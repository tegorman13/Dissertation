[
  {
    "objectID": "plan.html",
    "href": "plan.html",
    "title": "plan",
    "section": "",
    "text": "Writing Plan\n\n\nCurrent Progress\n\n\n\nSection\nPercentage\n\n\n\n\nVariability Intro\n30%\n\n\nIGAS Study\n90%\n\n\nHTW Study\n40%\n\n\n* Function Learning Review\n0%\n\n\n* Function Learning + Variability connection\n0%\n\n\n* Experimental Methods\n40%\n\n\n* Results\n10%\n\n\n* Modelling\n10%\n\n\n* Discussion\n0%\n\n\nSynthesis Model\n0%\n\n\nGeneral Discussion\n0%"
  },
  {
    "objectID": "index.html#project-2",
    "href": "index.html#project-2",
    "title": "Dissertation",
    "section": "Project 2",
    "text": "Project 2\nLink to HTW project page\n\nWorking Draft of HTW Manuscript",
    "crumbs": [
      "Dissertation"
    ]
  },
  {
    "objectID": "Sections/Introduction.html",
    "href": "Sections/Introduction.html",
    "title": "Variability and Generalization",
    "section": "",
    "text": "The factors that influence the generalization of learning are of considerable interest to both researchers exploring the human learning system and practitioners aiming to enhance the effectiveness of educational and training interventions. The present effort will focus specifically on the role of variability in the learning input. Variability manipulations typically regulate either the number of distinct instances presented to learners during training, or the dispersion of these instances. Such manipulations have been empirically demonstrated to affect subsequent generalization performance. This essay will offer an in-depth review of the extant literature on the influence of variability, spanning multiple relevant domains.\n\n\nStudies investigating the “benefits of variability” hypothesis usually assign participants to either a constant or varied group for the training stage of the experiment. Then, subjects in both groups complete an identical testing stage which often consists items/conditions seen during training, and novel items/conditions. If the varied group performs better in the testing stage, this is taken for evidence of the benefits of variability hypothesis. Even within this relatively straightforward between-groups design, researchers must navigate several crucial methodological choices, highlighted below:\n\nVariables Subject to Variation. In multidimensional tasks, researchers have the option to vary numerous variables. The experimenters must decide the specific dimension(s) across which variation will occur. For instance, in a projectile throwing accuracy task – researchers might vary the distance from the target, the size of the target, the weight of the projectile. They might also vary a contextual variable not directly relevant to the task, but which will still be encoded by the subject on a trial by trial basis, e.g. the background color.\nMagnitude of Variation, relative to the control condition. The simplest comparison would be to compare a constant group who trains with 1 example/condition, against a varied group that trains from 2 examples/conditions. However, it is not uncommon in the literature for the varied condition to train from 3 or 4 conditions. For example, Catalano & Kleiner (1984) train varied subjects from 4 different velocities in their coincident timing task, and (Goode et al., 2008) have varied subjects’ practice with 3 different variants (i.e. different letter scrambles of the same word) of an anagram for a given word, while their constant participants view the same variant 3 different times. Alternatively, rather than a constant vs. varied comparison, subjects in all conditions might experience a variety of training items, but with one group experiencing a greater number of unique items (Nosofsky, Sanders, Zhu, et al., 2018).\nLocations within Task-Space. For tasks in which the stimuli or conditions fall within a continuous metric space, the experimenter must decide whether the varied instances are relatively close together (e.g. throwing a ball from a distance of 4 feet and 5 feet), or far apart (throwing from 4 feet and 20 feet). Spreading the varied training items further apart may be beneficial in terms of providing a more representative sample of the task space to the learner, however large distances may also result in significant differences in difficulty between the training examples, which can be a common confound in variability studies.\nProximity of Testing to Training Conditions. Intuitively, the fairest form of comparison is to include testing conditions that are of an equivalent distance from both the varied and constant groups. However researchers might also attempt to demonstrate the benefits of variation as being sufficiently powerful to outperform constant training, even in cases where the constant group trained from a closer proximity to the testing conditions, or whose training conditions are identical to the testing conditions (Goode et al., 2008; Kerr & Booth, 1978).\n\n\n\n\nAn early and influential work on the influence of variability on category learning is that of Posner & Keele (1968). In an ambitious attempt to address the question of how category information is represented, the authors trained participants to categorize artificial dot patterns, manipulating whether learners were exposed to examples clustered close to the category prototypes (e.g. a low variability condition), or spread further away from the prototype (the varied-training group). It should be noted that both groups in this study were trained with the same number of unique instances and the manipulated difference was how spread out the instances were. The authors claim based on prior experiments using the same stimuli, that the training stimuli for the varied group were at least as far away from the testing stimuli as the training stimuli of the less-varied group. The authors interpreted their findings as evidence for the extraction of an abstraction or schema that is extracted and stored, and then over time becomes more likely to be the reference point from which generalization occurs, given that specific instances are thought to decay at a faster rate than prototypes or schema. The Posner and Keele study has been extremely influential and continues to be cited in contemporary research as clear evidence that schema abstraction underlies the benefits of varied training. It’s also referenced as a key influence in the development of “Schema Theory of Motor Learning” (Schmidt, 1975), which in turn influenced decades of investigations on the potential benefits of varied training in motor skill learning. However, the classic Posner & Keele study despite being far more carefully designed than many subsequent studies, and despite being a relative rarity in explicitly discussing and attempting to control for potential confounds of similarity between groups, may nevertheless be emblematic of a common issue in many investigations of the effects of varied training on learning. The problem with Posner & Keele’s conclusion was demonstrated clearly almost 3 decades later (Palmeri & Nosofsky, 2001), when researchers conducting a near replication of the original study also collected similarity judgements following training and performed multidimensional scaling analysis. Rather than being in the middle of the training stimuli as was the case in the physical stimuli space, the psychological representation of the prototype was shown reside at an extreme point, and generalization patterns by participants that would have seemed to warrant the learning of a prototype were then easily accounted for with only the assumption that the participants encoded instances. One of the primary concerns of the present paper is that many of the studies which purport to explain the benefits of variation via prototypes, schemas, or other abstractions, are often overlooking the potential of instance based similarity accounts.\n\n\n\nTraining variation has also been shown to promote transfer in motor learning. Much of this research has been influenced by the work of (Schmidt, 1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. Schema theory presumes a priori that learners possess general motor programs for classes of movements, such as an underhand throw. When called up for use, such programs must be parameterized, as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class, such as an underhand throw (though it is agnostic to the development of the movement classes themselves). Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices with multiple instances along some task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations.\nOne of the earliest, and still often cited investigations of Schmidt’s benefits of variability hypothesis was the work of Kerr & Booth (1978). Two groups of children, aged 8 and 12, were assigned to either constant or varied training of a bean bag throwing task. The constant group practiced throwing a bean-bag at a small target placed 3 feet in front of them, and the varied group practiced throwing from a distance of both 2 feet and 4 feet. Participants were blindfolded and unable to see the target while making each throw but would receive feedback by looking at where the beanbag had landed in between each training trial. 12 weeks later, all of the children were given a final test from a distance of 3 feet which was novel for the varied participants and repeated for the constant participants. Participants were also blindfolded for testing and did not receive trial by trial feedback in this stage. However, at the halfway point of the testing stage they were allowed to see the landing location of the 4 beanbags they had thrown, and then completed the final 4 testing throws. In both age groups, participants performed significantly better in the varied condition than the constant condition, though the effect was larger for the younger, 8-year-old children. Although this design does not directly assess the hypothesis of varied training producing superior generalization to constant training (since the constant group is not tested from a novel position), it nevertheless offers a compelling example of the merits of varied practice.\nOn occasion the Kerr and Booth design may be nested within a larger experimental design. One such study that used a movement timing task, wherein subjects had to move their hand from a starting location, to a target location, attempting to arrive at the target location at specific time following the onset of a cue (Wrisberg et al., 1987). This study utilized 4 different constant groups, and 3 varied groups, with one of the constant groups training under conditions identical to the testing conditions, and which were not trained on by any of the varied groups, e.g. the design of Kerr and Booth. However, in this case the varied group did not outperform the constant group. A more recent study attempting a slightly more direct replication of the original Kerr & Booth study (Willey & Liu, 2018), having subjects throw beanbags at a target, with the varied group training from positions (5 and 9 feet) on either side of the constant group (7 feet). However, this study diverged from the original in that the participants were adults; they faced away from the target and threw the beanbag backwards over their bodies; they alternated using their right and left hands every 6 trials; and underwent a relatively extreme amount of training (20 sessions with 60 practice trials each, spread out over 5-7 weeks). Like Wrisberg et al. (1987), this study did not find a varied advantage from the constant training position, though the varied group did perform better at distances novel to both groups.\nSome support for the Kerr and Booth findings was found with a relatively less common experimental task of training participants in hitting a projectile at a target with the use of a racket (Green et al., 1995). Varied participants trained with tennis, squash, badminton, and short-tennis rackets were compared against constant subjects trained with only a tennis racket. One of the testing conditions had subjects repeat the use of the tennis racket, which had been used on all 128 training trials for the constant group, and only 32 training trials for the varied group. Nevertheless, the varied group outperformed the constant group when using the tennis racket at testing, and also performed better in conditions with several novel racket lengths. Of course, this finding is less surprising than that of Kerr & Booth, given that varied subjects did have some prior exposure to the constant groups condition. This highlights an issue rarely discussed in the literature, of how much practice from an additional position might be necessary to induce benefits. Experimenters almost uniformly have varied participants train with an equivalent number of trials from each of their conditions\nOne of the few studies that has replicated the surprising result of varied outperforming constant, from the constant training condition, did so in the relatively distant domain of verbal manipulation (Goode et al., 2008). All participants trained to solve anagrams of 40 different words ranging in length from 5 to 11 letters, with an anagram of each word repeated 3 times throughout training, for a total of 120 training trials. Although subjects in all conditions were exposed to the same 40 unique words (i.e. the solution to an anagram), participants in the varied group saw 3 different arrangements for each solution-word, such as DOLOF, FOLOD, and OOFLD for the solution word FLOOD, whereas constant subjects would train on three repetitions of LDOOF (spread evenly across training). Two different constant groups were used. Both constant groups trained with three repetitions of the same word scramble, but for constant group A, the testing phase consisted of the identical letter arrangement to that seen during training (e.g. LDOOF), whereas for constant group B, the testing phase consisted of a arrangement they had not seen during training, thus presenting them with a testing situation similar situation to the varied group. At the testing stage, the varied group outperformed both constant groups, a particularly impressive result, given that constant group A had 3 prior exposures to the word arrangement (i.e. the particular permutation of letters) which the varied group had not explicitly seen. However varied subjects in this study did not exhibit the typical decrement in the training phase typical of other varied manipulations in the literature, and actually achieved higher levels of anagram solving accuracy by the end of training than either of the constant groups – solving 2 more anagrams on average than the constant group. This might suggest that for tasks of this nature where the learner can simply get stuck with a particular word scramble, repeated exposure to the identical scramble might be less helpful towards finding the solution than being given a different arrangement of the same letters. This contention is supported by the fact that constant group A, who was tested on the identical arrangement as they experienced during training, performed no better at testing than did constant group B, who had trained on a different arrangement of the same word solution – further suggesting that there may not have been a strong identity advantage in this task.\nPitting varied against constant practice against each other on the home turf of the constant group provides a compelling argument for the benefits of varied training, as well as an interesting challenge for theoretical accounts that posit generalization to occur as some function of distance. However, despite its appeal this particular contrast is relatively uncommon in the literature. It is unclear whether this may be cause for concern over publication bias, or just researchers feeling the design is too risky. A far more common design is to have separate constant groups that each train exclusively from each of the conditions that the varied group encounters (Catalano & Kleiner, 1984; Chua et al., 2019; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976), or for a single constant group to train from just one of the conditions experienced by the varied participants (Pigott & Shapiro, 1984; Roller et al., 2001; Wrisberg & McLean, 1984; Wrisberg & Mead, 1983). A less common contrast places the constant group training in a region of the task space outside of the range of examples experienced by the varied group, but distinct from the transfer condition (Wrisberg et al., 1987; Wulf & Schmidt, 1997).\nOf particular relevant to the current essay is the early work of Catalano & Kleiner (1984), as theirs was one of the earliest studies to investigate the influence of varied vs. constant training on multiple testing locations of graded distance from the training condition. Participants were trained on coincident timing task, in which subjects observe a series of lightbulbs turning on sequentially at a consistent rate and attempt to time a button response with the onset of the final bulb. The constant groups trained with a single velocity of either 5,7,9, or 11 mph, while the varied group trained from all 4 of these velocities. Participants were then assigned to one of four possible generalization conditions, all of which fell outside of the range of the varied training conditions – 1, 3, 13 or 15 mph. As is often the case, the varied group performed worse during the training phase. In the testing phase, the general pattern was for all participants to perform worse as the testing conditions became further away from the training conditions, but since the drop off in performance as a function of distance was far less steep for the varied group, the authors suggested that varied training induced a decremented generalization gradient, such that the varied participants were less affected by the change between training and testing conditions.\n\n\n\nIn the category learning literature, the constant vs. varied comparison is much less suitable. Instead, researchers tend to compare a condition with many repetitions of a few items against condition with fewer repetitions of a wider array of exemplars. Much of the earlier work in this sub-area trained subjects on artificial categories, such as dot patterns (Homa & Vosburgh, 1976; Posner & Keele, 1968), where more varied or distorted training examples were often shown to produce superior generalization when categorizing novel exemplars. More recently, researchers have also begun to utilize more realistic stimuli in their experiments. Wahlheim et al. (2012) conducted one such study. In a within-participants design, participants were trained on bird categories with either high repetitions of a few exemplars, or few repetitions of many exemplars. Across four different experiments, which were conducted to address an unrelated question on metacognitive judgements, the researchers consistently found that participants generalized better to novel species following training with more unique exemplars (i.e. higher variability), while high repetition training produced significantly better performance categorizing the specific species they had trained on. A variability advantage was also found in the relatively complex domain of rock categorization (Nosofsky, Sanders, & McDaniel, 2018). For 10 different rock categories, participants were trained with either many repetitions of 3 unique examples of each category, or few repetitions of 9 unique examples, with an equal number of total training trials in each group (the design also included 2 other conditions less amenable to considering the impact of variation). The high-variability group, trained with 9 unique examples, showed significantly better generalization performance than the other conditions. Moreover, the pattern of results in this study could be nicely accounted for by an extended version of the Generalized Context Model.\nThe studies described thus far have studied the benefits of variability by exposing participants to a greater or lesser number of distinct examples during training. A distinct sub-literature within the category learning domain has focused much less on benefits derived from varied training, instead emphasizing how increased variability during the learning of a novel category influences how far the category boundary will then be generalized. The general approach is to train participants on examples from two categories, with the examples from one of the categories being more dispersed than the other. Participants are then tested with novel items located within ambiguous regions of the task space which allow the experimenters to assess whether the difference in variability influences how far participants generalize the category boundaries.\nCohen et al. (2001) trained subjects on two categories, one with much more variability than the other. In experiment 1, a low variability category composed of 1 instance was compared against a high-variability category of 2 instances in one condition, and 7 instances in another. In experiment 2 both categories were composed of 3 instances, but for the low-variability group the instances were clustered close to each other, whereas the high-variability groups instances were spread much further apart. Participants were tested on an ambiguous novel instance that was located in between the two trained categories. Both experiments provided evidence that participants were much more likely to categorize the novel middle stimulus into a category with greater variation. Moreover, this effect was at odds with the predications of the baseline version of the GCM, thus providing some evidence that training variation may at least sometimes induce effects that cannot be entirely accounted for by exemplar-similarity accounts.\nFurther observations consonant with the results of Cohen et al. (2001) have since been observed in numerous investigations (Hahn et al., 2005; Hsu & Griffiths, 2010; Perlman et al., 2012; Sakamoto et al., 2008). The results of Sakamoto et al. (2008) are noteworthy. They first reproduced the basic finding of participants being more likely to categorize an unknown middle stimulus into a training category with higher variability. In a second experiment, they held the variability between the two training categories constant and instead manipulated the training sequence, such that the examples of one category appeared in an ordered fashion, with very small changes from one example to the other (the stimuli were lines that varied only in length), whereas examples in the alternate category were shown in a random order and thus included larger jumps in the stimulus space from trial to trial. They found that the middle stimulus was more likely to be categorized into the category that had been learned with a random sequence, which was attributed to an increased perception of variability which resulted from the larger trial to trial discrepancies.\nThe work of Hahn et al. (2005), is also of particular interest to the present discussion. Their experimental design was similar to previous studies, but they included a larger set of testing items which were used to assess generalization both between the two training categories as well as novel items located in the outer edges of the training categories. During generalization testing, participants were given the option to respond with “neither”, in addition to responses to the two training categories. The “neither” response was included to test how far away in the stimulus space participants would continue to categorize novel items as belonging to a trained category. Consistent with prior findings, high-variability training resulted in an increased probability of categorizing items in between the training categories as belong to the high variability category. Additionally, participants trained with higher variability also extended the category boundary further out into the periphery than participants trained with a lower variability category were willing to do. The authors then used the standard GCM framework to compare a variety of similarity-based models to account for their results. Of particular interest are their evaluations of a category response bias parameter, and a similarity scaling parameter. A model fit improvement when the response bias parameter is allowed to vary between the high-variability and low-variability trained groups is taken to suggest a simple bias for responding with one of the trained categories over the other. Alternatively, an improvement in fit due to a separate similarity scaling parameter may reflect the groups being differentially sensitive to the distances between stimuli. No improvement in model fit was found by allowing the response-bias parameter to differ between groups, however the model performance did improvement significantly when the similarity scaling parameter was fit separately. The best fitting similarity-scaling parameters were such that the high-variability group was less sensitive to the distances between stimuli, resulting in greater similarity values between their training items and testing items. This model accounted for both the extended generalization gradients of the varied particpants, and also for their poor performance in a recognition condition. Additional model comparisons suggested that this similarity rescaling applied across the entire stimulus space, rather than to the high variability category in particular.\nVariability effects have also been examined in the higher-level domain of how learners acquire novel concepts, and then instantiate (rather than merely recognize) that concept in untrained contexts (Braithwaite & Goldstone, 2015). This study trained participants on problems involving the concept of sampling with replacement (SWR). Training consisted of examples that were either highly similar in their semantic context (e.g. all involving people selecting objects) or in which the surface features were varied between examples (e.g. people choosing objects AND objects selected in a sequence). The experimenters also surveyed how much prior knowledge each participant had with SWR. They found that whether variation was beneficial depended on the prior knowledge of the participants – such that participants with some prior knowledge benefited from varied training, whereas participants with minimal prior knowledge performed better after training with similar examples. The authors hypothesized that in order to benefit from varied examples, participants must be able to detect the structure common to the diverse examples, and that participants with prior knowledge are more likely to be sensitive to such structure, and thus to benefit from varied training. To test this hypothesis more directly, the authors conducted a 2nd experiment, wherein they controlled prior knowledge by exposing some subjects to a short graphical or verbal pre-training lesson, designed to increase sensitivity to the training examples. Consistent with their hypothesis, participants exposed to the structural sensitivity pre-training benefited more from varied training than the controls participants who benefited more from training with similar examples.\nVariability has also been examined within the realm of language learning. A particularly impressive study is that of (Perry et al., 2010). In nine training sessions spread out over nine weeks infants were trained on object labels in a naturalistic play setting. All infants were introduced to three novel objects of the same category, with participants in the tight condition being exposed to three similar exemplars of the category, and participants in the varied condition being exposed to three dissimilar objects of the same category. Importantly, the similarity of the objects was carefully controlled for by having a separate group of adult subjects provide pairwise similarity judgements of the category objects prior to the study onset. Multidimensional scaling was then performed to obtain the coordinates of the objects psychological space, and out of the 10 objects for each category, the 3 most similar objects were selected for the tight group and the three least similar objects for the varied group, with the leftover four objects being retained for testing. By the end of the nine weeks, all of the infants had learned the labels of the training objects. The varied group demonstrated superior ability to correctly generalize the object labels to untrained exemplars of the same category, a pattern consistent with much of the existing literature. More interesting was the superior performance of the varied group on a higher order generalization task – such that they were able to appropriately generalize the bias they had learned during training for attending to the shape of objects to novel solid objects, but not to non-solids. The tight training group, on the other hand, tended to overgeneralize the shape bias, leading the researchers to suggest that the varied training induced a more context-sensitive understanding of when to apply their knowledge.\n\n\n\n\n\nA necessary consequence of varied training is that participants will have the experience of switching from one task condition to another. The number of switches can vary greatly, with the two extremes being varied participants completing all of their training trials in one before switching to the next condition (blocked sequencing), or if they alternate between conditions on a trial by trial basis (random/intermixed/interleaved sequencing). Not long after the initial influx of schema-theory inspired studies testing the benefits of variability hypothesis was shown that the influence of varied training might interact with the type of training sequence chosen by the experimenter (J. B. Shea & Morgan, 1979). In this seminal study, both groups of training subjects trained with the same number of trials of three separate movement patterns. A blocked group that completed all of their trials with one sequence before beginning the next sequence, and a random group that trained with all three movement patterns interspersed throughout the course of training. Participants were also randomly assigned to retention testing under either blocked or random sequence conditions, thus resulting in all four training-testing combinations of blocked-blocked; blocked-random; random-blocked; random-random. There was some effect of sequence context, such that both groups performed better when the testing sequence matched their training sequence. However, the main finding of interest was the advantage of random-training, which resulted in superior testing performance than blocked training regardless of whether the testing stage had a blocked or random sequence, an effect observed both immediately after training, and in a follow up test ten days after the end of training.\nPrior to the influential J. B. Shea & Morgan (1979) study, studies investigating the benefits of variability hypothesis had utilized both blocked and random training schedules, often without comment or justification. It was later observed (Lee et al., 1985) that positive evidence for benefits of varied training seemed more likely to occur for studies that utilized random schedules. The theoretical basis of such studies was invariably an appeal to Schmidt’s schema theory; however schema theory made no clear predictions of an effect of study sequence on retention or generalization, thus prompting the need for alternate accounts. One such account, the elaborative processing account (J. B. Shea & Zimny, 1983), draws on the earlier work (Battig, 1966) and argues that randomly sequencing conditions during training promotes comparison and contrastive processes between those conditions, which result in a deeper understanding of the training task than could arise via blocked sequencing. Supporting evidence for elaborative processing comes in the form of random-sequence trained subjects self-reporting more nuanced mental representations of movement patterns following training (J. B. Shea & Zimny, 1983), and by manipulating whether subjects are able to perform comparisons during training (Wright et al., 1992). An alternative, though not incompatible account suggests that the benefits of random-sequencing are a result of such sequences forcing the learner to continually reconstruct the relevant motor task in working memory (Lee & Magill, n.d.). Blocked training, on the other hand, allows the learner to maintain the same motor task in short term memory without decay for much of the training which facilitates training performance, but hinders ability to retrieve the appropriate motor memory in a later testing context. A much more recent study (Chua et al., 2019), replicates the standard findings of an advantage of varied training over constant training (expt 1, bean-bag throwing task), and of random training over blocked training (expt 2 & 3, bean-bag throwing & golf putting). The novelty of this study is that the experimenters queried subjects about their attentional focus throughout the training stage. In all three experiments varied or random trained-subjects reported significantly greater external attention (e.g. attending to the target distance), and constant or blocked subjects reported more internal attention (e.g. posture or hand position). The authors argue that the benefits of varied/random training may be mediated by changes in attentional focus, however the claims made in the paper seem to go far beyond what can be justified by the analyses reported – e.g. the increased external focus could be a simple byproduct of varied training. A stronger form of evidence that was not provided may have been to use multiple regression analyses to show that the testing advantage of the varied/random groups over the constant/blocked groups could be accounted for by the differences in self-reported attentional focus.\n\n\n\n\nOf course, the effects of varied training, and different training sequences, are likely to be far more complex than simply more varied training being better than less, or random training being better than blocked. Null effects of both manipulations have been reported (see Magill & Hall, 1990; Van Rossum, 1990 for reviews), and a variety of moderators have emerged. In one of the earlier examples of the complex relationship between study sequence and learning (Del Rey et al., 1982), experimenters recruited participants who self-reported either large amounts, or very little experience with athletic actives, and then trained participants on a coincident timing task under with either a single constant training velocity, or with four training velocities under either blocked, or random training sequence conditions - resulting in six experimental conditions: (athlete vs. non-athlete) x (constant vs. blocked vs. random training). Athlete participants had superior performance during training, regardless of sequence condition, and training performance was superior for all subjects in the constant group, followed by blocked training in the middle, and then random training resulting in the worst training performance. Of greater interest is the pattern of testing results for novel transfer conditions. Among the athlete-participants, transfer performance was best for those who received random training, followed by blocked, and then constant training. Non-athletes showed the opposite pattern, with superior performance for those who had constant training. A similar pattern was later observed in a golf-putting training study, wherein participants who had some prior golf experience benefited most from random-sequenced training, and participants with no golf experience benefited most from blocked training (Guadagnoli et al., 1999). More recently, the same pattern was observed in the concept learning literature (Braithwaite & Goldstone, 2015 expt 1.). This study trained participants on a mathematical concept and found that participants who self-reported some prior experience with the concept improved more from pre-test to post-test after training with varied examples, while participants who reported no prior experience showed greater gains following training with highly similar examples.\nIn addition to the influence of prior experiences described above, ample evidence also suggests that numerous aspects of the experiment may also interact with the influence of variation. One important study examined the impact of the amount of training completed in a force production task (C. H. Shea et al., 1990). This study employed a typical blocked vs. random training procedure, but with the additional manipulation of separate groups receiving 50, 200, or 400 total training trials. For the group that received only 50 training trials retention was best when training had been blocked. However, for the conditions that received 200 or 400 training trials the pattern was reversed, with random training resulting in superior retention than blocked training. These results were taken to suggest that the benefits of randomization may take time to emerge. Another experimental factor shown to interact with training sequence is the complexity of the training task (Albaret & Thon, 1998). In addition to random or blocked training, participants in this study were assigned to train on a drawing task at one of three different levels of complexity (reproducing from memory shapes composed of two, three or four components). On a transfer task 48 hours after the completion of training, only participants trained at the lower levels of task complexity (2 or 3 components) showed superior performance to the blocked condition. The authors suggest that the benefits of random sequencing, thought to arise from more elaborate cognitive processing, or the necessity of continually recalling task information from long term into short term memory, are more likely to be obscured as the complexity of the task forces the blocked participants to also engage in such processes.\nA final important influence of particular relevance to the practice-sequence literature concerns the exact structure of “random” sequencing. Although the term random is commonly used for convenience, experimenters do not typically leave the order of training entirely up to chance. Rather, the training sequence is often constrained such that each condition must occur a minimum number of times in each quartile of the training phase, thus resulting in an even distribution the conditions throughout training. While the assurance of the conditions being evenly spread throughout training is consistent across studies, other aspects of the sequence structure are a bit more idiosyncratic. Some researchers report setting a maximum number of consecutive repetitions, e.g. no more than 2 consecutive trials of the same condition (Del Rey et al., 1982; J. B. Shea & Morgan, 1979), or structure the random trials such that the same condition never occurs consecutively (Wulf, 1991). Also common is to structure experiments such that random condition really consists of many small blocks, where participants do a few trials of one condition consecutively and then switch to another condition (Chua et al., 2019; Willey & Liu, 2018; Wrisberg et al., 1987), resulting in many more switches than would arise if training was perfectly blocked. The question of whether such differences in the structure of random sequencing are consequential has been addressed experimentally a few times, in all cases consisting of a 1) a no-repeat random condition; 2) a blocked random condition (typically 3 or 4 repeats before a switch); and 3) a standard fully-blocked condition. Blocked-random training resulted in better performance than either repeat-random, or fully - blocked training in both a bean-bag throwing (Pigott & Shapiro, 1984), and basketball shot training study (Landin & Hebert, 1997), and in a replication plus extension of the seminal (J. B. Shea & Morgan, 1979) study, blocked-random training was equally effective as no-repeat random training, with both random structures leading to better performance than the fully-blocked training condition. Consequences on different study schedules have also been repeatedly observed in the category learning literature (Carvalho & Goldstone, 2014, 2017). This line of research has revealed that the effects of blocking vs. interleaving can depend on the structure of the category being learned, and also that the different schedules can result in the participants requiring different representations. A fruitful line of inquiry in the motor skill learning literature may be to attempt to identify whether structural aspects of the motor task interact with different training sequences in a reliable manner.\nNumerous researchers have attempted to provide coherent frameworks to account for the full range of influences of training variation and sequencing described above (along with many other effects not discussed). Such accounts are generally quite similar, invoking ideas of desirable levels of difficulty (Bjork & Bjork, 1992; Schmidt & Bjork, 1992), or optimal challenge points (Guadagnoli & Lee, 2004). They tend to start by describing the dissociation between acquisition performance (performance during training) and testing performance (delayed retention and/or transfer), most strikingly observed as varied/random training participants performing worse than their constant/blocked counterparts during the training stage of the study, but then outperforming the constant/blocked comparisons at a later retention or transfer stage. This observation is then used to justify the idea that the most enduring and generalizable learning occurs by training at an optimal level of training difficulty, with difficulty being some function of the experience of the learner, and the cognitive or visuomotor processing demands of the task. It then follows that the factors that tend to make training more difficult (i.e. increased variability or randomization), are more likely to be beneficial when the learner has some experience, or when the processing demands of the task are not too extreme (which may only occur after some experience with the task). Such frameworks may be helpful heuristics in some cases, but they also seem to be overly flexible such that any null result of some intervention might be accounted for by a suboptimal amount of training trials, or by suggesting the training task was too difficult. The development of computational models that can account for how changes in the parameters of the motor-skill task scale with difficulty, would be a great step forward.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#the-study-of-variability",
    "href": "Sections/Introduction.html#the-study-of-variability",
    "title": "Variability and Generalization",
    "section": "",
    "text": "Studies investigating the “benefits of variability” hypothesis usually assign participants to either a constant or varied group for the training stage of the experiment. Then, subjects in both groups complete an identical testing stage which often consists items/conditions seen during training, and novel items/conditions. If the varied group performs better in the testing stage, this is taken for evidence of the benefits of variability hypothesis. Even within this relatively straightforward between-groups design, researchers must navigate several crucial methodological choices, highlighted below:\n\nVariables Subject to Variation. In multidimensional tasks, researchers have the option to vary numerous variables. The experimenters must decide the specific dimension(s) across which variation will occur. For instance, in a projectile throwing accuracy task – researchers might vary the distance from the target, the size of the target, the weight of the projectile. They might also vary a contextual variable not directly relevant to the task, but which will still be encoded by the subject on a trial by trial basis, e.g. the background color.\nMagnitude of Variation, relative to the control condition. The simplest comparison would be to compare a constant group who trains with 1 example/condition, against a varied group that trains from 2 examples/conditions. However, it is not uncommon in the literature for the varied condition to train from 3 or 4 conditions. For example, Catalano & Kleiner (1984) train varied subjects from 4 different velocities in their coincident timing task, and (Goode et al., 2008) have varied subjects’ practice with 3 different variants (i.e. different letter scrambles of the same word) of an anagram for a given word, while their constant participants view the same variant 3 different times. Alternatively, rather than a constant vs. varied comparison, subjects in all conditions might experience a variety of training items, but with one group experiencing a greater number of unique items (Nosofsky, Sanders, Zhu, et al., 2018).\nLocations within Task-Space. For tasks in which the stimuli or conditions fall within a continuous metric space, the experimenter must decide whether the varied instances are relatively close together (e.g. throwing a ball from a distance of 4 feet and 5 feet), or far apart (throwing from 4 feet and 20 feet). Spreading the varied training items further apart may be beneficial in terms of providing a more representative sample of the task space to the learner, however large distances may also result in significant differences in difficulty between the training examples, which can be a common confound in variability studies.\nProximity of Testing to Training Conditions. Intuitively, the fairest form of comparison is to include testing conditions that are of an equivalent distance from both the varied and constant groups. However researchers might also attempt to demonstrate the benefits of variation as being sufficiently powerful to outperform constant training, even in cases where the constant group trained from a closer proximity to the testing conditions, or whose training conditions are identical to the testing conditions (Goode et al., 2008; Kerr & Booth, 1978).",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#variability-literature-review",
    "href": "Sections/Introduction.html#variability-literature-review",
    "title": "Variability and Generalization",
    "section": "",
    "text": "An early and influential work on the influence of variability on category learning is that of Posner & Keele (1968). In an ambitious attempt to address the question of how category information is represented, the authors trained participants to categorize artificial dot patterns, manipulating whether learners were exposed to examples clustered close to the category prototypes (e.g. a low variability condition), or spread further away from the prototype (the varied-training group). It should be noted that both groups in this study were trained with the same number of unique instances and the manipulated difference was how spread out the instances were. The authors claim based on prior experiments using the same stimuli, that the training stimuli for the varied group were at least as far away from the testing stimuli as the training stimuli of the less-varied group. The authors interpreted their findings as evidence for the extraction of an abstraction or schema that is extracted and stored, and then over time becomes more likely to be the reference point from which generalization occurs, given that specific instances are thought to decay at a faster rate than prototypes or schema. The Posner and Keele study has been extremely influential and continues to be cited in contemporary research as clear evidence that schema abstraction underlies the benefits of varied training. It’s also referenced as a key influence in the development of “Schema Theory of Motor Learning” (Schmidt, 1975), which in turn influenced decades of investigations on the potential benefits of varied training in motor skill learning. However, the classic Posner & Keele study despite being far more carefully designed than many subsequent studies, and despite being a relative rarity in explicitly discussing and attempting to control for potential confounds of similarity between groups, may nevertheless be emblematic of a common issue in many investigations of the effects of varied training on learning. The problem with Posner & Keele’s conclusion was demonstrated clearly almost 3 decades later (Palmeri & Nosofsky, 2001), when researchers conducting a near replication of the original study also collected similarity judgements following training and performed multidimensional scaling analysis. Rather than being in the middle of the training stimuli as was the case in the physical stimuli space, the psychological representation of the prototype was shown reside at an extreme point, and generalization patterns by participants that would have seemed to warrant the learning of a prototype were then easily accounted for with only the assumption that the participants encoded instances. One of the primary concerns of the present paper is that many of the studies which purport to explain the benefits of variation via prototypes, schemas, or other abstractions, are often overlooking the potential of instance based similarity accounts.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#motor-skill-learning",
    "href": "Sections/Introduction.html#motor-skill-learning",
    "title": "Variability and Generalization",
    "section": "",
    "text": "Training variation has also been shown to promote transfer in motor learning. Much of this research has been influenced by the work of (Schmidt, 1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. Schema theory presumes a priori that learners possess general motor programs for classes of movements, such as an underhand throw. When called up for use, such programs must be parameterized, as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class, such as an underhand throw (though it is agnostic to the development of the movement classes themselves). Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices with multiple instances along some task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations.\nOne of the earliest, and still often cited investigations of Schmidt’s benefits of variability hypothesis was the work of Kerr & Booth (1978). Two groups of children, aged 8 and 12, were assigned to either constant or varied training of a bean bag throwing task. The constant group practiced throwing a bean-bag at a small target placed 3 feet in front of them, and the varied group practiced throwing from a distance of both 2 feet and 4 feet. Participants were blindfolded and unable to see the target while making each throw but would receive feedback by looking at where the beanbag had landed in between each training trial. 12 weeks later, all of the children were given a final test from a distance of 3 feet which was novel for the varied participants and repeated for the constant participants. Participants were also blindfolded for testing and did not receive trial by trial feedback in this stage. However, at the halfway point of the testing stage they were allowed to see the landing location of the 4 beanbags they had thrown, and then completed the final 4 testing throws. In both age groups, participants performed significantly better in the varied condition than the constant condition, though the effect was larger for the younger, 8-year-old children. Although this design does not directly assess the hypothesis of varied training producing superior generalization to constant training (since the constant group is not tested from a novel position), it nevertheless offers a compelling example of the merits of varied practice.\nOn occasion the Kerr and Booth design may be nested within a larger experimental design. One such study that used a movement timing task, wherein subjects had to move their hand from a starting location, to a target location, attempting to arrive at the target location at specific time following the onset of a cue (Wrisberg et al., 1987). This study utilized 4 different constant groups, and 3 varied groups, with one of the constant groups training under conditions identical to the testing conditions, and which were not trained on by any of the varied groups, e.g. the design of Kerr and Booth. However, in this case the varied group did not outperform the constant group. A more recent study attempting a slightly more direct replication of the original Kerr & Booth study (Willey & Liu, 2018), having subjects throw beanbags at a target, with the varied group training from positions (5 and 9 feet) on either side of the constant group (7 feet). However, this study diverged from the original in that the participants were adults; they faced away from the target and threw the beanbag backwards over their bodies; they alternated using their right and left hands every 6 trials; and underwent a relatively extreme amount of training (20 sessions with 60 practice trials each, spread out over 5-7 weeks). Like Wrisberg et al. (1987), this study did not find a varied advantage from the constant training position, though the varied group did perform better at distances novel to both groups.\nSome support for the Kerr and Booth findings was found with a relatively less common experimental task of training participants in hitting a projectile at a target with the use of a racket (Green et al., 1995). Varied participants trained with tennis, squash, badminton, and short-tennis rackets were compared against constant subjects trained with only a tennis racket. One of the testing conditions had subjects repeat the use of the tennis racket, which had been used on all 128 training trials for the constant group, and only 32 training trials for the varied group. Nevertheless, the varied group outperformed the constant group when using the tennis racket at testing, and also performed better in conditions with several novel racket lengths. Of course, this finding is less surprising than that of Kerr & Booth, given that varied subjects did have some prior exposure to the constant groups condition. This highlights an issue rarely discussed in the literature, of how much practice from an additional position might be necessary to induce benefits. Experimenters almost uniformly have varied participants train with an equivalent number of trials from each of their conditions\nOne of the few studies that has replicated the surprising result of varied outperforming constant, from the constant training condition, did so in the relatively distant domain of verbal manipulation (Goode et al., 2008). All participants trained to solve anagrams of 40 different words ranging in length from 5 to 11 letters, with an anagram of each word repeated 3 times throughout training, for a total of 120 training trials. Although subjects in all conditions were exposed to the same 40 unique words (i.e. the solution to an anagram), participants in the varied group saw 3 different arrangements for each solution-word, such as DOLOF, FOLOD, and OOFLD for the solution word FLOOD, whereas constant subjects would train on three repetitions of LDOOF (spread evenly across training). Two different constant groups were used. Both constant groups trained with three repetitions of the same word scramble, but for constant group A, the testing phase consisted of the identical letter arrangement to that seen during training (e.g. LDOOF), whereas for constant group B, the testing phase consisted of a arrangement they had not seen during training, thus presenting them with a testing situation similar situation to the varied group. At the testing stage, the varied group outperformed both constant groups, a particularly impressive result, given that constant group A had 3 prior exposures to the word arrangement (i.e. the particular permutation of letters) which the varied group had not explicitly seen. However varied subjects in this study did not exhibit the typical decrement in the training phase typical of other varied manipulations in the literature, and actually achieved higher levels of anagram solving accuracy by the end of training than either of the constant groups – solving 2 more anagrams on average than the constant group. This might suggest that for tasks of this nature where the learner can simply get stuck with a particular word scramble, repeated exposure to the identical scramble might be less helpful towards finding the solution than being given a different arrangement of the same letters. This contention is supported by the fact that constant group A, who was tested on the identical arrangement as they experienced during training, performed no better at testing than did constant group B, who had trained on a different arrangement of the same word solution – further suggesting that there may not have been a strong identity advantage in this task.\nPitting varied against constant practice against each other on the home turf of the constant group provides a compelling argument for the benefits of varied training, as well as an interesting challenge for theoretical accounts that posit generalization to occur as some function of distance. However, despite its appeal this particular contrast is relatively uncommon in the literature. It is unclear whether this may be cause for concern over publication bias, or just researchers feeling the design is too risky. A far more common design is to have separate constant groups that each train exclusively from each of the conditions that the varied group encounters (Catalano & Kleiner, 1984; Chua et al., 2019; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976), or for a single constant group to train from just one of the conditions experienced by the varied participants (Pigott & Shapiro, 1984; Roller et al., 2001; Wrisberg & McLean, 1984; Wrisberg & Mead, 1983). A less common contrast places the constant group training in a region of the task space outside of the range of examples experienced by the varied group, but distinct from the transfer condition (Wrisberg et al., 1987; Wulf & Schmidt, 1997).\nOf particular relevant to the current essay is the early work of Catalano & Kleiner (1984), as theirs was one of the earliest studies to investigate the influence of varied vs. constant training on multiple testing locations of graded distance from the training condition. Participants were trained on coincident timing task, in which subjects observe a series of lightbulbs turning on sequentially at a consistent rate and attempt to time a button response with the onset of the final bulb. The constant groups trained with a single velocity of either 5,7,9, or 11 mph, while the varied group trained from all 4 of these velocities. Participants were then assigned to one of four possible generalization conditions, all of which fell outside of the range of the varied training conditions – 1, 3, 13 or 15 mph. As is often the case, the varied group performed worse during the training phase. In the testing phase, the general pattern was for all participants to perform worse as the testing conditions became further away from the training conditions, but since the drop off in performance as a function of distance was far less steep for the varied group, the authors suggested that varied training induced a decremented generalization gradient, such that the varied participants were less affected by the change between training and testing conditions.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#category-learning",
    "href": "Sections/Introduction.html#category-learning",
    "title": "Variability and Generalization",
    "section": "",
    "text": "In the category learning literature, the constant vs. varied comparison is much less suitable. Instead, researchers tend to compare a condition with many repetitions of a few items against condition with fewer repetitions of a wider array of exemplars. Much of the earlier work in this sub-area trained subjects on artificial categories, such as dot patterns (Homa & Vosburgh, 1976; Posner & Keele, 1968), where more varied or distorted training examples were often shown to produce superior generalization when categorizing novel exemplars. More recently, researchers have also begun to utilize more realistic stimuli in their experiments. Wahlheim et al. (2012) conducted one such study. In a within-participants design, participants were trained on bird categories with either high repetitions of a few exemplars, or few repetitions of many exemplars. Across four different experiments, which were conducted to address an unrelated question on metacognitive judgements, the researchers consistently found that participants generalized better to novel species following training with more unique exemplars (i.e. higher variability), while high repetition training produced significantly better performance categorizing the specific species they had trained on. A variability advantage was also found in the relatively complex domain of rock categorization (Nosofsky, Sanders, & McDaniel, 2018). For 10 different rock categories, participants were trained with either many repetitions of 3 unique examples of each category, or few repetitions of 9 unique examples, with an equal number of total training trials in each group (the design also included 2 other conditions less amenable to considering the impact of variation). The high-variability group, trained with 9 unique examples, showed significantly better generalization performance than the other conditions. Moreover, the pattern of results in this study could be nicely accounted for by an extended version of the Generalized Context Model.\nThe studies described thus far have studied the benefits of variability by exposing participants to a greater or lesser number of distinct examples during training. A distinct sub-literature within the category learning domain has focused much less on benefits derived from varied training, instead emphasizing how increased variability during the learning of a novel category influences how far the category boundary will then be generalized. The general approach is to train participants on examples from two categories, with the examples from one of the categories being more dispersed than the other. Participants are then tested with novel items located within ambiguous regions of the task space which allow the experimenters to assess whether the difference in variability influences how far participants generalize the category boundaries.\nCohen et al. (2001) trained subjects on two categories, one with much more variability than the other. In experiment 1, a low variability category composed of 1 instance was compared against a high-variability category of 2 instances in one condition, and 7 instances in another. In experiment 2 both categories were composed of 3 instances, but for the low-variability group the instances were clustered close to each other, whereas the high-variability groups instances were spread much further apart. Participants were tested on an ambiguous novel instance that was located in between the two trained categories. Both experiments provided evidence that participants were much more likely to categorize the novel middle stimulus into a category with greater variation. Moreover, this effect was at odds with the predications of the baseline version of the GCM, thus providing some evidence that training variation may at least sometimes induce effects that cannot be entirely accounted for by exemplar-similarity accounts.\nFurther observations consonant with the results of Cohen et al. (2001) have since been observed in numerous investigations (Hahn et al., 2005; Hsu & Griffiths, 2010; Perlman et al., 2012; Sakamoto et al., 2008). The results of Sakamoto et al. (2008) are noteworthy. They first reproduced the basic finding of participants being more likely to categorize an unknown middle stimulus into a training category with higher variability. In a second experiment, they held the variability between the two training categories constant and instead manipulated the training sequence, such that the examples of one category appeared in an ordered fashion, with very small changes from one example to the other (the stimuli were lines that varied only in length), whereas examples in the alternate category were shown in a random order and thus included larger jumps in the stimulus space from trial to trial. They found that the middle stimulus was more likely to be categorized into the category that had been learned with a random sequence, which was attributed to an increased perception of variability which resulted from the larger trial to trial discrepancies.\nThe work of Hahn et al. (2005), is also of particular interest to the present discussion. Their experimental design was similar to previous studies, but they included a larger set of testing items which were used to assess generalization both between the two training categories as well as novel items located in the outer edges of the training categories. During generalization testing, participants were given the option to respond with “neither”, in addition to responses to the two training categories. The “neither” response was included to test how far away in the stimulus space participants would continue to categorize novel items as belonging to a trained category. Consistent with prior findings, high-variability training resulted in an increased probability of categorizing items in between the training categories as belong to the high variability category. Additionally, participants trained with higher variability also extended the category boundary further out into the periphery than participants trained with a lower variability category were willing to do. The authors then used the standard GCM framework to compare a variety of similarity-based models to account for their results. Of particular interest are their evaluations of a category response bias parameter, and a similarity scaling parameter. A model fit improvement when the response bias parameter is allowed to vary between the high-variability and low-variability trained groups is taken to suggest a simple bias for responding with one of the trained categories over the other. Alternatively, an improvement in fit due to a separate similarity scaling parameter may reflect the groups being differentially sensitive to the distances between stimuli. No improvement in model fit was found by allowing the response-bias parameter to differ between groups, however the model performance did improvement significantly when the similarity scaling parameter was fit separately. The best fitting similarity-scaling parameters were such that the high-variability group was less sensitive to the distances between stimuli, resulting in greater similarity values between their training items and testing items. This model accounted for both the extended generalization gradients of the varied particpants, and also for their poor performance in a recognition condition. Additional model comparisons suggested that this similarity rescaling applied across the entire stimulus space, rather than to the high variability category in particular.\nVariability effects have also been examined in the higher-level domain of how learners acquire novel concepts, and then instantiate (rather than merely recognize) that concept in untrained contexts (Braithwaite & Goldstone, 2015). This study trained participants on problems involving the concept of sampling with replacement (SWR). Training consisted of examples that were either highly similar in their semantic context (e.g. all involving people selecting objects) or in which the surface features were varied between examples (e.g. people choosing objects AND objects selected in a sequence). The experimenters also surveyed how much prior knowledge each participant had with SWR. They found that whether variation was beneficial depended on the prior knowledge of the participants – such that participants with some prior knowledge benefited from varied training, whereas participants with minimal prior knowledge performed better after training with similar examples. The authors hypothesized that in order to benefit from varied examples, participants must be able to detect the structure common to the diverse examples, and that participants with prior knowledge are more likely to be sensitive to such structure, and thus to benefit from varied training. To test this hypothesis more directly, the authors conducted a 2nd experiment, wherein they controlled prior knowledge by exposing some subjects to a short graphical or verbal pre-training lesson, designed to increase sensitivity to the training examples. Consistent with their hypothesis, participants exposed to the structural sensitivity pre-training benefited more from varied training than the controls participants who benefited more from training with similar examples.\nVariability has also been examined within the realm of language learning. A particularly impressive study is that of (Perry et al., 2010). In nine training sessions spread out over nine weeks infants were trained on object labels in a naturalistic play setting. All infants were introduced to three novel objects of the same category, with participants in the tight condition being exposed to three similar exemplars of the category, and participants in the varied condition being exposed to three dissimilar objects of the same category. Importantly, the similarity of the objects was carefully controlled for by having a separate group of adult subjects provide pairwise similarity judgements of the category objects prior to the study onset. Multidimensional scaling was then performed to obtain the coordinates of the objects psychological space, and out of the 10 objects for each category, the 3 most similar objects were selected for the tight group and the three least similar objects for the varied group, with the leftover four objects being retained for testing. By the end of the nine weeks, all of the infants had learned the labels of the training objects. The varied group demonstrated superior ability to correctly generalize the object labels to untrained exemplars of the same category, a pattern consistent with much of the existing literature. More interesting was the superior performance of the varied group on a higher order generalization task – such that they were able to appropriately generalize the bias they had learned during training for attending to the shape of objects to novel solid objects, but not to non-solids. The tight training group, on the other hand, tended to overgeneralize the shape bias, leading the researchers to suggest that the varied training induced a more context-sensitive understanding of when to apply their knowledge.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#complications-to-the-influence-of-variability",
    "href": "Sections/Introduction.html#complications-to-the-influence-of-variability",
    "title": "Variability and Generalization",
    "section": "",
    "text": "A necessary consequence of varied training is that participants will have the experience of switching from one task condition to another. The number of switches can vary greatly, with the two extremes being varied participants completing all of their training trials in one before switching to the next condition (blocked sequencing), or if they alternate between conditions on a trial by trial basis (random/intermixed/interleaved sequencing). Not long after the initial influx of schema-theory inspired studies testing the benefits of variability hypothesis was shown that the influence of varied training might interact with the type of training sequence chosen by the experimenter (J. B. Shea & Morgan, 1979). In this seminal study, both groups of training subjects trained with the same number of trials of three separate movement patterns. A blocked group that completed all of their trials with one sequence before beginning the next sequence, and a random group that trained with all three movement patterns interspersed throughout the course of training. Participants were also randomly assigned to retention testing under either blocked or random sequence conditions, thus resulting in all four training-testing combinations of blocked-blocked; blocked-random; random-blocked; random-random. There was some effect of sequence context, such that both groups performed better when the testing sequence matched their training sequence. However, the main finding of interest was the advantage of random-training, which resulted in superior testing performance than blocked training regardless of whether the testing stage had a blocked or random sequence, an effect observed both immediately after training, and in a follow up test ten days after the end of training.\nPrior to the influential J. B. Shea & Morgan (1979) study, studies investigating the benefits of variability hypothesis had utilized both blocked and random training schedules, often without comment or justification. It was later observed (Lee et al., 1985) that positive evidence for benefits of varied training seemed more likely to occur for studies that utilized random schedules. The theoretical basis of such studies was invariably an appeal to Schmidt’s schema theory; however schema theory made no clear predictions of an effect of study sequence on retention or generalization, thus prompting the need for alternate accounts. One such account, the elaborative processing account (J. B. Shea & Zimny, 1983), draws on the earlier work (Battig, 1966) and argues that randomly sequencing conditions during training promotes comparison and contrastive processes between those conditions, which result in a deeper understanding of the training task than could arise via blocked sequencing. Supporting evidence for elaborative processing comes in the form of random-sequence trained subjects self-reporting more nuanced mental representations of movement patterns following training (J. B. Shea & Zimny, 1983), and by manipulating whether subjects are able to perform comparisons during training (Wright et al., 1992). An alternative, though not incompatible account suggests that the benefits of random-sequencing are a result of such sequences forcing the learner to continually reconstruct the relevant motor task in working memory (Lee & Magill, n.d.). Blocked training, on the other hand, allows the learner to maintain the same motor task in short term memory without decay for much of the training which facilitates training performance, but hinders ability to retrieve the appropriate motor memory in a later testing context. A much more recent study (Chua et al., 2019), replicates the standard findings of an advantage of varied training over constant training (expt 1, bean-bag throwing task), and of random training over blocked training (expt 2 & 3, bean-bag throwing & golf putting). The novelty of this study is that the experimenters queried subjects about their attentional focus throughout the training stage. In all three experiments varied or random trained-subjects reported significantly greater external attention (e.g. attending to the target distance), and constant or blocked subjects reported more internal attention (e.g. posture or hand position). The authors argue that the benefits of varied/random training may be mediated by changes in attentional focus, however the claims made in the paper seem to go far beyond what can be justified by the analyses reported – e.g. the increased external focus could be a simple byproduct of varied training. A stronger form of evidence that was not provided may have been to use multiple regression analyses to show that the testing advantage of the varied/random groups over the constant/blocked groups could be accounted for by the differences in self-reported attentional focus.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/Introduction.html#other-task-and-participant-effects",
    "href": "Sections/Introduction.html#other-task-and-participant-effects",
    "title": "Variability and Generalization",
    "section": "",
    "text": "Of course, the effects of varied training, and different training sequences, are likely to be far more complex than simply more varied training being better than less, or random training being better than blocked. Null effects of both manipulations have been reported (see Magill & Hall, 1990; Van Rossum, 1990 for reviews), and a variety of moderators have emerged. In one of the earlier examples of the complex relationship between study sequence and learning (Del Rey et al., 1982), experimenters recruited participants who self-reported either large amounts, or very little experience with athletic actives, and then trained participants on a coincident timing task under with either a single constant training velocity, or with four training velocities under either blocked, or random training sequence conditions - resulting in six experimental conditions: (athlete vs. non-athlete) x (constant vs. blocked vs. random training). Athlete participants had superior performance during training, regardless of sequence condition, and training performance was superior for all subjects in the constant group, followed by blocked training in the middle, and then random training resulting in the worst training performance. Of greater interest is the pattern of testing results for novel transfer conditions. Among the athlete-participants, transfer performance was best for those who received random training, followed by blocked, and then constant training. Non-athletes showed the opposite pattern, with superior performance for those who had constant training. A similar pattern was later observed in a golf-putting training study, wherein participants who had some prior golf experience benefited most from random-sequenced training, and participants with no golf experience benefited most from blocked training (Guadagnoli et al., 1999). More recently, the same pattern was observed in the concept learning literature (Braithwaite & Goldstone, 2015 expt 1.). This study trained participants on a mathematical concept and found that participants who self-reported some prior experience with the concept improved more from pre-test to post-test after training with varied examples, while participants who reported no prior experience showed greater gains following training with highly similar examples.\nIn addition to the influence of prior experiences described above, ample evidence also suggests that numerous aspects of the experiment may also interact with the influence of variation. One important study examined the impact of the amount of training completed in a force production task (C. H. Shea et al., 1990). This study employed a typical blocked vs. random training procedure, but with the additional manipulation of separate groups receiving 50, 200, or 400 total training trials. For the group that received only 50 training trials retention was best when training had been blocked. However, for the conditions that received 200 or 400 training trials the pattern was reversed, with random training resulting in superior retention than blocked training. These results were taken to suggest that the benefits of randomization may take time to emerge. Another experimental factor shown to interact with training sequence is the complexity of the training task (Albaret & Thon, 1998). In addition to random or blocked training, participants in this study were assigned to train on a drawing task at one of three different levels of complexity (reproducing from memory shapes composed of two, three or four components). On a transfer task 48 hours after the completion of training, only participants trained at the lower levels of task complexity (2 or 3 components) showed superior performance to the blocked condition. The authors suggest that the benefits of random sequencing, thought to arise from more elaborate cognitive processing, or the necessity of continually recalling task information from long term into short term memory, are more likely to be obscured as the complexity of the task forces the blocked participants to also engage in such processes.\nA final important influence of particular relevance to the practice-sequence literature concerns the exact structure of “random” sequencing. Although the term random is commonly used for convenience, experimenters do not typically leave the order of training entirely up to chance. Rather, the training sequence is often constrained such that each condition must occur a minimum number of times in each quartile of the training phase, thus resulting in an even distribution the conditions throughout training. While the assurance of the conditions being evenly spread throughout training is consistent across studies, other aspects of the sequence structure are a bit more idiosyncratic. Some researchers report setting a maximum number of consecutive repetitions, e.g. no more than 2 consecutive trials of the same condition (Del Rey et al., 1982; J. B. Shea & Morgan, 1979), or structure the random trials such that the same condition never occurs consecutively (Wulf, 1991). Also common is to structure experiments such that random condition really consists of many small blocks, where participants do a few trials of one condition consecutively and then switch to another condition (Chua et al., 2019; Willey & Liu, 2018; Wrisberg et al., 1987), resulting in many more switches than would arise if training was perfectly blocked. The question of whether such differences in the structure of random sequencing are consequential has been addressed experimentally a few times, in all cases consisting of a 1) a no-repeat random condition; 2) a blocked random condition (typically 3 or 4 repeats before a switch); and 3) a standard fully-blocked condition. Blocked-random training resulted in better performance than either repeat-random, or fully - blocked training in both a bean-bag throwing (Pigott & Shapiro, 1984), and basketball shot training study (Landin & Hebert, 1997), and in a replication plus extension of the seminal (J. B. Shea & Morgan, 1979) study, blocked-random training was equally effective as no-repeat random training, with both random structures leading to better performance than the fully-blocked training condition. Consequences on different study schedules have also been repeatedly observed in the category learning literature (Carvalho & Goldstone, 2014, 2017). This line of research has revealed that the effects of blocking vs. interleaving can depend on the structure of the category being learned, and also that the different schedules can result in the participants requiring different representations. A fruitful line of inquiry in the motor skill learning literature may be to attempt to identify whether structural aspects of the motor task interact with different training sequences in a reliable manner.\nNumerous researchers have attempted to provide coherent frameworks to account for the full range of influences of training variation and sequencing described above (along with many other effects not discussed). Such accounts are generally quite similar, invoking ideas of desirable levels of difficulty (Bjork & Bjork, 1992; Schmidt & Bjork, 1992), or optimal challenge points (Guadagnoli & Lee, 2004). They tend to start by describing the dissociation between acquisition performance (performance during training) and testing performance (delayed retention and/or transfer), most strikingly observed as varied/random training participants performing worse than their constant/blocked counterparts during the training stage of the study, but then outperforming the constant/blocked comparisons at a later retention or transfer stage. This observation is then used to justify the idea that the most enduring and generalizable learning occurs by training at an optimal level of training difficulty, with difficulty being some function of the experience of the learner, and the cognitive or visuomotor processing demands of the task. It then follows that the factors that tend to make training more difficult (i.e. increased variability or randomization), are more likely to be beneficial when the learner has some experience, or when the processing demands of the task are not too extreme (which may only occur after some experience with the task). Such frameworks may be helpful heuristics in some cases, but they also seem to be overly flexible such that any null result of some intervention might be accounted for by a suboptimal amount of training trials, or by suggesting the training task was too difficult. The development of computational models that can account for how changes in the parameters of the motor-skill task scale with difficulty, would be a great step forward.",
    "crumbs": [
      "Variability and Generalization"
    ]
  },
  {
    "objectID": "Sections/HTW.html",
    "href": "Sections/HTW.html",
    "title": "HTW Project",
    "section": "",
    "text": "Link to HTW project page\nWorking Draft of HTW Manuscript _______________________________________________________________________________",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#function-learning-and-extrapolation",
    "href": "Sections/HTW.html#function-learning-and-extrapolation",
    "title": "HTW Project",
    "section": "Function Learning and Extrapolation",
    "text": "Function Learning and Extrapolation\nThe study of human function learning investigates how people learn relationships between continuous input and output values. Function learning is studied both in tasks where individuals are exposed to a sequence of input/output pairs (DeLosh et al., 1997; McDaniel et al., 2013), or situations where observers are presented with a an incomplete scatterplot or line graph and make predictions about regions of the plot that don’t contain data (Ciccione & Dehaene, 2021; Courrieu, 2012; Said & Fischer, 2021; Schulz et al., 2020).\nCarroll (1963) conducted the earliest work on function learning. Input stimuli and output responses were both lines of varying length. The correct output response was related to the length of the input line by a linear, quadratic, or random function. Participants in the linear and quadratic performed above chance levels during extrapolation testing, with those in the linear condition performing the best overall. Carroll argued that these results were best explained by a ruled based model wherein learners form an abstract representation of the underlying function. Subsequent work by Brehmer (1974),testing a wider array of functional forms, provided further evidence for superior extrapolation in tasks with linear functions. Brehmer argued that individuals start out with an assumption of a linear function, but given sufficient error will progressively test alternative hypothesis with polynomials of greater degree. Koh & Meyer (1991) employed a visuomotor function learning task, wherein participants were trained on examples from an unknown function relating the length of an input line to the duration of a response (time between keystrokes). In this domain, participants performed best when the relation between line length and response duration was determined by a power, as opposed to linear function. Koh & Meyer developed the log-polynomial adaptive-regression model to account for their results.\nThe first significant challenge to the rule-based accounts of function learning was put forth by DeLosh et al. (1997) . In their task, participants learned to associate stimulus magnitudes with response magnitudes that were related via either linear, exponential, or quadratic function. Participants approached ceiling performance by the end of training in each function condition, and were able to correctly respond in interpolation testing trials. All three conditions demonstrated some capacity for extrapolation, however participants in the linear condition tended to underestimate the true function, while exponential and quadratic participants reliably overestimated the true function on extrapolation trials. Extrapolation and interpolation performance are depicted in Figure 1.\nThe authors evaluated both of the rule-based models introduced in earlier research (with some modifications enabling trial-by-trial learning). The polynomial hypothesis testing model (Brehmer, 1974; Carroll, 1963) tended to mimic the true function closely in extrapolation, and thus offered a poor account of the human data. The log-polynomial adaptive regression model (Koh & Meyer, 1991) was able to mimic some of the systematic deviations produced by human subjects, but also predicted overestimation in cases where underestimation occurred.\nThe authors also introduced two new function-learning models. The Associative Learning Model (ALM) and the extrapolation-association model (EXAM). ALM is a two layer connectionist model adapted from the ALCOVE model in the category learning literature (Kruschke, 1992). ALM belongs to the general class of radial-basis function neural networks, and can be considered a similarity-based model in the sense that the nodes in the input layer of the network are activated as a function of distance. The EXAM model retains the same similarity based activation and associative learning mechanisms as ALM, while being augmented with a linear rule response mechanism. When presented with novel stimuli, EXAM will retrieve the most similar input-output examples encountered during training, and from those examples compute a local slope. ALM was able to provide a good account of participant training and interpolation data in all three function conditions, however it was unable to extrapolate. EXAM, on the other hand, was able to reproduce both the extrapolation underestimation, as well as the quadratic and exponential overestimation patterns exhibited by the human participants. Subsequent research identified some limitations in EXAM’s ability to account for cases where human participants learn and extrapolate sinusoidal function Bott & Heit (2004) or to scenarios where different functions apply to different regions of the input space Kalish et al. (2004), though EXAM has been shown to provide a good account of human learning and extrapolation in tasks with bi-linear, V shaped input spaces Mcdaniel et al. (2009).\n\nVariability and Function Learning\nThe influence of variability on function learning tasks has received relatively little attention. The study by DeLosh et al. (1997) (described in detail above) did include a variability manipulation (referred to as density in their paper), wherein participants were trained with either either 8, 20, or 50 unique input-output pairs, with the total number of training trials held constant. They found a minimal influence of variability on training performance, and no difference between groups in interpolation or extrapolation, with all three variability conditions displaying accurate interpolation, and linearly biased extrapolation that was well accounted for by the EXAM model.\nIn the domain of visuomotor learning, van Dam & Ernst (2015) employed a task which required participants to learn a linear function between the spikiness of shape stimuli and the correct horizontal position to make a rapid pointing response. The shapes ranged from very spiky to completely circular at the extreme ends of the space. Participants trained with intermediate shapes from a lower variation (2 shapes) or higher variation (5 shapes) condition, with the 2 items of the lower varied condition matching the items used on the extreme ends of the higher variation training space. Learning was significantly slower in the higher variation group. However, the two conditions did not differ when tested with novel shapes, with both groups producing extrapolation responses of comparable magnitudes to the most similar training item, rather than in accordance with the true linear function. The authors accounted for both learning and extrapolation performance with a Bayesian learning model. Similar to ALM, the bayesian model assumes that generalization occurs as a Gaussian function of the distance between stimuli. However unlike ALM, the bayesian learning model utilizes more elaborate probabilistic stimulus representations, with a separate Kalman Filter for each shape stimulus.\n\n\n\n\n\n\n\n\nFigure 1: Generalization reproduced patterns from DeLosh et al. (1997) Figure 3. Stimulii that fall within the dashed lines are interpolations of the training examples.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#participants",
    "href": "Sections/HTW.html#participants",
    "title": "HTW Project",
    "section": "Participants",
    "text": "Participants\nData was collected from 647 participants (after exclusions). The results shown below consider data from subjects in our initial experiment, which consisted of 196 participants (106 constant, 90 varied). The follow-up experiments entailed minor manipulations: 1) reversing the velocity bands that were trained on vs. novel during testing; 2) providing ordinal rather than numerical feedback during training (e.g. correct, too low, too high). The data from these subsequent experiments are largely consistently with our initial results shown below.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#task",
    "href": "Sections/HTW.html#task",
    "title": "HTW Project",
    "section": "Task",
    "text": "Task\nWe developed a novel visuomotor extrapolation task, termed the Hit The Wall task, wherein participants learned to launch a projectile such that it hit a rectangle at the far end of the screen with an appropriate amount of force. Although the projectile had both x and y velocity components, only the x-dimension was relevant for the task.  Link to task demo",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#procedure",
    "href": "Sections/HTW.html#procedure",
    "title": "HTW Project",
    "section": "Procedure",
    "text": "Procedure\nThe HTW task involved launching projectiles to hit a target displayed on the computer screen. Participants completed a total of 90 trials during the training stage. In the varied training condition, participants encountered three velocity bands (800-1000, 1000-1200, and 1200-1400). In contrast, participants in the constant training condition encountered only one velocity band (800-1000).\nDuring the training stage, participants in both conditions also completed “no feedback” trials, where they received no information about their performance. These trials were randomly interleaved with the regular training trials.\nFollowing the training stage, participants proceeded to the testing stage, which consisted of three phases. In the first phase, participants completed “no-feedback” testing from three novel extrapolation bands (100-300, 350-550, and 600-800), with each band consisting of 15 trials.\nIn the second phase of testing, participants completed “no-feedback” testing from the three velocity bands used during the training stage (800-1000, 1000-1200, and 1200-1400). In the constant training condition, two of these bands were novel, while in the varied training condition, all three bands were encountered during training.\nThe third and final phase of testing involved “feedback” testing for each of the three extrapolation bands (100-300, 350-550, and 600-800), with each band consisting of 10 trials. Participants received feedback on their performance during this phase.\nThroughout the experiment, participants’ performance was measured by calculating the distance between the produced x-velocity of the projectiles and the closest edge of the current velocity band. Lower distances indicated better performance.\nAfter completing the experiment, participants were debriefed and provided with an opportunity to ask questions about the study.\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1\n\nTest  \nNovel Bands \n100-300\n350-550\n600-800\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n800-1000\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n100-300\n350-550\n600-800\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 2: Experiment 1 Design. Constant and Varied participants complete different training conditions.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#analyses-strategy",
    "href": "Sections/HTW.html#analyses-strategy",
    "title": "HTW Project",
    "section": "Analyses Strategy",
    "text": "Analyses Strategy\nAll data processing and statistical analyses were performed in R version 4.31 Team (2020). To assess differences between groups, we used Bayesian Mixed Effects Regression. Model fitting was performed with the brms package in R Bürkner (2017), and descriptive stats and tables were extracted with the BayestestR package Makowski et al. (2019). Mixed effects regression enables us to take advantage of partial pooling, simultaneously estimating parameters at the individual and group level. Our use of Bayesian, rather than frequentist methods allows us to directly quantify the uncertainty in our parameter estimates, as well as circumventing convergence issues common to the frequentist analogues of our mixed models. For each model, we report the median values of the posterior distribution, and 95% credible intervals.\nEach model was set to run with 4 chains, 5000 iterations per chain, with the first 2500 of which were discarded as warmup chains. Rhat values were generally within an acceptable range, with values &lt;=1.02 (see appendix for diagnostic plots). We used uninformative priors for the fixed effects of the model (condition and velocity band), and weakly informative Student T distributions for for the random effects.\nWe compared varied and constant performance across two measures, deviation and discrimination. Deviation was quantified as the absolute deviation from the nearest boundary of the velocity band, or set to 0 if the throw velocity fell anywhere inside the target band. Thus, when the target band was 600-800, throws of 400, 650, and 1100 would result in deviation values of 200, 0, and 300, respectively. Discrimination was measured by fitting a linear model to the testing throws of each subjects, with the lower end of the target velocity band as the predicted variable, and the x velocity produced by the participants as the predictor variable. Participants who reliably discriminated between velocity bands tended to have positive slopes with values ~1, while participants who made throws irrespective of the current target band would have slopes ~0.\n\n\nCode\nresult &lt;- test_summary_table(test, \"dist\",\"Deviation\", mfun = list(mean = mean, median = median, sd = sd))\n\n\nresult$constant |&gt;kable(booktabs = TRUE,\n                        linesep = \"\\\\addlinespace[0.5em]\")\n                        #caption = paste(\"Summary of Deviation- Constant\"))\n# |&gt;\n#   kable_styling(font_size = ifelse(fmt_out == \"latex\", 8.5, NA))\n\nresult$varied |&gt; kable(booktabs = TRUE,\n                        linesep = \"\\\\addlinespace[0.5em]\")\n                        #caption = paste(\"Summary of Deviation- Varied\"))\n\n\n\n\nTable 1: Testing Deviation - Empirical Summary\n\n\n\n\n\n\n(a) Full datasets\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n254\n148\n298\n\n\n350-550\nExtrapolation\n191\n110\n229\n\n\n600-800\nExtrapolation\n150\n84\n184\n\n\n800-1000\nTrained\n184\n106\n242\n\n\n1000-1200\nExtrapolation\n233\n157\n282\n\n\n1200-1400\nExtrapolation\n287\n214\n290\n\n\n\n\n\n\n\n\n\n\n\n(b) Intersection of samples with all labels available\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n386\n233\n426\n\n\n350-550\nExtrapolation\n285\n149\n340\n\n\n600-800\nExtrapolation\n234\n144\n270\n\n\n800-1000\nTrained\n221\n149\n248\n\n\n1000-1200\nTrained\n208\n142\n226\n\n\n1200-1400\nTrained\n242\n182\n235",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#results",
    "href": "Sections/HTW.html#results",
    "title": "HTW Project",
    "section": "Results",
    "text": "Results\n\nTesting Phase - No feedback.\nIn the first part of the testing phase, participants are tested from each of the velocity bands, and receive no feedback after each throw.\n\nDeviation From Target Band\nDescriptive summaries testing deviation data are provided in Table 1 and Figure 3. To model differences in accuracy between groups, we used Bayesian mixed effects regression models to the trial level data from the testing phase. The primary model predicted the absolute deviation from the target velocity band (dist) as a function of training condition (condit), target velocity band (band), and their interaction, with random intercepts and slopes for each participant (id).\n\\[\\begin{equation}\ndist_{ij} = \\beta_0 + \\beta_1 \\cdot condit_{ij} + \\beta_2 \\cdot band_{ij} + \\beta_3 \\cdot condit_{ij} \\cdot band_{ij} + b_{0i} + b_{1i} \\cdot band_{ij} + \\epsilon_{ij}\n\\end{equation}\\]\n\n\nCode\ntest |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\n\n\n\n\n\n\nFigure 3: E1. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\nmodelName &lt;- \"e1_testDistBand_RF_5K\"\ne1_distBMM &lt;- brm(dist ~ condit * bandInt + (1 + bandInt|id),\n                      data=test,file=paste0(here::here(\"data/model_cache\",modelName)),\n                      iter=5000,chains=4)\nGetModelStats(e1_distBMM) |&gt; kable(booktabs = TRUE,caption = paste(\"Coefficients\"))\n\n\ne1_distBMM |&gt; \n  emmeans(\"condit\",by=\"bandInt\",at=list(bandInt=c(100,350,600,800,1000,1200)),\n          epred = TRUE, re_formula = NA) |&gt; \n  pairs() |&gt; gather_emmeans_draws()  |&gt; \n   summarize(median_qi(.value),pd=sum(.value&gt;0)/n()) |&gt;\n   select(contrast,Band=bandInt,value=y,lower=ymin,upper=ymax,pd) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 2)),\n          pd=ifelse(value&lt;0,1-pd,pd)) |&gt; kable(booktabs = TRUE)\n# |&gt; \n#   kbl(caption=\"Contrasts\")\n\ncoef_details &lt;- get_coef_details(e1_distBMM, \"conditVaried\")\n\n\n\n\nTable 2: Experiment 1. Bayesian Mixed Model predicting absolute deviation as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n(a) Constant Testing1 - Deviation\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n205.09\n136.86\n274.06\n1.00\n\n\nconditVaried\n157.44\n60.53\n254.90\n1.00\n\n\nBand\n0.01\n-0.07\n0.08\n0.57\n\n\ncondit*Band\n-0.16\n-0.26\n-0.06\n1.00\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied Testing - Deviation\n\n\n\n\n\ncontrast\nBand\nvalue\nlower\nupper\npd\n\n\n\n\nConstant - Varied\n100\n-141.49\n-229.2\n-53.83\n1.00\n\n\nConstant - Varied\n350\n-101.79\n-165.6\n-36.32\n1.00\n\n\nConstant - Varied\n600\n-62.02\n-106.2\n-14.77\n1.00\n\n\nConstant - Varied\n800\n-30.11\n-65.1\n6.98\n0.94\n\n\nConstant - Varied\n1000\n2.05\n-33.5\n38.41\n0.54\n\n\nConstant - Varied\n1200\n33.96\n-11.9\n81.01\n0.92\n\n\n\n\n\n\n\n\n\n\n\nThe model predicting absolute deviation (dist) showed clear effects of both training condition and target velocity band (Table X). Overall, the varied training group showed a larger deviation relative to the constant training group (β = 157.44, 95% CI [60.53, 254.9]). Deviation also depended on target velocity band, with lower bands showing less deviation. See Table 2 for full model output.\n\n\nDiscrimination between bands\nIn addition to accuracy/deviation, we also assessed the ability of participants to reliably discriminate between the velocity bands (i.e. responding differently when prompted for band 600-800 than when prompted for band 150-350). Table 3 shows descriptive statistics of this measure, and Figure 1 visualizes the full distributions of throws for each combination of condition and velocity band. To quantify discrimination, we again fit Bayesian Mixed Models as above, but this time the dependent variable was the raw x velocity generated by participants on each testing trial.\n\\[\\begin{equation}\nvx_{ij} = \\beta_0 + \\beta_1 \\cdot condit_{ij} + \\beta_2 \\cdot bandInt_{ij} + \\beta_3 \\cdot condit_{ij} \\cdot bandInt_{ij} + b_{0i} + b_{1i} \\cdot bandInt_{ij} + \\epsilon_{ij}\n\\end{equation}\\]\n\n\nCode\ntest %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 4: E1 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\n\nresult &lt;- test_summary_table(test, \"vx\",\"X Velocity\", mfun = list(mean = mean, median = median, sd = sd))\nresult$constant |&gt; kable(booktabs = TRUE)\nresult$varied |&gt; kable(booktabs = TRUE)\n\n\n\n\nTable 3: Testing vx - Empirical Summary\n\n\n\n\n\n\n(a) Constant\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n524\n448\n327\n\n\n350-550\nExtrapolation\n659\n624\n303\n\n\n600-800\nExtrapolation\n770\n724\n300\n\n\n800-1000\nTrained\n1001\n940\n357\n\n\n1000-1200\nExtrapolation\n1167\n1104\n430\n\n\n1200-1400\nExtrapolation\n1283\n1225\n483\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n664\n533\n448\n\n\n350-550\nExtrapolation\n768\n677\n402\n\n\n600-800\nExtrapolation\n876\n813\n390\n\n\n800-1000\nTrained\n1064\n1029\n370\n\n\n1000-1200\nTrained\n1180\n1179\n372\n\n\n1200-1400\nTrained\n1265\n1249\n412\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ne1_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e1_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\nGetModelStats(e1_vxBMM ) |&gt; kable(booktabs=T, caption=\"Fit to all 6 bands\")\n\ncd1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e1_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried:bandInt\")\n\n\nmodelName &lt;- \"e1_extrap_testVxBand\"\ne1_extrap_VxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                  data=test |&gt;\n                    filter(expMode==\"test-Nf\"),file=paste0(here::here(\"data/model_cache\",modelName)),\n                  iter=5000,chains=4)\nGetModelStats(e1_extrap_VxBMM ) |&gt; kable(booktabs=T, caption=\"Fit to 3 extrapolation bands\")\n\n\nsc2 &lt;- get_coef_details(e1_extrap_VxBMM, \"bandInt\")\nintCoef2 &lt;- get_coef_details(e1_extrap_VxBMM, \"conditVaried:bandInt\")\n\n\n\n\nTable 4: Experiment 1. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n(a) Model fit to all 6 bands\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n408.55\n327.00\n490.61\n1.00\n\n\nconditVaried\n164.05\n45.50\n278.85\n1.00\n\n\nBand\n0.71\n0.62\n0.80\n1.00\n\n\ncondit*Band\n-0.14\n-0.26\n-0.01\n0.98\n\n\n\n\n\n\n\n\n\n\n\n(b) Model fit to 3 extrapolation bands\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n478.47\n404.00\n551.45\n1.00\n\n\nconditVaried\n142.04\n37.17\n247.59\n1.00\n\n\nBand\n0.50\n0.42\n0.57\n1.00\n\n\ncondit*Band\n-0.07\n-0.17\n0.04\n0.89\n\n\n\n\n\n\n\n\n\n\n\nSee Table 4 for the full model results. The estimated coefficient for training condition (\\(B\\) = 164.05, 95% CrI [45.5, 278.85]) suggests that the varied group tends to produce harder throws than the constant group, but is not in and of itself useful for assessing discrimination. Most relevant to the issue of discrimination is the slope on Velocity Band (\\(B\\) = 0.71, 95% CrI [0.62, 0.8]). Although the median slope does fall underneath the ideal of value of 1, the fact that the 95% credible interval does not contain 0 provides strong evidence that participants exhibited some discrimination between bands. The estimate for the interaction between slope and condition (\\(B\\) = -0.14, 95% CrI [-0.26, -0.01]), suggests that the discrimination was somewhat modulated by training condition, with the varied participants showing less senitivity between vands than the constant condition. This difference is depicted visually in Figure 5.@tbl-e1-slope-quartile shows the average slope coefficients for varied and constant participants separately for each quartile. The constant participant participants appear to have larger slopes across quartiles, but the difference between conditions may be less pronounced for the top quartiles of subjects who show the strongest discrimination. Figure Figure 6 shows the distributions of slope values for each participant, and the compares the probability density of slope coefficients between training conditions. Figure 7\nThe second model, which focused solely on extrapolation bands, revealed similar patterns. The Velocity Band term (\\(B\\) = 0.5, 95% CrI [0.42, 0.57]) still demonstrates a high degree of discrimination ability. However, the posterior distribution for interaction term (\\(B\\) = -0.07, 95% CrI [-0.17, 0.04] ) does across over 0, suggesting that the evidence for decreased discrimination ability for the varied participants is not as strong when considering only the three extrapolation bands.\n\nCode\ne1_vxBMM |&gt; emmeans( ~condit + bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects() +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(test$vb), \n                     limits = c(0, 1400))\n\ne1_extrap_VxBMM |&gt; emmeans( ~condit + bandInt, \n                       at = list(bandInt = c(100, 350, 600))) |&gt;\n  gather_emmeans_draws() |&gt;\n  condEffects() +\n  scale_x_continuous(breaks = c(100, 350, 600), \n                     labels = levels(test$vb)[1:3], \n                     limits = c(0, 1000)) \n\n\n\n\n\n\n\n\n\n\n\n\n(a) Model fit to all 6 bands\n\n\n\n\n\n\n\n\n\n\n\n(b) Model fit to only 3 extrapolation bands\n\n\n\n\n\n\n\nFigure 5: Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\nCode\nnew_data_grid=map_dfr(1, ~data.frame(unique(test[,c(\"id\",\"condit\",\"bandInt\")]))) |&gt; \n  dplyr::arrange(id,bandInt) |&gt; \n  mutate(condit_dummy = ifelse(condit == \"Varied\", 1, 0)) \n\nindv_coefs &lt;- as_tibble(coef(e1_vxBMM)$id, rownames=\"id\")|&gt; \n  select(id, starts_with(\"Est\")) |&gt;\n  left_join(e1Sbjs, by=join_by(id) ) \n\n\nfixed_effects &lt;- e1_vxBMM |&gt; \n  spread_draws(`^b_.*`,regex=TRUE) |&gt; arrange(.chain,.draw,.iteration)\n\n\nrandom_effects &lt;- e1_vxBMM |&gt; \n  gather_draws(`^r_id.*$`, regex = TRUE, ndraws = 1500) |&gt; \n  separate(.variable, into = c(\"effect\", \"id\", \"term\"), sep = \"\\\\[|,|\\\\]\") |&gt; \n  mutate(id = factor(id,levels=levels(test$id))) |&gt; \n  pivot_wider(names_from = term, values_from = .value) |&gt; arrange(id,.chain,.draw,.iteration)\n\n\n indvDraws &lt;- left_join(random_effects, fixed_effects, by = join_by(\".chain\", \".iteration\", \".draw\")) |&gt; \n  rename(bandInt_RF = bandInt,RF_Intercept=Intercept) |&gt;\n  right_join(new_data_grid, by = join_by(\"id\")) |&gt; \n  mutate(\n    Slope = bandInt_RF+b_bandInt,\n    Intercept= RF_Intercept + b_Intercept,\n    estimate = (b_Intercept + RF_Intercept) + (bandInt*(b_bandInt+bandInt_RF)) + (bandInt * condit_dummy) * `b_conditVaried:bandInt`,\n    SlopeInt = Slope + (`b_conditVaried:bandInt`*condit_dummy)\n  ) \n\n  indvSlopes &lt;- indvDraws |&gt; group_by(id) |&gt; median_qi(Slope,SlopeInt, Intercept,b_Intercept,b_bandInt) |&gt;\n  left_join(e1Sbjs, by=join_by(id)) |&gt; group_by(condit) |&gt;\n    select(id,condit,Intercept,b_Intercept,starts_with(\"Slope\"),b_bandInt, n) |&gt;\n  mutate(rankSlope=rank(Slope)) |&gt; arrange(rankSlope)   |&gt; ungroup()\n \n  \n  indvSlopes |&gt; mutate(Condition=condit) |&gt;  group_by(Condition) |&gt; \n    reframe(enframe(quantile(SlopeInt, c(0.0,0.25, 0.5, 0.75,1)), \"quantile\", \"SlopeInt\")) |&gt; \n  pivot_wider(names_from=quantile,values_from=SlopeInt,names_prefix=\"Q_\") |&gt;\n  group_by(Condition) |&gt;\n  summarise(across(starts_with(\"Q\"), list(mean = mean))) |&gt; kable()\n\n\n\n\nTable 5: Slope coefficients by quartile, per condition\n\n\n\n\n\n\nCondition\nQ_0%_mean\nQ_25%_mean\nQ_50%_mean\nQ_75%_mean\nQ_100%_mean\n\n\n\n\nConstant\n-0.110\n0.478\n0.692\n0.933\n1.4\n\n\nVaried\n-0.201\n0.273\n0.581\n0.905\n1.3\n\n\n\n\n\n\n\n\n\nCode\n  indvSlopes |&gt; ggplot(aes(y=rankSlope, x=SlopeInt,fill=condit,color=condit)) + \n  geom_pointrange(aes(xmin=SlopeInt.lower , xmax=SlopeInt.upper)) + \n  labs(x=\"Estimated Slope\", y=\"Participant\")  + facet_wrap(~condit)\n\n   ggplot(indvSlopes, aes(x = SlopeInt, color = condit)) + \n  geom_density() + labs(x=\"Slope Coefficient\",y=\"Density\")\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Slope estimates by participant - ordered from lowest to highest within each condition.\n\n\n\n\n\n\n\n\n\n\n\n(b) Destiny of slope coefficients by training group\n\n\n\n\n\n\n\nFigure 6: Slope distributions between condition\n\n\n\ntest\n\n\nCode\n\nnSbj &lt;- 3\nindvDraws  |&gt; indv_model_plot(indvSlopes, testAvg, SlopeInt,rank_variable=Slope,n_sbj=nSbj,\"max\")\nindvDraws |&gt; indv_model_plot(indvSlopes, testAvg,SlopeInt, rank_variable=Slope,n_sbj=nSbj,\"min\")\n\n\n\n\n\n\n\n\n\n\n\n(a) subset with largest slopes\n\n\n\n\n\n\n\n\n\n\n\n(b) subset with smallest slopes\n\n\n\n\n\n\nFigure 7: Subset of Varied and Constant Participants with the smallest and largest estimated slope values. Red lines represent the best fitting line for each participant, gray lines are 200 random samples from the posterior distribution. Colored points and intervals at each band represent the empirical median and 95% HDI.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#e2-results",
    "href": "Sections/HTW.html#e2-results",
    "title": "HTW Project",
    "section": "E2 Results",
    "text": "E2 Results\n\nTesting Phase - No feedback.\nIn the first part of the testing phase, participants are tested from each of the velocity bands, and receive no feedback after each throw.\n\nDeviation From Target Band\nDescriptive summaries testing deviation data are provided in Table 6 and Figure 9. To model differences in accuracy between groups, we used Bayesian mixed effects regression models to the trial level data from the testing phase. The primary model predicted the absolute deviation from the target velocity band (dist) as a function of training condition (condit), target velocity band (band), and their interaction, with random intercepts and slopes for each participant (id).\n\\[\\begin{equation}\ndist_{ij} = \\beta_0 + \\beta_1 \\cdot condit_{ij} + \\beta_2 \\cdot band_{ij} + \\beta_3 \\cdot condit_{ij} \\cdot band_{ij} + b_{0i} + b_{1i} \\cdot band_{ij} + \\epsilon_{ij}\n\\end{equation}\\]\n\n\nCode\nresult &lt;- test_summary_table(testE2, \"dist\",\"Deviation\", mfun = list(mean = mean, median = median, sd = sd))\nresult$constant |&gt; kable()\nresult$varied |&gt; kable()\n# make kable table with smaller font size\n# result$constant |&gt; kbl(caption=\"Constant Testing - Deviation\",booktabs=T,escape=F) |&gt; kable_styling(font_size = 7)\n\n\n\n\nTable 6: Testing Deviation - Empirical Summary\n\n\n\n\n\n\n(a) Constant Testing - Deviation\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n206\n48\n317\n\n\n350-550\nExtrapolation\n194\n86\n268\n\n\n600-800\nTrained\n182\n112\n240\n\n\n800-1000\nExtrapolation\n200\n129\n233\n\n\n1000-1200\nExtrapolation\n238\n190\n234\n\n\n1200-1400\nExtrapolation\n311\n254\n288\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied Testing - Deviation\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nTrained\n153\n25\n266\n\n\n350-550\nTrained\n138\n53\n233\n\n\n600-800\nTrained\n160\n120\n183\n\n\n800-1000\nExtrapolation\n261\n207\n257\n\n\n1000-1200\nExtrapolation\n305\n258\n273\n\n\n1200-1400\nExtrapolation\n363\n314\n297\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ntestE2 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\n\n\n\n\n\n\nFigure 9: E2. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\nmodelName &lt;- \"e2_testDistBand_RF_5K\"\ne2_distBMM &lt;- brm(dist ~ condit * bandInt + (1 + bandInt|id),\n                      data=testE2,file=paste0(here::here(\"data/model_cache\",modelName)),\n                      iter=5000,chains=4)\nmp2 &lt;- GetModelStats(e2_distBMM) |&gt; kable(booktabs=T)\nmp2\n\ne2_distBMM |&gt; \n  emmeans(\"condit\",by=\"bandInt\",at=list(bandInt=c(100,350,600,800,1000,1200)),\n          epred = TRUE, re_formula = NA) |&gt; \n  pairs() |&gt; gather_emmeans_draws()  |&gt; \n   summarize(median_qi(.value),pd=sum(.value&gt;0)/n()) |&gt;\n   select(contrast,Band=bandInt,value=y,lower=ymin,upper=ymax,pd) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 2)),\n          pd=ifelse(value&lt;0,1-pd,pd)) |&gt;\n   kable()\n\ncoef_details &lt;- get_coef_details(e2_distBMM, \"conditVaried\")\n\n\n\n\nTable 7: Experiment 2. Bayesian Mixed Model predicting absolute deviation as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n(a) Model fits\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n151.71\n90.51\n215.86\n1.00\n\n\nconditVaried\n-70.33\n-156.87\n16.66\n0.94\n\n\nBand\n0.10\n0.02\n0.18\n1.00\n\n\ncondit*Band\n0.12\n0.02\n0.23\n0.99\n\n\n\n\n\n\n\n\n\n\n\n(b) Contrasts\n\n\n\n\n\ncontrast\nBand\nvalue\nlower\nupper\npd\n\n\n\n\nConstant - Varied\n100\n57.6\n-20.5\n135.32\n0.93\n\n\nConstant - Varied\n350\n26.6\n-30.9\n83.84\n0.83\n\n\nConstant - Varied\n600\n-4.3\n-46.7\n38.52\n0.58\n\n\nConstant - Varied\n800\n-29.3\n-69.4\n11.29\n0.92\n\n\nConstant - Varied\n1000\n-54.6\n-101.1\n-5.32\n0.98\n\n\nConstant - Varied\n1200\n-79.6\n-139.5\n-15.45\n0.99\n\n\n\n\n\n\n\n\n\n\n\nThe model predicting absolute deviation showed a modest tendency for the varied training group to have lower deviation compared to the constant training group (β = -70.33, 95% CI [-156.87, 16.66]),with 94% of the posterior distribution being less than 0. This suggests a potential benefit of training with variation, though the evidence is not definitive.\n\n\nDiscrimination between Velocity Bands\nIn addition to accuracy/deviation. We also assessed the ability of participants to reliably discriminate between the velocity bands (i.e. responding differently when prompted for band 600-800 than when prompted for band 150-350). Table 8 shows descriptive statistics of this measure, and Figure 1 visualizes the full distributions of throws for each combination of condition and velocity band. To quantify discrimination, we again fit Bayesian Mixed Models as above, but this time the dependent variable was the raw x velocity generated by participants.\n\\[\\begin{equation}\nvx_{ij} = \\beta_0 + \\beta_1 \\cdot condit_{ij} + \\beta_2 \\cdot bandInt_{ij} + \\beta_3 \\cdot condit_{ij} \\cdot bandInt_{ij} + b_{0i} + b_{1i} \\cdot bandInt_{ij} + \\epsilon_{ij}\n\\end{equation}\\]\n\n\nCode\ntestE2 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 10: E2 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\nCode\nresult &lt;- test_summary_table(testE2, \"vx\",\"X Velocity\" ,mfun = list(mean = mean, median = median, sd = sd))\nresult$constant |&gt; kable()\nresult$varied |&gt; kable()\n\n\n\n\nTable 8: Testing vx - Empirical Summary\n\n\n\n\n\n\n\n(a) Constant Testing - vx\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n457\n346\n354\n\n\n350-550\nExtrapolation\n597\n485\n368\n\n\n600-800\nTrained\n728\n673\n367\n\n\n800-1000\nExtrapolation\n953\n913\n375\n\n\n1000-1200\nExtrapolation\n1064\n1012\n408\n\n\n1200-1400\nExtrapolation\n1213\n1139\n493\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied Testing - vx\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nTrained\n410\n323\n297\n\n\n350-550\nTrained\n582\n530\n303\n\n\n600-800\nTrained\n696\n641\n316\n\n\n800-1000\nExtrapolation\n910\n848\n443\n\n\n1000-1200\nExtrapolation\n1028\n962\n482\n\n\n1200-1400\nExtrapolation\n1095\n1051\n510\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ne2_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=testE2,file=paste0(here::here(\"data/model_cache\", \"e2_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\nmt3 &lt;-GetModelStats(e2_vxBMM ) |&gt; kable(escape=F,booktabs=T)\nmt3\n\ncd1 &lt;- get_coef_details(e2_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e2_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e2_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\nTable 9: Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n362.64\n274.85\n450.02\n1.00\n\n\nconditVaried\n-8.56\n-133.97\n113.98\n0.55\n\n\nBand\n0.71\n0.58\n0.84\n1.00\n\n\ncondit*Band\n-0.06\n-0.24\n0.13\n0.73\n\n\n\n\n\n\n\n\nSee Table 9 for the full model results.\nWhen examining discrimination ability using the model predicting raw x-velocity, the results were less clear than those of the absolute deviation analysis. The slope on Velocity Band (β = 0.71, 95% CrI [0.58, 0.84]) indicates that participants showed good discrimination between bands overall. However, the interaction term suggested this effect was not modulated by training condition (β = -0.06, 95% CrI [-0.24, 0.13]) Thus, while varied training may provide some advantage for accuracy, both training conditions seem to have similar abilities to discriminate between velocity bands.\n\n\nCode\ne2_vxBMM |&gt; emmeans( ~condit + bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt;\n  ggplot(aes(x = bandInt, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  ylab(\"Predicted X Velocity\") + xlab(\"Band\")+\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE2$vb), \n                     limits = c(0, 1400)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\n\nFigure 11: Conditional effect of training condition and Band. Ribbons indicate 95% HDI.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#results-1",
    "href": "Sections/HTW.html#results-1",
    "title": "HTW Project",
    "section": "Results",
    "text": "Results\n\nTesting Phase - No feedback.\nIn the first part of the testing phase, participants are tested from each of the velocity bands, and receive no feedback after each throw. Note that these no-feedback testing trials are identical to those of Experiment 1 and 2, as the ordinal feedback only occurs during the training phase, and final testing phase, of Experiment 3.\n\nDeviation From Target Band\nDescriptive summaries testing deviation data are provided in Table 10 and Figure 12. To model differences in accuracy between groups, we fit Bayesian mixed effects regression models to the trial level data from the testing phase. The primary model predicted the absolute deviation from the target velocity band (dist) as a function of training condition (condit), target velocity band (band), and their interaction, with random intercepts and slopes for each participant (id).\n\n\nCode\nresultOrig &lt;- test_summary_table(testE3 |&gt; filter(bandOrder==\"Original\"), \"dist\",\"Deviation\", mfun = list(mean = mean, median = median, sd = sd))\nresultOrig$constant |&gt; kable()\nresultOrig$varied |&gt; kable()\n\nresultRev &lt;- test_summary_table(testE3 |&gt; filter(bandOrder==\"Reverse\"), \"dist\",\"Deviation\", mfun = list(mean = mean, median = median, sd = sd))\nresultRev$constant |&gt; kable()\nresultRev$varied |&gt; kable()\n\n\n\n\nTable 10: Testing Deviation - Empirical Summary\n\n\n\n\n\n\n(a) Constant Testing - Deviation\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n396\n325\n350\n\n\n350-550\nExtrapolation\n278\n176\n299\n\n\n600-800\nExtrapolation\n173\n102\n215\n\n\n800-1000\nTrained\n225\n126\n284\n\n\n1000-1200\nExtrapolation\n253\n192\n271\n\n\n1200-1400\nExtrapolation\n277\n210\n262\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied Testing - Deviation\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n383\n254\n385\n\n\n350-550\nExtrapolation\n287\n154\n318\n\n\n600-800\nExtrapolation\n213\n140\n244\n\n\n800-1000\nTrained\n199\n142\n209\n\n\n1000-1200\nTrained\n222\n163\n221\n\n\n1200-1400\nTrained\n281\n227\n246\n\n\n\n\n\n\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n403\n334\n383\n\n\n350-550\nExtrapolation\n246\n149\n287\n\n\n600-800\nTrained\n155\n82\n209\n\n\n800-1000\nExtrapolation\n207\n151\n241\n\n\n1000-1200\nExtrapolation\n248\n220\n222\n\n\n1200-1400\nExtrapolation\n322\n281\n264\n\n\n\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nTrained\n153\n0\n307\n\n\n350-550\nTrained\n147\n55\n258\n\n\n600-800\nTrained\n159\n107\n192\n\n\n800-1000\nExtrapolation\n221\n160\n235\n\n\n1000-1200\nExtrapolation\n244\n185\n235\n\n\n1200-1400\nExtrapolation\n324\n264\n291\n\n\n\n\n\n\n\n\n\n\nCode\ntestE3 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  labs(x=\"Band\", y=\"Deviation From Target\") + facet_wrap(~bandOrder)\n\n\n\n\n\n\n\n\nFigure 12: e3. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\nmodelName &lt;- \"e3_testDistBand_RF_5K\"\ne3_distBMM &lt;- brm(dist ~ condit * bandInt + (1 + bandInt|id),\n                      data=testE3,file=paste0(here::here(\"data/model_cache\",modelName)),\n                      iter=5000,chains=4)\nmp3 &lt;- GetModelStats(e3_distBMM) |&gt; kable(booktabs=T)\nmp3\n\n\ncd1 &lt;- get_coef_details(e3_distBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e3_distBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e3_distBMM, \"conditVaried:bandInt\")\n\n\n\n\nTable 11: Experiment 3. Bayesian Mixed Model predicting absolute deviation as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n306.47\n243.89\n368.75\n1.00\n\n\nconditVaried\n-90.65\n-182.79\n3.75\n0.97\n\n\nBand\n-0.07\n-0.13\n0.00\n0.97\n\n\ncondit*Band\n0.09\n-0.01\n0.19\n0.96\n\n\n\n\n\n\n\n\nThe effect of training condition in Experiment 3 showed a similar pattern to Experiment 2, with the varied group tending to have lower deviation than the constant group (β = -90.65, 95% CrI [-182.79, 3.75]), with 97% of the posterior distribution falling under 0.\n\n\nCode\n\ne3_distBMM |&gt; emmeans( ~condit + bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt;\n  ggplot(aes(x = bandInt, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n    ylab(\"Predicted Deviation\") + xlab(\"Velocity Band\")+\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE3$vb), \n                     limits = c(0, 1400)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\n\nFigure 13: e3. Conditioinal Effect of Training Condition and Band. Ribbon indicated 95% Credible Intervals.\n\n\n\n\n\n\n\nDiscrimination between Velocity Bands\nIn addition to accuracy/deviation. We also assessed the ability of participants to reliably discriminate between the velocity bands (i.e. responding differently when prompted for band 600-800 than when prompted for band 150-350). Table 12 shows descriptive statistics of this measure, and Figure 1 visualizes the full distributions of throws for each combination of condition and velocity band. To quantify discrimination, we again fit Bayesian Mixed Models as above, but this time the dependent variable was the raw x velocity generated by participants.\n\\[\\begin{equation}\nvx_{ij} = \\beta_0 + \\beta_1 \\cdot condit_{ij} + \\beta_2 \\cdot bandInt_{ij} + \\beta_3 \\cdot condit_{ij} \\cdot bandInt_{ij} + b_{0i} + b_{1i} \\cdot bandInt_{ij} + \\epsilon_{ij}\n\\end{equation}\\]\n\n\nCode\n# testE3 |&gt; filter(bandOrder==\"Original\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit()\n# testE3 |&gt; filter(bandOrder==\"Reverse\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit() +ggtitle(\"test\")\n\ntestE3 |&gt; group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + \n  facet_wrap(bandOrder~condit,scale=\"free_x\") \n\n# column: screen-inset-right\n\n\n\n\n\n\n\n\nFigure 14: e3 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\nresultOrig &lt;- test_summary_table(testE3 |&gt; filter(bandOrder==\"Original\"), \"vx\",\"X Velocity\", mfun = list(mean = mean, median = median, sd = sd))\nresultOrig$constant |&gt; kable()\nresultOrig$varied |&gt; kable()\n\nresultRev &lt;- test_summary_table(testE3 |&gt; filter(bandOrder==\"Reverse\"), \"vx\",\"X Velocity\", mfun = list(mean = mean, median = median, sd = sd))\nresultRev$constant |&gt; kable()\nresultRev$varied |&gt; kable()\n\n\n\n\nTable 12: Testing vx - Empirical Summary\n\n\n\n\n\n\n(a) Constant Testing - vx\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n680\n625\n370\n\n\n350-550\nExtrapolation\n771\n716\n357\n\n\n600-800\nExtrapolation\n832\n786\n318\n\n\n800-1000\nTrained\n1006\n916\n417\n\n\n1000-1200\nExtrapolation\n1149\n1105\n441\n\n\n1200-1400\nExtrapolation\n1180\n1112\n443\n\n\n\n\n\n\n\n\n\n\n\n(b) Varied Testing - vx\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n667\n554\n403\n\n\n350-550\nExtrapolation\n770\n688\n383\n\n\n600-800\nExtrapolation\n869\n814\n358\n\n\n800-1000\nTrained\n953\n928\n359\n\n\n1000-1200\nTrained\n1072\n1066\n388\n\n\n1200-1400\nTrained\n1144\n1093\n426\n\n\n\n\n\n\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nExtrapolation\n684\n634\n406\n\n\n350-550\nExtrapolation\n729\n679\n350\n\n\n600-800\nTrained\n776\n721\n318\n\n\n800-1000\nExtrapolation\n941\n883\n387\n\n\n1000-1200\nExtrapolation\n1014\n956\n403\n\n\n1200-1400\nExtrapolation\n1072\n1014\n442\n\n\n\n\n\n\n\n\nBand\nBand Type\nMean\nMedian\nSd\n\n\n\n\n100-300\nTrained\n392\n270\n343\n\n\n350-550\nTrained\n540\n442\n343\n\n\n600-800\nTrained\n642\n588\n315\n\n\n800-1000\nExtrapolation\n943\n899\n394\n\n\n1000-1200\nExtrapolation\n1081\n1048\n415\n\n\n1200-1400\nExtrapolation\n1185\n1129\n500\n\n\n\n\n\n\n\n\n\n\nCode\ne3_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=testE3,file=paste0(here::here(\"data/model_cache\", \"e3_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\nmt4 &lt;-GetModelStats(e3_vxBMM ) |&gt; kable(booktabs=T)\nmt4\n\ncd1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e3_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\nTable 13: Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n607.67\n536.02\n679.87\n1\n\n\nconditVaried\n-167.76\n-277.14\n-64.08\n1\n\n\nBand\n0.44\n0.35\n0.52\n1\n\n\ncondit*Band\n0.18\n0.06\n0.31\n1\n\n\n\n\n\n\n\n\nSee Table 13 for the full model results.\nSlope estimates for experiment 3 suggest that participants were capable of distinguishing between velocity bands even when provided only ordinal feedback during training (β = 0.44, 95% CrI [0.35, 0.52]). Unlike the previous two experiments, the posterior distribution for the interaction between condition and band was consistently positive, suggestive of superior discrimination for the varied participants β = 0.18, 95% CrI [0.06, 0.31].\n\n\n\nComputational Modelling\n\n\nCode\n# load and view data\npacman::p_load(tidyverse,patchwork,here, pander, latex2exp, flextable)\npurrr::walk(here::here(c(\"Functions/Display_Functions.R\", \"Functions/alm_core.R\",\"Functions/misc_model_funs.R\")),source)\n\npurrr::walk(here::here(c(\"Functions/Display_Functions.R\")),source)\n\nselect &lt;- dplyr::select; mutate &lt;- dplyr::mutate \n\nds &lt;- readRDS(here::here(\"data/e1_md_11-06-23.rds\"))\ndsAvg &lt;- ds |&gt; group_by(condit,expMode2,tr, x) |&gt; \n  summarise(y=mean(y),.groups=\"keep\") \n\nvAvg &lt;- dsAvg |&gt; filter(condit==\"Varied\")\ncAvg &lt;- dsAvg |&gt; filter(condit==\"Constant\")\n\n#i1 &lt;- ds |&gt; filter(id==\"3\")\n\ninput.layer &lt;- c(100,350,600,800,1000,1200)\noutput.layer &lt;- c(100,350,600,800,1000,1200)\n\n\npurrr::walk(c(\"con_group_exam_fits\", \"var_group_exam_fits\", \"hybrid_group_exam_fits\"), \n            ~ list2env(readRDS(here::here(paste0(\"data/model_cache/\", .x, \".rds\"))), \n            envir = .GlobalEnv))\n\n# pluck(ex_te_v, \"Fit\") |&gt; mutate(w= ifelse(exists(\"w\"), round(w,2),NA))\n# pluck(hybrid_te_v, \"Fit\") |&gt; mutate(w= ifelse(exists(\"w\"), round(w,2), NA))\n\n\n\n\nCode\n alm_plot()\n\n\n\n\n\n\n\n\nFigure 15: The basic structure of the ALM model.\n\n\n\n\n\n\n\n\n\n\nTable 14: ALM & EXAM Equations\n\n\n\n\n\n\n\n\n\n\n\nALM Response Generation\n\n\n\n\n\nInput Activation\n\\(a_i(X) = \\frac{e^{-c(X-X_i)^2}}{\\sum_{k=1}^M e^{-c(X-X_k)^2}}\\)\nInput nodes activate as a function of Gaussian similarity to stimulus\n\n\nOutput Activation\n\\(O_j(X) = \\sum_{k=1}^M w_{ji} \\cdot a_i(X)\\)\nOutput unit \\(O_j\\) activation is the weighted sum of input activations and association weights\n\n\nOutput Probability\n\\(P[Y_j|X] = \\frac{O_j(X)}{\\sum_{k=1}^M O_k(X)}\\)\nThe response, \\(Y_j\\) probabilites computed via Luce’s choice rule\n\n\nMean Output\n\\(m(X) = \\sum_{j=1}^L Y_j \\cdot \\frac{O_j(x)}{\\sum_{k=1}^M O_k(X)}\\)\nWeighted average of probabilities determines response to X\n\n\n\nALM Learning\n\n\n\nFeedback\n\\(f_j(Z) = e^{-c(Z-Y_j)^2}\\)\nfeedback signal Z computed as similarity between ideal response and observed response\n\n\nmagnitude of error\n\\(\\Delta_{ji}=(f_{j}(Z)-o_{j}(X))a_{i}(X)\\)\nDelta rule to update weights.\n\n\nUpdate Weights\n\\(w_{ji}^{new}=w_{ji}+\\eta\\Delta_{ji}\\)\nUpdates scaled by learning rate parameter \\(\\eta\\).\n\n\n\nEXAM Extrapolation\n\n\n\nInstance Retrieval\n\\(P[X_i|X] = \\frac{a_i(X)}{\\sum_{k=1}^M a_k(X)}\\)\nNovel test stimulus \\(X\\) activates input nodes \\(X_i\\)\n\n\nSlope Computation\n\\(S =\\) \\(\\frac{m(X_{1})-m(X_{2})}{X_{1}-X_{2}}\\)\nSlope value, \\(S\\) computed from nearest training instances\n\n\nResponse\n\\(E[Y|X_i] = m(X_i) + S \\cdot [X - X_i]\\)\nALM response \\(m(X_i)\\) adjusted by slope.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#alm-exam-description",
    "href": "Sections/HTW.html#alm-exam-description",
    "title": "HTW Project",
    "section": "ALM & Exam Description",
    "text": "ALM & Exam Description\nALM is a localist neural network model (Page, 2000), with each input node corresponding to a particular stimulus, and each output node corresponding to a particular response value. The units in the input layer activate as a function of their Gaussian similarity to the input stimulus. So, for example, an input stimulus of value 55 would induce maximal activation of the input unit tuned to 55. Depending on the value of the generalization parameter, the nearby units (e.g. 54 and 56; 53 and 57) may also activate to some degree. ALM is structured with input and output nodes that correspond to regions of the stimulus space, and response space, respectively. The units in the input layer activate as a function of their similarity to a presented stimulus. As was the case with the exemplar-based models, similarity in ALM is exponentially decaying function of distance. The input layer is fully connected to the output layer, and the activation for any particular output node is simply the weighted sum of the connection weights between that node and the input activations. The network then produces a response by taking the weighted average of the output units (recall that each output unit has a value corresponding to a particular response). During training, the network receives feedback which activates each output unit as a function of its distance from the ideal level of activation necessary to produce the correct response. The connection weights between input and output units are then updated via the standard delta learning rule, where the magnitude of weight changes are controlled by a learning rate parameter. The EXAM model is an extension of ALM, with the same learning rule and representational scheme for input and output units. EXAM differs from ALM only in its response rule, as it includes a linear extrapolation mechanism for generating novel responses. Although this extrapolation rule departs from a strictly similarity-based generalization mechanism, EXAM is distinct from pure rule-based models in that it remains constrained by the weights learned during training. EXAM retrieves the two nearest training inputs, and the ALM responses associated with those inputs, and computes the slope between these two points. The slope is then used to extrapolate the response to the novel test stimulus. Because EXAM requires at least two input-output pairs to generate a response, additional assumptions were required in order for it to generate resposnes for the constant group. We assumed that participants come to the task with prior knowledge of the origin point (0,0), which can serve as a reference point necessary for the model to generate responses for the constant group. This assumption is motivated by previous function learning research (Brown & Lacroix (2017)), which through a series of manipulations of the y intercept of the underlying function, found that participants consistently demonstrated knowledge of, or a bias towards, the origin point (see Kwantes & Neal (2006) for additional evidence of such a bias in function learning tasks).\nSee Table 12 for a full specification of the equations that define ALM and EXAM, and Figure 15 for a visual representation of the ALM model.\n\n\n\n\nTable 12: ALM & EXAM Equations\n\n\n\n\n\n\n\n\n\n\n\nALM Response Generation\n\n\n\n\n\nInput Activation\n\\(a_i(X) = \\frac{e^{-c(X-X_i)^2}}{\\sum_{k=1}^M e^{-c(X-X_k)^2}}\\)\nInput nodes activate as a function of Gaussian similarity to stimulus\n\n\nOutput Activation\n\\(O_j(X) = \\sum_{k=1}^M w_{ji} \\cdot a_i(X)\\)\nOutput unit \\(O_j\\) activation is the weighted sum of input activations and association weights\n\n\nOutput Probability\n\\(P[Y_j|X] = \\frac{O_j(X)}{\\sum_{k=1}^M O_k(X)}\\)\nThe response, \\(Y_j\\) probabilites computed via Luce’s choice rule\n\n\nMean Output\n\\(m(X) = \\sum_{j=1}^L Y_j \\cdot \\frac{O_j(x)}{\\sum_{k=1}^M O_k(X)}\\)\nWeighted average of probabilities determines response to X\n\n\n\nALM Learning\n\n\n\nFeedback\n\\(f_j(Z) = e^{-c(Z-Y_j)^2}\\)\nfeedback signal Z computed as similarity between ideal response and observed response\n\n\nmagnitude of error\n\\(\\Delta_{ji}=(f_{j}(Z)-o_{j}(X))a_{i}(X)\\)\nDelta rule to update weights.\n\n\nUpdate Weights\n\\(w_{ji}^{new}=w_{ji}+\\eta\\Delta_{ji}\\)\nUpdates scaled by learning rate parameter \\(\\eta\\).\n\n\n\nEXAM Extrapolation\n\n\n\nInstance Retrieval\n\\(P[X_i|X] = \\frac{a_i(X)}{\\sum_{k=1}^M a_k(X)}\\)\nNovel test stimulus \\(X\\) activates input nodes \\(X_i\\)\n\n\nSlope Computation\n\\(S =\\) \\(\\frac{m(X_{1})-m(X_{2})}{X_{1}-X_{2}}\\)\nSlope value, \\(S\\) computed from nearest training instances\n\n\nResponse\n\\(E[Y|X_i] = m(X_i) + S \\cdot [X - X_i]\\)\nALM response \\(m(X_i)\\) adjusted by slope.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#model-fitting-and-comparison",
    "href": "Sections/HTW.html#model-fitting-and-comparison",
    "title": "HTW Project",
    "section": "Model Fitting and Comparison",
    "text": "Model Fitting and Comparison\nFollowing the procedure used by Mcdaniel et al. (2009), we will assess the ability of both ALM and EXAM to account for the empirical data when fitting the models to 1) only the training data, and 2) both training and testing data. Models were fit to the aggregated participant data by minimizing the root-mean squared deviation (RMSE). Because ALM has been shown to do poorly at accounting for human patterns extrapolation (DeLosh et al., 1997), we will also generate predictions from the EXAM model for the testing stage. EXAM which operates identically to ALM during training, but includes a linear extrapolation mechanism for generating novel responses during testing.\nFor the hybrid model, predictions are computed by first generating separate predictions from ALM and EXAM, and then combining them using the following equation: \\(\\hat{y} = (1 - w) \\cdot alm.pred + w \\cdot exam.pred\\). For the grid search, the weight parameter is varied from 0 to 1, and the resulting RMSE is recorded.\nEach model was fit to the data in 3 different ways. 1) To just the testing data, 2) Both the training and testing data, 3) Only the training data. In all cases, the model only updates its weights during the training phase, and the weights are frozen during the testing phase. In all cases, only the ALM model generates predictions during the training phase. For the testing phase, all 3 models are used to generate predictions.\n\n\n\nCode\n##| column: body-outset-right\n\n\nreshaped_df &lt;- all_combined_params %&gt;%\n  select(-Value,-Test_RMSE) |&gt;\n  rename(\"Fit Method\" = Fit_Method) |&gt;\n  pivot_longer(cols=c(c,lr,w),names_to=\"Parameter\") %&gt;%\n  unite(Group, Group, Parameter) %&gt;%\n  pivot_wider(names_from = Group, values_from = value)\n\nheader_df &lt;- data.frame(\n  col_keys = c(\"Model\", \"Fit Method\",\"Constant_c\", \"Constant_lr\", \"Constant_w\", \"Varied_c\", \"Varied_lr\", \"Varied_w\"),\n  line1 = c(\"\", \"\", \"Constant\", \"\", \"\", \"Varied\", \"\",\"\"),\n  line2 = c(\"Model\", \"Fit Method\", \"c\", \"lr\", \"w\", \"c\", \"lr\", \"w\")\n)\n\nft &lt;- flextable(reshaped_df) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% add_header_lines(values = \" \") %&gt;%\n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;% \n  hline(part = \"header\", i = 2, j=3:5) %&gt;% \n  hline(part = \"header\", i = 2, j=6:8)\n\nft\n\n\n\n\nTable 15: Fit Parameters and Model RMSE. The Test_RMSE column is the main performance indicator of interest, and represents the RMSE for just the testing data. The Fit_Method column indicates the data used to fit the model. The \\(w\\) parameter determines the balance between the ALM and EXAM response generation processes, and is only included for the hybrid model. A weight of .5 would indicate equal contribution from both models. \\(w\\) values approaching 1 indicate stronger weight for EXAM.\n\n\n\n ConstantVariedModelFit MethodclrwclrwALMTest Only0.0000.1000.1342.030ALMTest & Train0.0470.0800.0670.100ALMTrain Only0.0600.1000.0470.080EXAMTest Only0.0071.3270.4091.910EXAMTest & Train0.0810.1610.0740.100EXAMTrain Only0.0600.1000.0470.080HybridTest Only0.0081.58010.3952.0170.64HybridTest & Train0.0670.13410.1342.0170.79HybridTrain Only0.0420.06700.0420.0670.00\n\n\n\n\n\n\nTesting Observations vs. Predictions\n\n\nCode\ntvte&lt;- pluck(a_te_v, \"test\") |&gt; \n  mutate(Fit_Method=\"Test Only\") |&gt;\n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_te_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_v, \"test\") |&gt; pull(pred))\n\ntvtetr&lt;-pluck(a_tetr_v, \"test\") |&gt; \n  mutate(Fit_Method=\"Test & Train\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tetr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_v, \"test\") |&gt; pull(pred))\n\ntvtr&lt;- pluck(a_tr_v, \"test\")|&gt; \n  mutate(Fit_Method=\"Train Only\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_v, \"test\") |&gt; pull(pred))\n\ntcte&lt;- pluck(a_te_c, \"test\") |&gt; \n  mutate(Fit_Method=\"Test Only\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_te_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_c, \"test\") |&gt; pull(pred))\n\ntctetr&lt;-pluck(a_tetr_c, \"test\") |&gt; \n  mutate(Fit_Method=\"Test & Train\") |&gt;  \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tetr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_c, \"test\") |&gt; pull(pred))\n\ntctr&lt;- pluck(a_tr_c, \"test\")|&gt; \n  mutate(Fit_Method=\"Train Only\") |&gt;  \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_c, \"test\") |&gt; pull(pred))\n\nvPreds &lt;- rbind(tvte,tvtetr, tvtr) |&gt; relocate(Fit_Method,.before=x) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 0)))\n\ncPreds &lt;- rbind(tcte,tctetr, tctr) |&gt; relocate(Fit_Method,.before=x) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 0)))\n\nallPreds &lt;- rbind(vPreds |&gt; mutate(Group=\"Varied\"), cPreds |&gt; mutate(Group=\"Constant\")) |&gt;\n  pivot_longer(cols=c(\"ALM\",\"EXAM\",\"Hybrid\"), names_to=\"Model\",values_to = \"Prediction\") |&gt; \n  mutate(Error=Observed-Prediction, Abs_Error=((Error)^2)) |&gt; \n  group_by(Group,Fit_Method, Model) #|&gt; summarise(Mean_Error=mean(Error), Abs_Error=mean(Abs_Error))\n\n\n\n\nCode\nallPreds |&gt; summarise(Error=mean(Error), Abs_Error=sqrt(mean(Abs_Error))) |&gt; \n  mutate(Fit_Method=factor(Fit_Method, levels=c(\"Test Only\", \"Test & Train\", \"Train Only\"))) |&gt;\n  tabulator(rows=c(\"Fit_Method\", \"Model\"), columns=c(\"Group\"), \n             `ME` = as_paragraph(Error), \n            `RMSE` = as_paragraph(Abs_Error)) |&gt; as_flextable()\n\n\n\n\nTable 16: Model Perforamnce - averaged over all X values/Bands. ME=Mean Average Error, RMSE = Root mean squared error.\n\n\n\nFit_MethodModelConstantVariedMERMSEMERMSETest OnlyALM223.8348.056.395.4EXAM-59.2127.5-6.045.9Hybrid-58.2127.4-3.033.8Test & TrainALM193.2328.782.3106.6EXAM-28.8132.113.260.2Hybrid-16.7136.716.746.5Train OnlyALM194.5329.286.3109.1EXAM75.3199.917.565.4Hybrid197.5330.488.3110.3",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#varied-testing-predictions",
    "href": "Sections/HTW.html#varied-testing-predictions",
    "title": "HTW Project",
    "section": "Varied Testing Predictions",
    "text": "Varied Testing Predictions\n\n\nCode\n##| column: screen-inset-right\n\n####\n\nvte &lt;-  pluck(a_te_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_te_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test Only\")\n\nvtetr &lt;-  pluck(a_tetr_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tetr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") + \n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test and Train\")\n\nvtr &lt;-  pluck(a_tr_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Train Only\")\n\n vte/vtetr/vtr\n\n\n\n\n\n\n\n\nFigure 16: Varied Group - Mean Model predictions vs. observations\n\n\n\n\n\n\n\nCode\n##| column: screen-inset-right\n\n\n# Create a custom header dataframe\nheader_df &lt;- data.frame(\n  col_keys = c(\"Fit_Method\", \"x\",\"Observed\" ,\"ALM_Predicted\", \"ALM_Residual\", \"EXAM_Predicted\",\"EXAM_Residual\", \"Hybrid_Predicted\",\"Hybrid_Residual\"),\n  line1 = c(\"\",\"\",\"\", \"ALM\", \"\", \"EXAM\", \"\", \"Hybrid\",\"\"),\n  line2 = c(\"Fit Method\", \"X\", \"Observed\", \"Predicted\",\"Residual\", \"Predicted\",\"Residual\", \"Predicted\",\"Residual\")\n)\n\n\nbest_vPreds &lt;- vPreds %&gt;%\n  pivot_longer(cols = c(ALM, EXAM, Hybrid), names_to = \"Model\", values_to = \"Predicted\") |&gt;\n  mutate(Residual=(Observed-Predicted), abs_res =abs(Residual)) |&gt; group_by(Fit_Method,x) |&gt;\n  mutate(best=if_else(abs_res==min(abs_res),1,0)) |&gt; select(-abs_res)\n\nlong_vPreds &lt;- best_vPreds |&gt; select(-best) |&gt;\n  pivot_longer(cols=c(Predicted,Residual), names_to=\"Model_Perf\") |&gt;\n  relocate(Model, .after=Fit_Method) |&gt; \n  unite(Model,Model,Model_Perf) |&gt;\n  pivot_wider(names_from=Model,values_from=value)\n\nbest_wide &lt;- best_vPreds |&gt; select(-Residual,-Predicted,-Observed) |&gt; ungroup() |&gt;\n  pivot_wider(names_from=Model,values_from=best) |&gt; select(ALM,EXAM,Hybrid)\n\nbest_indexV &lt;- row_indices &lt;- apply(best_wide, 1, function(row) {\n which(row == 1)\n})\n\n\napply_best_formatting &lt;- function(ft, best_index) {\n  for (i in 1:length(best_index)) {\n      #ft &lt;- ft %&gt;% surround(i=i,j=best_index[i],border=fp_border_default(color=\"red\",width=1))\n      ind = best_index[[i]]\n      ind &lt;- ind  %&gt;% map_dbl(~ .x*2+3)\n      ft &lt;- ft %&gt;% highlight(i=i,j=ind,color=\"wheat\")\n      }\n  return(ft)\n}\n\nft &lt;- flextable(long_vPreds) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% \n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;%\n  hline(part = \"header\", i = 1, j=4:9) %&gt;%\n  vline(j=c(\"Observed\",\"ALM_Residual\",\"EXAM_Residual\")) %&gt;%\n  hline(part = \"body\", i=c(6,12)) |&gt; \n  bold(i=long_vPreds$x %in% c(100,350,600), j=2) \n\n  # bold the cell with the lowest residual, based on best_wide df\n  # for each row, the cell that should be bolded matches which column in best_wide==1 at that row\nft &lt;- apply_best_formatting(ft, best_indexV)\nft\n\n\n\n\nTable 17: Varied group - mean model predictions vs. observations. Extrapolation Bands are bolded. For each Modelling fitting and band combination, the model with the smallest residual is highlighted. Only the lower bound of each velocity band is shown (bands are all 200 units).\n\n\n\nALMEXAMHybridFit MethodXObservedPredictedResidualPredictedResidualPredictedResidualTest Only100663675-12716-53708-45Test Only35076467589817-53792-28Test Only600884675209895-118759Test Only8001,0831,07851,000831,091-8Test Only1,0001,1961,202-61,199-31,204-8Test Only1,2001,2831,230531,28211,22162Test & Train100663675-12716-53707-44Test & Train35076467589817-53788-24Test & Train600884675209902-1885133Test & Train8001,0831,000831,000831,00479Test & Train1,0001,1961,163331,165311,1960Test & Train1,2001,2831,191921,194891,22756Train Only100663675-12716-53675-12Train Only35076467589817-5367589Train Only600884675209905-21675209Train Only8001,0831,000831,0008399984Train Only1,0001,1961,150461,150461,14353Train Only1,2001,2831,1801031,1801031,176107\n\n\n\n\n\n\n\nCode\npander(tvte, caption=\"Varied fit to test only\")\npander(tvtetr,caption=\"Varied fit to train and test\")\npander(tvtr,caption=\"Varied fit to train only\")",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#constant-testing-predictions",
    "href": "Sections/HTW.html#constant-testing-predictions",
    "title": "HTW Project",
    "section": "Constant Testing Predictions",
    "text": "Constant Testing Predictions\n\n\nCode\n##| column: screen-inset-right\n\n####\n\ncte &lt;-  pluck(a_te_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_te_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test Only\")\n\nctetr &lt;-  pluck(a_tetr_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tetr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") + \n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test and Train\")\n\nctr &lt;-  pluck(a_tr_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Train Only\")\n  \ncte/ctetr/ctr\n\n\n\n\n\n\n\n\nFigure 17: Constant Group - Mean Model predictions vs. observations\n\n\n\n\n\n\n\nCode\n##| column: screen-inset-right\n\n\n\nbest_cPreds &lt;- cPreds %&gt;%\n  pivot_longer(cols = c(ALM, EXAM, Hybrid), names_to = \"Model\", values_to = \"Predicted\") |&gt;\n  mutate(Residual=(Observed-Predicted), abs_res =abs(Residual)) |&gt; group_by(Fit_Method,x) |&gt;\n  mutate(best=if_else(abs_res==min(abs_res),1,0)) |&gt; select(-abs_res)\n\nlong_cPreds &lt;- best_cPreds |&gt; select(-best) |&gt;\n  pivot_longer(cols=c(Predicted,Residual), names_to=\"Model_Perf\") |&gt;\n  relocate(Model, .after=Fit_Method) |&gt; \n  unite(Model,Model,Model_Perf) |&gt;\n  pivot_wider(names_from=Model,values_from=value)\n\nbest_wideC &lt;- best_cPreds |&gt; select(-Residual,-Predicted,-Observed) |&gt; ungroup() |&gt;\n  pivot_wider(names_from=Model,values_from=best) |&gt; select(ALM,EXAM,Hybrid)\n\nbest_indexC &lt;- row_indices &lt;- apply(best_wideC, 1, function(row) {\n which(row == 1)\n})\n\n\nft &lt;- flextable(long_cPreds) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% \n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;%\n  hline(part = \"header\", i = 1, j=4:9) %&gt;%\n  vline(j=c(\"Observed\",\"ALM_Residual\",\"EXAM_Residual\")) %&gt;%\n  hline(part = \"body\", i=c(6,12)) |&gt; \n  bold(i=long_cPreds$x %in% c(100,350,600, 1000,1200), j=2) \n\n  # bold the cell with the lowest residual, based on best_wide df\n  # for each row, the cell that should be bolded matches which column in best_wide==1 at that row\n\nft &lt;- apply_best_formatting(ft, best_indexC)\nft\n\n\n\n\nTable 18: Constant group - mean model predictions vs. observations. The X values of Extrapolation Bands are bolded. For each Modelling fitting and band combination, the model with the smallest residual is highlighted. Only the lower bound of each velocity band is shown (bands are all 200 units).\n\n\n\nALMEXAMHybridFit MethodXObservedPredictedResidualPredictedResidualPredictedResidualTest Only100527675-148717-190717-190Test Only350666675-9822-156821-155Test Only600780675105927-147926-146Test Only8009806753051,010-301,009-29Test Only1,0001,1636754881,094691,09370Test Only1,2001,2776756021,178991,176101Test & Train100527675-148712-185711-184Test & Train350666675-9806-140800-134Test & Train600780675105900-120889-109Test & Train800980859121975596020Test & Train1,0001,1636754881,0491141,031132Test & Train1,2001,2776756021,1241531,102175Train Only100527675-148697-170675-148Train Only350666675-9752-86675-9Train Only600780675105807-27675105Train Only800980851129851129833147Train Only1,0001,163675488895268675488Train Only1,2001,277675602939338675602",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/Appendix/IGAS-Supplemental.html",
    "href": "Sections/Appendix/IGAS-Supplemental.html",
    "title": "Dissertation",
    "section": "",
    "text": "Reviewer #2: This study addresses a question that is important both theoretically and practically. However, the authors need to rule out the following, less interesting alternative. Namely, the results could be due to task practice effect, as follows.\nSince there was no pre-training test, and no practice trials (as far as I can tell), and since the task was an online motor task that participants could not rely on their prior motor experience, trying to launch the ball to the target could only be done via trial and error. For the varied training group, they got to practice at two distances. Therefore, they had a better “calibration” in terms of the relationship between launching speed and target distance. This was likely beneficial both in Exp.1 when both transfer distances were interpolations from the two trained distances, and in Exp.2 when two transfer distances were interpolations and two were extrapolations but the latter two were immediately next to the training distances.\nIn comparison, since the constant group trained at only a single distance, any transfer distance (or at least the first transfer distance tested) was extrapolation even if this transfer distance was shorter than the trained, because the participants did not know beforehand how to shoot the ball to the shortest distance due to the existence of the barrier. If the transfer distance was longer, for sure that was extrapolation.\nRegardless, the above analysis suggests that the constant group would always be a step behind the varied group. The number of trials at each transfer distance may not be sufficient for them to catch up the varied group either (whether there was learning during testing should be checked). If such disadvantage for the constant group is indeed due to the lack of tryout opportunities, then the authors should verify whether the same results still hold if all groups were provided opportunities to practice, or if pre-training tests across all distances were offered.\n\nexponential learning models fit to individual subjects\n\ne2TestFits &lt;- readRDS(here::here('data/IGAS-e2TestFits-April4.rds'))\ne2TestFits &lt;- e2TestFits %&gt;% mutate(Asymptote.Minus.Start=pAsym-pStart)\nexp2.fit2 &lt;- e2TestFits %&gt;% ungroup() %&gt;% group_by(sbjCode,conditType) %&gt;%\n  summarise(MeanAsym=mean(pAsym),MeanStart=mean(pStart),\n            MeanRate=mean(pRate),\n            asymMinusStart=mean(Asymptote.Minus.Start),.groups=\"keep\") %&gt;% \n  ungroup() %&gt;% as.data.frame()\n\n\n\nGroup comparison of learning rate fits\n\n# mr1=e2TestFits %&gt;% anova_test(dv=pRate,between=conditType,wid=sbjCode,within=positionX,type=3);show(mr1)\n# mr2=exp2.fit2 %&gt;% anova_test(dv=MeanRate,between=conditType,wid=sbjCode,type=3);show(mr2) \n\n# h4&lt;-e2TestFits %&gt;% ggplot(aes(x=positionX,y=pRate,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ggtitle(\"Learning rates \")+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)+ylab(\"Inverse Learning Rate\")+xlab(\"Testing Location\")\n# h4\n\n\n# mr1=e2TestFits %&gt;% filter(converged==TRUE)%&gt;% anova_test(dv=pRate,between=conditType,wid=sbjCode,within=positionX,type=3);show(mr1)\n# mr2=exp2.fit2 %&gt;% anova_test(dv=MeanRate,between=conditType,wid=sbjCode,type=3);show(mr2) \n\nh4&lt;-e2TestFits %&gt;%filter(Pval&lt;.4)%&gt;% ggplot(aes(x=positionX,y=pRate,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ggtitle(\"Learning rates \")+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)+ylab(\"Inverse Learning Rate\")+xlab(\"Testing Location\")\nh4\n\n\n\n\n\n\n\n\n\n\nFirst vs. second half of testing stage\n\ntestSplit &lt;- transfer %&gt;%\n  group_by(sbjCode, conditType, positionX, testHalfSbj) %&gt;%\n  summarise(\n    MeanTargetDistance = mean(AbsDistFromCenter),\n    MeanScaledDev =mean(scaledDev,trim=.05),\n    .groups = \"keep\"\n  ) %&gt;% \n  as.data.frame()\n\ntestSplit2 &lt;- transfer %&gt;%\n  group_by(sbjCode, conditType, testHalfSbj) %&gt;%\n  summarise(\n    MeanTargetDistance = mean(AbsDistFromCenter, trim = .01),\n    MeanScaledDev =\n      mean(scaledDev, trim = .05),\n    .groups = \"keep\"\n  ) %&gt;% as.data.frame()\n\n\ntsw &lt;- testSplit %&gt;% ungroup() %&gt;% \n  pivot_wider(names_from = testHalfSbj,values_from=c(MeanTargetDistance,MeanScaledDev)) %&gt;%\n  mutate(endMinusStart = `MeanTargetDistance_2nd-Half` - `MeanTargetDistance_1st-Half`,\n    endMinusStartScaled = `MeanScaledDev_2nd-Half` - `MeanScaledDev_1st-Half`) %&gt;% \n    as.data.frame()\n\ntsw2 &lt;- tsw %&gt;% \n  group_by(sbjCode,conditType) %&gt;% summarise(endMinusStart=mean(endMinusStart),endMinusStartScaled=mean(endMinusStartScaled)) %&gt;% as.data.frame()\n\n# testSplit %&gt;% ggplot(aes(x=testHalfSbj,y=MeanTargetDistance))+\n#   geom_bar(aes(group=conditType,fill=conditType),stat=\"summary\",position=dodge)+\n#   facet_wrap(~positionX,ncol=2)+\n#   stat_summary(aes(x=testHalfSbj,group=conditType),fun.data=mean_se,geom=\"errorbar\",position=dodge)\n\n\nh1=testSplit %&gt;% filter(testHalfSbj==\"1st-Half\") %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n geom_bar(aes(group=conditType,fill=conditType),stat=\"summary\",position=dodge,fun=\"mean\")+stat_summary(aes(x=positionX,group=conditType),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+\n scale_y_continuous(name=\"Mean Absolute Deviation From Target\",limits=c(0,400))+ \n ggtitle(\"Testing - 1st half\")+\n  ylab(\"Mean Absolute Deviation From Target\")+xlab(\"Testing Location\")+theme(legend.position=\"top\")\n\nh2=testSplit %&gt;% filter(testHalfSbj==\"2nd-Half\") %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n geom_bar(aes(group=conditType,fill=conditType),stat=\"summary\",position=dodge,fun=\"mean\")+\n  stat_summary(aes(x=positionX,group=conditType),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8) + \n scale_y_continuous(name=\"\",limits=c(0,400))+ \n ggtitle(\"Testing - 2nd half\")+\n  xlab(\"Testing Location\")+\n  theme(plot.title = element_text(hjust = 0.5))+\n  theme(legend.position=\"top\") +\n  guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)\n\n#egg::ggarrange(h1,h2,ncol=2)\n\n\nh3 &lt;- tsw %&gt;% ggplot(aes(x=positionX,y=endMinusStart))+\n  geom_bar(aes(group=conditType,fill=conditType),stat=\"summary\",position=dodge,fun=\"mean\")+\n  stat_summary(aes(x=positionX,group=conditType),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+\n  ylab(\"2nd Half Deviation - 1st Half Deviation\")+ \n  ggtitle(\"Improvement Per Location\")+\n  xlab(\"Testing Location\")+theme(plot.title = element_text(hjust = 0.5))+\n  guides(fill=guide_legend(title=\"Testing Location\")) +theme(legend.position=\"none\")\n\n#ggarrange(h1,h2,h3,h4,ncol=2)\n\n#(h1 + h2) / (h3)\n\n(h1+h2)/h3\n\n\n\n\n\n\n\n\n\n\nGroup Comparison for asymptote-starting performance\n\n# ma1=e2TestFits %&gt;% filter()%&gt;% anova_test(dv=Asymptote.Minus.Start,between=conditType,wid=sbjCode,within=positionX,type=3);show(ma1)\n# ma2=exp2.fit2 %&gt;% anova_test(dv=asymMinusStart,between=conditType,wid=sbjCode,type=3);show(ma2) \n\ne2TestFits %&gt;% ggplot(aes(x=conditType,y=Asymptote.Minus.Start,fill=conditType))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  facet_grid(~positionX)+ggtitle(\"e2 testing (asymptote - start performance)\") + \n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\n\n\n\nRelative distance and under/overshooting\nReviewer 3 Absolute versus relative distance: From a methodological standpoint, I understand the need to differentiate these two types of distance. However, from a theoretical perspective there may be some issue in differentiating these two concepts. Schema theory relies on relative (or invariant) information to inform the motor program. However, both distances would be important to an instance or exemplar representation. You may want to consider commenting on this issue.\nReviewer 2 For the same reason, the plots showing improvement during training could be due to participants learning the task, rather than fine motor skills. Although task learning and motor learning are impossible to separate cleanly, the common practice in the field is indeed to offer practice trials to reduce the task learning aspects. The authors should address this.\nIn addition to absolute errors (which is related to variance), the authors should also provide other measures of performance, e.g., the mean of the signed errors, so that readers have a better idea whether there was any meaningful over- or undershooting.\n\nexperiment 1 training - relative distances\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=========================================================================\nconditType devianceDirection      610            760            910      \n-------------------------------------------------------------------------\nconstant       Overshoot                    311.84(307.92)               \nconstant      Undershoot                    188.05(163.62)               \nvaried         Overshoot     211.69(234.97)                360.14(322.01)\nvaried        Undershoot     107.35(81.21)                 244.85(196.47)\n-------------------------------------------------------------------------\n\n\n\n======================================================\nconditType      610           760            910      \n------------------------------------------------------\nconstant                 121.03(269.17)               \nvaried     39.91(178.12)                150.53(290.04)\n------------------------------------------------------\n\n\n\n====================================================================\nconditType     610           760            835            910      \n--------------------------------------------------------------------\nconstant   7.13(124.02) 107.02(218.49) 142.42(252.34) 122.92(282.58)\nvaried     3.19(96.67)   92.1(173.9)   103.84(214.4)  108.12(234.59)\n--------------------------------------------------------------------\n\n\n\n\nexperiment 2 training - relative distances\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExperiment 1 Testing - relative distances\n\n\n\n\n\n\n\n\n\n\n====================================================================================================================================\nconditType2         msdu_610       msdu_760       msdu_835       msdu_910      msds_610      msds_760      msds_835      msds_910   \n------------------------------------------------------------------------------------------------------------------------------------\nConstant Training 136.27(84.29) 191.65(112.65) 219.46(139.91) 276.75(153.09) 25.28(158.98) 50.82(217.48) 73.14(250.93) 50.76(313.77)\nVaried Training   105.12(51.39)  149.37(93.4)  180.54(129.52) 198.64(137.84) 13.85(116.87) 50.59(169.59) 50.52(217.39) 49.94(237.71)\n------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n=========================================================================\nCondition              610           760           835           910     \n-------------------------------------------------------------------------\nConstant Training 25.28(158.98) 50.82(217.48) 73.14(250.93) 50.76(313.77)\nVaried Training   13.85(116.87) 50.59(169.59) 50.52(217.39) 49.94(237.71)\n-------------------------------------------------------------------------\n\n\n\n\nExperiment 2 Testing - relative distances\n\n\n\n\n\n\n\n\n\n\n\nExperimenet 1 - intermittent testing\n\nintTest.half &lt;- readRDS(here::here(\"data/e1_intTest.rds\"))\n\nintTest.half %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n  geom_bar(aes(group=trainHalf,fill=trainHalf),stat=\"summary\",fun=mean,position=dodge)+\n  facet_wrap(~conditType,ncol=2)+\n  stat_summary(aes(x=positionX,group=trainHalf),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+\n  ylab(\"Mean Distance From Center Of Target\")+\n  xlab(\"Intermittent Testing Throw Location\")+theme(plot.title = element_text(hjust = 0.5))+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)\n\n\n\n\n\n\n\ncnames=c(\"Condition\",\"610_First Half\",\"760_First Half\",\"910_First Half\",\"610_Second Half\",\"760_Second Half\",\"910_Second Half\")\ntest= intTest.half %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,trainHalf,positionX) %&gt;% \n  summarise(Mean=round(mean(MeanTargetDistance),2),sd=round(sd(MeanTargetDistance),2)) \ntest=test %&gt;% group_by(Condition) %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\")) %&gt;%\n select(Condition,positionX,trainHalf,msd)%&gt;% pivot_wider(names_from = c(positionX,trainHalf),values_from=c(msd))\ntest=test %&gt;% as.data.frame()\ncolnames(test) &lt;- cnames\nstargazer(test,type=\"text\",summary=FALSE,rownames=FALSE)\n\n\n======================================================================================================\nCondition 610_First Half 760_First Half 910_First Half 610_Second Half 760_Second Half 910_Second Half\n------------------------------------------------------------------------------------------------------\nconstant  206.64(82.08)  286.51(121.07) 406.93(145.2)   187.2(55.24)    238.21(95.16)  313.27(114.86) \nvaried    195.68(78.58)  278.9(105.37)  318.53(134.81)  177.79(70.82)  224.98(108.04)   276.86(110.5) \n------------------------------------------------------------------------------------------------------\n\n\n\n\n\nTraining plots - Experiment 1\n\n# possible that scaling required loading special package from devtools\nexp1Train &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1) %&gt;% group_by(Group,sbjCode) %&gt;%mutate(scaleDev=scale_this(AbsDistFromCenter)) %&gt;%ungroup() %&gt;% group_by(Group,sbjCode,stage,conditType)\nexp1Train = exp1Train %&gt;% summarise(MeanTargetDistance=mean(AbsDistFromCenter),scaledDist=mean(scaleDev,trim=.05))\nexp1Train$stage &lt;- factor(exp1Train$stage, levels = c(\"Beginning\", \"Middle\", \"End\")) #in case the levels get out of order\nexp1TrainTrials &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1,trialType!=44) %&gt;% group_by(Group,sbjCode,positionX) %&gt;% mutate(scaleDev=scale_this(AbsDistFromCenter),ind=1,trainIndex=cumsum(ind)) %&gt;%ungroup() %&gt;% group_by(Group,sbjCode,stage,conditType)\n\n\n\n# manuscript plot - original\nggplot(data = exp1Train, aes(x=stage, y=MeanTargetDistance)) + geom_boxplot(aes(fill=conditType),position=position_dodge(1))+stat_summary(fun=\"mean\",aes(group=conditType),position=position_dodge(1))+\nylab(\"Mean Distance From Center Of Target\") +xlab(\"Training Stage\")+theme(plot.title = element_text(hjust = 0.5))+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.5)+theme_classic()\n\n\n\n\n\n\n\nlineplot.CI(data=exp1Train,x.factor=stage,group=conditType,response=scaledDist,xlab=\"Training Stage\",x.leg=2,legend=TRUE,ylab=\"Distance from Target (scaled)\",main=\"Training Performance - Experiment 1\",col=c(\"red\",\"black\"))\n\n\n\n\n\n\n\nlineplot.CI(data=exp1Train,x.factor=stage,group=conditType,response=MeanTargetDistance,xlab=\"Training Stage\",x.leg=2,legend=TRUE,ylab=\"Distance From Target\",main=\"Training Performance - Experiment 1\",col=c(\"red\",\"blue\"))\n\n\n\n\n\n\n\n\n\nNot in manuscript\n\n\nfit to testing performance averaged across positions\n\ne2Fits.AggPos &lt;- readRDS(here::here('data/IGAS-e2Fits.AggPos-April_12.rds'))\n\ne2Fits.AggPos %&gt;% ggplot(aes(x=Group,y=pStart,fill=Group))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  ggtitle(\"experiment 2 - starting performance per position\") + \n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\ne2Fits.AggPos %&gt;% ggplot(aes(x=Group,y=pAsym,fill=Group))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  ggtitle(\"e2 testing performance asymptote per position \") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\ne2Fits.AggPos %&gt;% ggplot(aes(x=Group,y=pRate,fill=Group))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  ggtitle(\"e2 testing performance asymptote per position \") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\n#mr1=e2Fits.AggPos %&gt;% anova_test(dv=pRate,between=conditType,wid=sbjCode,type=3);show(mr1)\n\n\n\nstatistical tests for starting performance\n\nms1=e2TestFits %&gt;% filter(converged==TRUE) %&gt;% anova_test(dv=pStart,between=conditType,wid=sbjCode,within=positionX,type=3);\nms2=exp2.fit2 %&gt;% anova_test(dv=MeanStart,between=conditType,wid=sbjCode,type=3);\n#ms1\nms2 \n\nANOVA Table (type III tests)\n\n      Effect DFn DFd    F     p p&lt;.05   ges\n1 conditType   1 206 3.04 0.083       0.015\n\ne2TestFits %&gt;% ggplot(aes(x=conditType,y=pStart,fill=conditType))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  facet_grid(~positionX)+ggtitle(\"experiment 2 - starting performance per position\") + \n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n\n\n\n\n\n\n\n\n\n\nstatistical tests for asymptote\n\nma1=e2TestFits %&gt;% filter(converged==TRUE)%&gt;% anova_test(dv=pAsym,between=conditType,wid=sbjCode,within=positionX,type=3);\nma2=exp2.fit2 %&gt;% anova_test(dv=MeanAsym,between=conditType,wid=sbjCode,type=3);\nma2\n\nANOVA Table (type III tests)\n\n      Effect DFn DFd    F     p p&lt;.05   ges\n1 conditType   1 206 3.38 0.067       0.016\n\ne2TestFits %&gt;% ggplot(aes(x=conditType,y=pAsym,fill=conditType))+\n  geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+\n  facet_grid(~positionX)+ggtitle(\"e2 testing performance asymptote per position \") + \n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "Outline.html",
    "href": "Outline.html",
    "title": "Dissertation Outline",
    "section": "",
    "text": "In Project 1, I programmed a simple projectile launching task to serve as a conceptual replication of an influential paradigm in the visuomotor skill learning literature. Several of the canonical empirical patterns are replicated, with the varied trained participants tending to perform better during testing in both experiments. A major issue with previous research in the cross-disciplinary “benefits of variability” literature is that many previous works do not adequately control for the similarity between training and testing conditions. Such issues arise when both from failures to consider the possibility of non-linear generalization, and from often the unquestioned assumption that participants are acquiring, and then generalizing from prototype or schema-based representations. I introduce a theoretically motivated method of explicitly quantifying the similarity between training experience and testing condition. The resulting similarity quantity can then be used to explicitly control for similarity (by adding it as a covariate to the statistical model). The effect of variability remains significant while controlling for similarity, which I argue is a more rigorous demonstration of the effect of variability on testing performance than what is typically provided with standard methods. I conclude by introducing an extended version of the model that assumes training variation influences the steepness of the generalization gradient. With this flexible similarity mechanism, the group-level effect of variability can then be accounted for within the similarity-based generalization framework.\n\n\n\n\nIn Project 2, a modified version of the task from Project 1 is used in conjunction with a testing procedure that challenges participants to extrapolate well beyond their training experience. In line with previous research in the function learning literature, participants show evidence of successful extrapolation in our linear task environment. Surprisingly though, the constant training group outperforms the varied training group consistently across numerous variants of the task. Such a pattern is far from unheard of in the vast literature on training variability, and it is therefore remains a worthwhile challenge to evaluate the ability of similarity-based models to account for the observed effects. Additionally, the cognitive process models implemented for project 2 will go beyond the modelling efforts of the previous project in two respects. 1) Extensions that enable the model to produce predictions of participant responses, and 2) fitting and attempting to account for behavior in both training AND testing phases of the experiment.\n\nhttps://tegorman13.github.io/DP/\n\n\n\n\n\n\nProject 1\n\nAbstract\nIntroduction\n\nSimilarity and instance-based approaches to transfer of learning\nThe effect of training variability on transfer\nIssues with Previous Research\n\nExperiment 1\n\nMethods\n\nSample Size Estimation\nParticipants\nTask\n\nResults\nData Processing and Statistical Packages\nTraining Phase\nTesting Phase\nDiscussion\n\nExperiment 2\n\nMethods\n\nParticipants\nTask and Procedure\n\nResults\n\nData Processing and Statistical Packages\nTraining Phase\nTesting Phase\n\nDiscussion\n\nComputational Model\n\nFitting model parameters separately by group\n\nGeneral Discussion\n\nLimitations\nConclusion\n\nReferences\n\nProject 2\n\nIntroduction\nMethods\n\nParticipants\nTask\nDesign\n\nResults\n\nTraining\nTesting\n\nModeling\n\nALM & Exam Description\nModel Equations\nModel Fitting and Comparison\n\nReferences\n\nProject 3\n\nOverview\nMethods\n\nDataset and Game Description\nSplit-Test Data\n\nTrial-by-trial influence of variability\n\nRandomization\nMeasuring Trial-by-trial variability\n\nComputational Modelling\n\nSimilarity Between Trials\nMeasurement model of learning and performance\n\nReferences"
  },
  {
    "objectID": "Outline.html#dissertation-outline",
    "href": "Outline.html#dissertation-outline",
    "title": "Dissertation Outline",
    "section": "",
    "text": "In Project 1, I programmed a simple projectile launching task to serve as a conceptual replication of an influential paradigm in the visuomotor skill learning literature. Several of the canonical empirical patterns are replicated, with the varied trained participants tending to perform better during testing in both experiments. A major issue with previous research in the cross-disciplinary “benefits of variability” literature is that many previous works do not adequately control for the similarity between training and testing conditions. Such issues arise when both from failures to consider the possibility of non-linear generalization, and from often the unquestioned assumption that participants are acquiring, and then generalizing from prototype or schema-based representations. I introduce a theoretically motivated method of explicitly quantifying the similarity between training experience and testing condition. The resulting similarity quantity can then be used to explicitly control for similarity (by adding it as a covariate to the statistical model). The effect of variability remains significant while controlling for similarity, which I argue is a more rigorous demonstration of the effect of variability on testing performance than what is typically provided with standard methods. I conclude by introducing an extended version of the model that assumes training variation influences the steepness of the generalization gradient. With this flexible similarity mechanism, the group-level effect of variability can then be accounted for within the similarity-based generalization framework.\n\n\n\n\nIn Project 2, a modified version of the task from Project 1 is used in conjunction with a testing procedure that challenges participants to extrapolate well beyond their training experience. In line with previous research in the function learning literature, participants show evidence of successful extrapolation in our linear task environment. Surprisingly though, the constant training group outperforms the varied training group consistently across numerous variants of the task. Such a pattern is far from unheard of in the vast literature on training variability, and it is therefore remains a worthwhile challenge to evaluate the ability of similarity-based models to account for the observed effects. Additionally, the cognitive process models implemented for project 2 will go beyond the modelling efforts of the previous project in two respects. 1) Extensions that enable the model to produce predictions of participant responses, and 2) fitting and attempting to account for behavior in both training AND testing phases of the experiment.\n\nhttps://tegorman13.github.io/DP/\n\n\n\n\n\n\nProject 1\n\nAbstract\nIntroduction\n\nSimilarity and instance-based approaches to transfer of learning\nThe effect of training variability on transfer\nIssues with Previous Research\n\nExperiment 1\n\nMethods\n\nSample Size Estimation\nParticipants\nTask\n\nResults\nData Processing and Statistical Packages\nTraining Phase\nTesting Phase\nDiscussion\n\nExperiment 2\n\nMethods\n\nParticipants\nTask and Procedure\n\nResults\n\nData Processing and Statistical Packages\nTraining Phase\nTesting Phase\n\nDiscussion\n\nComputational Model\n\nFitting model parameters separately by group\n\nGeneral Discussion\n\nLimitations\nConclusion\n\nReferences\n\nProject 2\n\nIntroduction\nMethods\n\nParticipants\nTask\nDesign\n\nResults\n\nTraining\nTesting\n\nModeling\n\nALM & Exam Description\nModel Equations\nModel Fitting and Comparison\n\nReferences\n\nProject 3\n\nOverview\nMethods\n\nDataset and Game Description\nSplit-Test Data\n\nTrial-by-trial influence of variability\n\nRandomization\nMeasuring Trial-by-trial variability\n\nComputational Modelling\n\nSimilarity Between Trials\nMeasurement model of learning and performance\n\nReferences"
  },
  {
    "objectID": "Sections/Appendix/E1_Appendix.html",
    "href": "Sections/Appendix/E1_Appendix.html",
    "title": "Dissertation",
    "section": "",
    "text": "# print(getwd())\n# here::set_here(path='..')\n# print(getwd())\nsource(here::here(\"Functions\", \"packages.R\"))\n\nLoading required package: pacman\n\n\n\ntest &lt;- readRDS(here::here(\"data/e1_08-21-23.rds\")) |&gt; filter(expMode2 == \"Test\")  |&gt;\n  select(id,condit,bandInt,vb,vx,dist,sdist,bandType,tOrder)\n\n\nPosterior Predictive Distributions\n\ndist_pred &lt;- \n  posterior_predict(e1_distBMM, ndraws = 500) |&gt; \n  array_branch(margin=1) |&gt; \n   map_dfr( \n    function(yrep_iter) {\n      test  |&gt;\n        mutate(dist_pred = yrep_iter)\n    },\n    .id = 'iter'\n  ) |&gt;\n  mutate(iter = as.numeric(iter))\n\n\n\ndist_pred  |&gt;\n  filter(iter &lt; 100) %&gt;%\n  ggplot(aes(dist_pred, group = iter)) +\n  geom_line(alpha = .03, stat = 'density', color = 'blue') +\n  geom_density(data = test,\n               aes(dist,col=vb),\n               inherit.aes = FALSE,\n               size = 0.7) + # 1\n  facet_grid(condit ~ vb) +\n  xlab('Deviation')\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\nFigure 1: Posterior Predictive distributions for Absolute Deviance. Posterior Draws in Blue, colored lines are empirical data.\n\n\n\n\n\n\nvx_pred &lt;- \n  posterior_predict(e1_vxBMM, ndraws = 500) |&gt; \n  array_branch(margin=1) |&gt; \n   map_dfr( \n    function(yrep_iter) {\n      test  |&gt;\n        mutate(vx_pred = yrep_iter)\n    },\n    .id = 'iter'\n  ) |&gt;\n  mutate(iter = as.numeric(iter))\n\n\n\nvx_pred  |&gt;\n  filter(iter &lt; 100) %&gt;%\n  ggplot(aes(vx_pred, group = iter)) +\n  geom_line(alpha = .03, stat = 'density', color = 'blue') +\n  geom_density(data = test,\n               aes(vx,col=vb),\n               inherit.aes = FALSE,\n               size = 0.7) + # 1\n  facet_grid(condit ~ vb) +\n  xlab('Vx')\n\n\n\n\n\n\n\nFigure 2: Posterior Predictive distributions for Vx. Posterior Draws in Blue, colored lines are empirical data.\n\n\n\n\n\n\n\nEmpirical vs. Predicted\n\n{\nvx_pred  |&gt;\n  filter(iter &lt; 100)  |&gt; group_by(id,condit,vb,iter) |&gt;\n  summarise(vx_pred=mean(vx_pred)) %&gt;%\n  ggplot(aes(x=vb,y=vx_pred,fill=condit)) + \n  geom_flat_violin( position = position_nudge(x = 0.1, y = 0),\n                   adjust = 1.5,\n                   trim = FALSE, alpha = .5, colour = NA) +\n  # geom_point(aes(x = as.numeric(vb) - 0.15, y = vx_pred, colour = vb),\n  #            position = position_jitter(width = 0.05, height = 0),\n  #            size = 1, shape = 20) +\n  geom_boxplot(aes(x = vb, y = vx_pred, fill = condit),\n               outlier.shape = NA,\n               alpha = 0.5,\n               width = 0.1,\n               colour = \"black\") +\n  geom_hline(yintercept = 0,\n             linetype = 'dashed',\n             color = 'red',\n             size = 0.4) + \n  coord_flip() + ggtitle(\"Predicted Vx\")  \n} / {\nvx_pred  |&gt;\n  filter(iter &lt; 2)  |&gt; group_by(id,condit,vb) |&gt;\n  summarise(vx=mean(vx)) %&gt;%\n  ggplot(aes(x=vb,y=vx,fill=condit)) + \n  geom_flat_violin( position = position_nudge(x = 0.1, y = 0),\n                   adjust = 1.5,\n                   trim = FALSE,\n                   alpha = .5,\n                   colour = NA) +\n  geom_point(aes(x = as.numeric(vb) - 0.15,col=condit),\n             # position = position_jitter(width = 0.05),\n             position = position_jitter(width = 0.05, height = 0),\n             size = 1,\n             shape = 20) +\n  geom_boxplot(\n               outlier.shape = NA,\n               alpha = 0.5,\n               width = 0.1,\n               colour = \"black\") +\n  geom_hline(yintercept = 0,\n             linetype = 'dashed',\n             color = 'red',\n             size = 0.4) + \n  coord_flip() + ggtitle(\"Empirical Vx\") \n}\n\nWarning: Using the `size` aesthetic with geom_polygon was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n\n\n\n\n\n\n\n\nFigure 3: Bayesian Mixed Model predictions vs. Empirical Predictions - X velocity\n\n\n\n\n\n\n\nDifferent Aggregations\n\nepId &lt;- dist_pred  |&gt;\n  filter(iter &lt; 2)  |&gt; group_by(id,condit,vb) |&gt;\n  summarise(dist=median(dist)) |&gt;\n  ggplot(aes(x=vb,y=dist,fill=condit)) + \n  geom_flat_violin(aes(fill=condit), position = position_nudge(x = 0.1, y = 0),\n                   adjust = 1.5,trim = FALSE, alpha = .5, colour = NA) +\n  geom_point(aes(x = as.numeric(vb) - 0.15, col=condit),\n             position = position_jitter(width = 0.05, height = 0),\n             size = 1, shape = 20, alpha=.7) +\n  geom_boxplot(aes(x=vb,y=dist,fill=condit),\n               outlier.shape = NA,\n               alpha = 0.5, width = 0.1) +\n  geom_hline(yintercept = 0,\n             linetype = 'dashed',\n             color = 'red',\n             size = 0.4) + \n  coord_flip() + ggtitle(\"Empirical Deviation - Subject level averaging\") \n\n\n\nepId \n\n\n\n\n\n\n\nFigure 4: E1. Distribution of Vx at Participant level\n\n\n\n\n\n\nepTrial &lt;- dist_pred  |&gt;\n  filter(iter &lt; 2)  |&gt; group_by(id,condit,vb) |&gt;\n  ggplot(aes(x=vb,y=dist,fill=condit)) + \n  geom_flat_violin(aes(fill=condit), position = position_nudge(x = 0.1, y = 0),\n                   adjust = 1.5,trim = FALSE, alpha = .5, colour = NA) +\n  geom_point(aes(x = as.numeric(vb) - 0.15, col=condit),\n             position = position_jitter(width = 0.05, height = 0),\n             size = .5, shape = 20, alpha=.7) +\n  geom_boxplot(aes(x=vb,y=dist,fill=condit),\n               outlier.shape = NA,\n               alpha = 0.5, width = 0.1) +\n  geom_hline(yintercept = 0,\n             linetype = 'dashed',\n             color = 'red',\n             size = 0.4) + \n  coord_flip() + ggtitle(\"Empirical Deviation - Raw Trial\") +\n   theme(axis.title.y=element_blank(),\n        axis.text.y=element_blank())\n\nepTrial\n\n\n\n\n\n\n\nFigure 5: E1. Distribution of Vx at Trial level\n\n\n\n\n\n\nnew_data_grid=map_dfr(1, ~data.frame(unique(test[,c(\"id\",\"condit\",\"bandInt\")])))\n\ncSamp &lt;- e1_distBMM  |&gt; \n  emmeans(\"condit\",by=\"bandInt\",at=list(bandInt=c(100,350,600,800,1000,1200)),\n          epred = TRUE, re_formula = NA) |&gt; \n  pairs() |&gt; gather_emmeans_draws()  |&gt;\n  group_by(contrast, .draw,bandInt) |&gt; summarise(value=mean(.value), n=n())\n\nLoading required namespace: rstanarm\n\n ameBand &lt;- cSamp |&gt; ggplot(aes(x=value,y=\"\")) + \n  stat_halfeye() + \n  geom_vline(xintercept=0,alpha=.4)+\n  facet_wrap(~bandInt,ncol=1) + labs(x=\"Marginal Effect (Constant - Varied)\", y= NULL)+\n  ggtitle(\"Average Marginal Effect\")\n\nbothConditGM &lt;- e1_distBMM %&gt;%\n  epred_draws(newdata = new_data_grid,ndraws = 2000, re_formula = NA) |&gt;\n  ggplot(aes(x=.epred,y=\"Mean\",fill=condit)) + \n  stat_halfeye() +facet_wrap(~bandInt, ncol = 1) +\n  labs(x=\"Predicted Deviation\", y=NULL)+\n  ggtitle(\"Grand Means\") +theme(legend.position = \"bottom\")\n\n(bothConditGM | ameBand) + plot_layout(widths=c(2,1.0))\n\n\n\n\n\n\n\nFigure 6: E1. Predicted Means Per Condition and Band, and Average Marginal Effect (Constant - Varied)"
  },
  {
    "objectID": "Sections/Discussion.html",
    "href": "Sections/Discussion.html",
    "title": "General Discussion",
    "section": "",
    "text": "Optional: - emphasize that both tasks involve extrapolation - it’s just emphasized more in Project 2, and project 2 is designed to more closely mirror tasks used in the function learning literature.",
    "crumbs": [
      "General Discussion"
    ]
  },
  {
    "objectID": "Sections/IGAS.html",
    "href": "Sections/IGAS.html",
    "title": "IGAS Project",
    "section": "",
    "text": "pdf of the journal article\nLink to online version of journal article\nCode\npacman::p_load(tidyr,papaja, knitr, tinytex, RColorBrewer, kableExtra, cowplot, patchwork,here)\nsource(here::here('Functions/IGAS_ProcessFunctions.R'))\n\ntheme_set(theme_classic())\n# load the processed data from experiment 1 and 2\ne1 &lt;- readRDS(here::here(\"data/igas_e1_cleanedData-final.rds\")) %&gt;% mutate(initialVelocityX=X_Velocity,initialVelocityY=Y_Velocity,stageInt=as.numeric(as.character(experimentStage)))\ne2&lt;- readRDS(here::here('data/igas_e2_cleanedData-final.rds')) %&gt;% mutate(initialVelocityX=X_Velocity,initialVelocityY=Y_Velocity)\n# load subject similarity data - computed with the IGAS model in 'IGAS-SimModel.R'\ne2_sim &lt;- readRDS(here::here('data/IGAS_Similarity-Performance.rds'))\n\noptions(contrasts = c(\"contr.sum\", \"contr.poly\"))\ndefaultContrasts = options()$contrasts\ntheme_set(theme_classic())\n\ndodge &lt;- position_dodge(width = 0.9)\ne2GrpPos &lt;- c(\"400\",\"500\",\"625\",\"675\",\"800\",\"900\")\ne2Grp &lt;- paste(\"Constant\",\"Constant\", \"Constant\",\"Constant\",\"Constant\",\"Constant\", \"Varied\")\ne2Labels &lt;- paste(c(\"400\\n Constant\",\"500\\n Constant\",\"625\\n Constant\",\"675\\n Constant\",\n                   \"800\\n Constant\",\"900\\n Constant\",\"500-800\\n Varied\"),sep=\"\")\n\ne1Pos &lt;- c(\"610\",\"760\",\"835\",\"910\")\ne1Var &lt;- paste(\"Varied Train Position\",\"Constant Train Position\", \"Novel Position\", \"Varied Training Position\")\ne1Labels&lt;- paste(c(\"610\\n Varied Trained\",\"760\\n Constant Trained\",\"835\\n Novel Location\",\"910\\n Varied Trained\"),sep=\"\")",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#similarity-and-instance-based-approaches-to-transfer-of-learning",
    "href": "Sections/IGAS.html#similarity-and-instance-based-approaches-to-transfer-of-learning",
    "title": "IGAS Project",
    "section": "Similarity and instance-based approaches to transfer of learning",
    "text": "Similarity and instance-based approaches to transfer of learning\nNotions of similarity have long played a central role in many prominent models of generalization of learning, as well as in the longstanding theoretical issue of whether learners abstract an aggregate, summary representation, or if they simply store individual instances. Early models of learning often assumed that discrete experiences with some task or category were not stored individually in memory, but instead promoted the formation of a summary representation, often referred to as a prototype or schema, and that exposure to novel examples would then prompt the retrieval of whichever preexisting prototype was most similar (Posner & Keele, 1968). Prototype models were later challenged by the success of instance-based or exemplar models – which were shown to provide an account of generalization as good or better than prototype models, with the advantage of not assuming the explicit construction of an internal prototype (Estes, 1994; Hintzman, 1984; Medin & Schaffer, 1978; Nosofsky, 1986 ). Instance-based models assume that learners encode each experience with a task as a separate instance/exemplar/trace, and that each encoded trace is in turn compared against novel stimuli. As the number of stored instances increases, so does the likelihood that some previously stored instance will be retrieved to aid in the performance of a novel task. Stored instances are retrieved in the context of novel stimuli or tasks if they are sufficiently similar, thus suggesting that the process of computing similarity is of central importance to generalization.\nSimilarity, defined in this literature as a function of psychological distance between instances or categories, has provided a successful account of generalization across numerous tasks and domains. In an influential study demonstrating an ordinal similarity effect, experimenters employed a numerosity judgment task in which participants quickly report the number of dots flashed on a screen. Performance (in terms of response times to new patterns) on novel dot configurations varied as an inverse function of their similarity to previously trained dot configurations Palmeri (1997). That is, performance was better on novel configurations moderately similar to trained configurations than to configurations with low-similarity, and also better on low-similarity configurations than to even less similar, unrelated configurations. Instance-based approaches have had some success accounting for performance in certain sub-domains of motor learning (Cohen & Rosenbaum, 2004; Crump & Logan, 2010; Meigh et al., 2018; Poldrack et al., 1999; Wifall et al., 2017). Crump & Logan (2010) trained participants to type words on an unfamiliar keyboard, while constraining the letters composing the training words to a pre-specified letter set. Following training, typing speed was tested on previously experienced words composed of previously experienced letters; novel words composed of letters from the trained letter set; and novel words composed of letters from an untrained letter set. Consistent with an instance-based account, transfer performance was graded such that participants were fastest at typing the words they had previously trained on, followed by novel words composed of letters they had trained on, and slowest performance for new words composed of untrained letters.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#the-effect-of-training-variability-on-transfer",
    "href": "Sections/IGAS.html#the-effect-of-training-variability-on-transfer",
    "title": "IGAS Project",
    "section": "The effect of training variability on transfer",
    "text": "The effect of training variability on transfer\nWhile similarity-based models account for transfer by the degree of similarity between previous and new experiences, a largely separate body of research has focused on improving transfer by manipulating characteristics of the initial training stage. Such characteristics have included training difficulty, spacing, temporal order, feedback schedules, and the primary focus of the current work – variability of training examples.\nResearch on the effects of varied training typically compares participants trained under constant, or minimal variability conditions to those trained from a variety of examples or conditions (Czyż, 2021; Soderstrom & Bjork, 2015). Varied training has been shown to influence learning in myriad domains including categorization of simple stimuli (Hahn et al., 2005; Maddox & Filoteo, 2011; Posner & Keele, 1968), complex categorization (Nosofsky et al., 2018), language learning (Jones & Brandt, 2020; Perry et al., 2010; Twomey et al., 2018; Wonnacott et al., 2012), anagram completion (Goode et al., 2008), trajectory extrapolation (Fulvio et al., 2014), task switching (Sabah et al., 2019), associative learning (Lee et al., 2019), visual search (George & Egner, 2021; Gonzalez & Madhavan, 2011; Kelley & Yantis, 2009), voice identity learning (Lavan et al., 2019), simple motor learning (Braun et al., 2009; Kerr & Booth, 1978; Roller et al., 2001; Willey & Liu, 2018a), sports training (Green et al., 1995; North et al., 2019), and training on a complex video game (Seow et al., 2019).\nTraining variation has received a particularly large amount of attention within the domain of visuomotor skill learning. Much of this research has been influenced by the work of Schmidt (1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. According to Schema Theory, learners possess general motor programs for classes of movements (e.g. throwing a ball with an underhand movement), as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class. Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices from multiple levels of a task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations. Empirically observed benefits of the varied-trained group are then attributed to the variation they received during training, a finding observed in numerous studies (Catalano & Kleiner, 1984; Chua et al., 2019; Goodwin et al., 1998; Kerr & Booth, 1978; Wulf, 1991), and the benefits of this variation are typically thought to be mediated by the development of a more general schema for the throwing motion.\nOf course, the relationship between training variability and transfer is unlikely to be a simple function wherein increased variation is always beneficial. Numerous studies have found null, or in some cases negative effects of training variation (DeLosh et al., 1997; Sinkeviciute et al., 2019; Wrisberg et al., 1987), and many more have suggested that the benefits of variability may depend on additional factors such as prior task experience, the order of training trials, or the type of transfer being measured (Berniker et al., 2014; Braithwaite & Goldstone, 2015; Hahn et al., 2005; Lavan et al., 2019; North et al., 2019; Sadakata & McQueen, 2014; Zaman et al., 2021).",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#issues-with-previous-research",
    "href": "Sections/IGAS.html#issues-with-previous-research",
    "title": "IGAS Project",
    "section": "Issues with Previous Research",
    "text": "Issues with Previous Research\nAlthough the benefits of training variation in visuomotor skill learning have been observed many times, null findings have also been repeatedly found, leading some researchers to question the veracity of the variability of practice hypothesis (Newell, 2003; Van Rossum, 1990). Critics have also pointed out that investigations of the effects of training variability, of the sort described above, often fail to control for the effect of similarity between training and testing conditions. For training tasks in which participants have numerous degrees of freedom (e.g. projectile throwing tasks where participants control the x and y velocity of the projectile), varied groups are likely to experience a wider range of the task space over the course of their training (e.g. more unique combinations of x and y velocities). Experimenters may attempt to account for this possibility by ensuring that the training location(s) of the varied and constant groups are an equal distance away from the eventual transfer locations, such that their training throws are, on average, equally similar to throws that would lead to good performance at the transfer locations. However, even this level of experimental control may still be insufficient to rule out the effect of similarity on transfer. Given that psychological similarity is typically best described as either a Gaussian or exponentially decaying function of psychological distance (Ennis et al., 1988; Ghahramani et al., 1996; Logan, 1988; Nosofsky, 1992; Shepard, 1987; Thoroughman & Taylor, 2005 ), it is plausible that a subset of the most similar training instances could have a disproportionate impact on generalization to transfer conditions, even if the average distance between training and transfer conditions is identical between groups. Figure 1 demonstrates the consequences of a generalization gradient that drops off as a Gaussian function of distance from training, as compared to a linear drop-off.\n\n\nCode\np=2\nc&lt;- .0002\nsimdat &lt;- data.frame(x=rep(seq(200,1000),3),condit=c(rep(\"varied\",1602),rep(\"constant\",801)),\n                     train.position=c(rep(400,801),rep(800,801),rep(600,801)),c=.0002,p=2) %&gt;%\n                     mutate(plotjitter=ifelse(condit==\"varied\",0,7),\n                            linScale=ifelse(condit==\"varied\",980,1000),\n                            genGauss=exp(-c*(abs((x-train.position)^p))),\n                            genLinear=1000-abs(x-train.position)+plotjitter) %&gt;% \n  #group_by(condit) %&gt;% mutate(scaleLinear=(genLinear-min(genLinear))/(max(genLinear)-min(genLinear))) \n  group_by(x,condit) %&gt;%\n  reframe(genGauss=mean(genGauss),genLinear=mean(genLinear)/linScale,.groups = 'keep')\ncolorVec=c(\"darkblue\",\"darkred\")\nplotSpecs &lt;- list(geom_line(alpha=.7,size=.4),scale_color_manual(values=colorVec),\n                  geom_vline(alpha=.55,xintercept = c(400,800),color=colorVec[2]),\n                  geom_vline(alpha=.55,xintercept = c(600),color=colorVec[1]),\n                  ylim(c(0,1.05)),\n                  #xlim(c(250,950)),\n                  scale_x_continuous(breaks=seq(200,1000,by=200)),\n                  xlab(\"Test Stimulus\"),\n                  annotate(geom=\"text\",x=447,y=1.05,label=\"Varied\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=450,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=659,y=1.05,label=\"Constant\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=657,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=847,y=1.05,label=\"Varied\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=850,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  theme(panel.border = element_rect(colour = \"black\", fill=NA, linewidth=1),\n                        legend.position=\"none\"))\n\nip1 &lt;- simdat  %&gt;% ggplot(aes(x,y=genGauss,group=condit,col=condit))+plotSpecs+ylab(\"\")\nip2 &lt;- simdat %&gt;%  ggplot(aes(x,y=genLinear,group=condit,col=condit))+plotSpecs+ylab(\"Amount of Generalization\")\n\nplot_grid(ip1,ip2,ncol=2,rel_heights=c(1))\n\n\n\n\n\n\n\n\nFigure 1: Left panel- Generalization predicted from a simple model that assumes a linear generalization function. A varied group (red vertical lines indicate the 2 training locations) trained from positions 400 and 800, and a constant group (blue vertical line), trained from position 600. Right panel- if a Gaussian generalization function is assumed, then varied training (400, 800) is predicted to result in better generalization to positions close to 400 and 800 than does constant training at 600. (For interpretation of the references to color in this figure legend, the reader is referred to the web version of this article.)\n\n\n\n\n\nIn addition to largely overlooking the potential for non-linear generalization to confound interpretations of training manipulations, the visuomotor skill learning literature also rarely considers alternatives to schema representations (Chamberlin & Magill, 1992b). Although schema-theory remains influential within certain literatures, instance or exemplar-based models have accounted for human behavior across myriad domains (Jamieson et al., 2022; Logan, 2002). As mentioned above, instance based accounts have been shown to perform well on a variety of different tasks with motoric components (Crump & Logan, 2010; Gandolfo et al., 1996; Meigh et al., 2018; Rosenbaum et al., 1995; van Dam & Ernst, 2015). However, such accounts have received little attention within the subdomain of visuomotor skill learning focused on the benefits of varied training.\nThe present work examines whether the commonly observed benefits of varied training can be accounted for by between-group differences in similarity between training and testing throws. We first attempt to replicate previous work finding an advantage of varied training over constant training in a projectile launching task. We then examine the extent to which this advantage can be explained by an instance-based similarity model.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#methods",
    "href": "Sections/IGAS.html#methods",
    "title": "IGAS Project",
    "section": "Methods",
    "text": "Methods\n\nSample Size Estimation\nTo obtain an independent estimate of effect size, we identified previous investigations which included between-subjects contrasts of varied and constant conditions following training on an accuracy based projectile launching task (Chua et al., 2019; Goodwin et al., 1998; Kerr & Booth, 1978; Wulf, 1991). We then averaged effects across these studies, yielding a Cohens f =.43. The GPower 3.1 software package (Faul et al., 2009), 2009) was then used to determine that a power of 80% requires a sample size of at least 23 participants per condition. All experiments reported in the present manuscript exceed this minimum number of participants per condition.\n\n\nParticipants\nParticipants were recruited from an undergraduate population that is 63% female and consists almost entirely of individuals aged 18-22 years. A total of 110 Indiana University psychology students participated in Experiment 1. We subsequently excluded 34 participants poor performance at one of the dependent measures of the task (2.5-3 standard deviations worse than the median subject at the task) or for displaying a pattern of responses that was clearly indicative of a lack of engagement with the task (e.g. simply dropping the ball on each trial rather than throwing it at the target), or for reporting that they completed the experiment on a phone or tablet device, despite the instructions not to use one of these devices. A total of 74 participants were retained for the final analyses, 35 in the varied group and 39 in the constant group.\n\n\nTask\nThe experimental task was programmed in JavaScript, using packages from the Phaser physics engine (https://phaser.io) and the jsPsych library (de Leeuw, 2015). The stimuli, presented on a black background, consisted of a circular blue ball – controlled by the participant via the mouse or trackpad cursor; a rectangular green target; a red rectangular barrier located between the ball and the target; and an orange square within which the participant could control the ball before releasing it in a throw towards the target. Because the task was administered online, the absolute distance between stimuli could vary depending on the size of the computer monitor being used, but the relative distance between the stimuli was held constant. Likewise, the distance between the center of the target, and the training and testing locations was scaled such that relative distances were preserved regardless of screen size. For the sake of brevity, subsequent mentions of this relative distance between stimuli, or the position where the ball landed in relation to the center of the target, will be referred to simply as distance. Figure 2 displays the layout of the task, as it would appear to a participant at the start of a trial, with the ball appearing in the center of the orange square. Using a mouse or trackpad, participants click down on the ball to take control of the ball, connecting the movement of the ball to the movement of the cursor. Participants can then “wind up” the ball by dragging it (within the confines of the orange square) and then launch the ball by releasing the cursor. If the ball does not land on the target, participants are presented with feedback in red text at the top right of the screen, on how many units away they were from the center of the target. If the ball was thrown outside of the boundary of the screen participants are given feedback as to how far away from the target center the ball would have been if it had continued its trajectory. If the ball strikes the barrier (from the side or by landing on top), feedback is presented telling participants to avoid hitting the barrier. If participants drag the ball outside of the orange square before releasing it, the trial terminates, and they are reminded to release the ball within the orange square. If the ball lands on the target, feedback is presented in green text, confirming that the target was hit, and presenting additional feedback on how many units away the ball was from the exact center of the target.\nLink to abbrevaited example of task.\n\n\nCode\nmf &lt;- cowplot::ggdraw()+cowplot::draw_image(here::here(\"Assets/methodsFig1.png\"),hjust=0)+theme(plot.margin = margin(0, 0, 0, 0))\nplot_grid(mf,ncol=1)\n\n\n\n\n\n\n\n\nFigure 2: The stimuli of the task consisted of a blue ball, which the participants would launch at the green target, while avoiding the red barrier. On each trial, the ball would appear in the center of the orange square, with the position of the orange square varying between experimental conditions. Participants were constrained to release the ball within the square",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#results",
    "href": "Sections/IGAS.html#results",
    "title": "IGAS Project",
    "section": "Results",
    "text": "Results",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#data-processing-and-statistical-packages",
    "href": "Sections/IGAS.html#data-processing-and-statistical-packages",
    "title": "IGAS Project",
    "section": "Data Processing and Statistical Packages",
    "text": "Data Processing and Statistical Packages\nTo prepare the data, we first removed trials that were not easily interpretable as performance indicators in our task. Removed trials included: 1) those in which participants dragged the ball outside of the orange starting box without releasing it, 2) trials in which participants clicked on the ball, and then immediately released it, causing the ball to drop straight down, 3) outlier trials in which the ball was thrown more than 2.5 standard deviations further than the average throw (calculated separately for each throwing position), and 4) trials in which the ball struck the barrier. The primary measure of performance used in all analyses was the absolute distance away from the center of the target. The absolute distance was calculated on every trial, and then averaged within each subject to yield a single performance score, for each position. A consistent pattern across training and testing phases in both experiments was for participants to perform worse from throwing positions further away from the target – a pattern which we refer to as the difficulty of the positions. However, there were no interactions between throwing position and training conditions, allowing us to collapse across positions in cases where contrasts for specific positions were not of interest. All data processing and statistical analyses were performed in R version 4.03 (R Core Team, 2020). ANOVAs for group comparisons were performed using the rstatix package (Kassambara, 2021)****.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#training-phase",
    "href": "Sections/IGAS.html#training-phase",
    "title": "IGAS Project",
    "section": "Training Phase",
    "text": "Training Phase\nFigure 3 below shows aggregate training performance binned into three stages representing the beginning, middle, and end of the training phase. Because the two conditions trained from target distances that were not equally difficult, it was not possible to directly compare performance between conditions in the training phase. Our focus for the training data analysis was instead to establish that participants did improve their performance over the course of training, and to examine whether there was any interaction between training stage and condition. Descriptive statistics for the intermittent testing phase are provided in the supplementary materials.\nWe performed an ANOVA comparison with stage as a within-group factor and condition as between-group factor. The analysis revealed a significant effect of training stage F(2,142)=62.4, p&lt;.001, \\(\\eta^{2}_G\\) = .17, such that performance improved over the course of training There was no significant effect of condition F(1,71)=1.42, p=.24, \\(\\eta^{2}_G\\) = .02, and no significant interaction between condition and training stage, F(2,142)=.10, p=.91, \\(\\eta^{2}_G\\) &lt; .01.\n\n\nCode\nexp1TrainPosition &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1) %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group,conditType,trainHalf,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1TrainPosition3 &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1) %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group,conditType,stage,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1Train &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1)  %&gt;%\n  group_by(sbjCode,Group,conditType,trainHalf) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1Train3 &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1)  %&gt;%\n  group_by(sbjCode,Group,conditType,stage) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\n\ne1train2 &lt;- exp1TrainPosition3 %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",fun=mean,position=dodge)+\n  facet_wrap(~conditType,ncol=2)+\n  stat_summary(aes(x=positionX,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+\n  ylab(\"Mean Distance From Center Of Target\")+\n  xlab(\"Training Location(s)\")+theme(plot.title = element_text(hjust = 0.5))+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)\n\n\n#plot_grid(title,e1train2,capt,ncol=1,rel_heights=c(.18,1,.15))\nplot_grid(e1train2,ncol=1)\n\n\n\n\n\n\n\n\nFigure 3: Training performance for varied and constant participants binned into three stages. Shorter bars indicate better performance (ball landing closer to the center of the target). Error bars indicate standard error of the mean.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#testing-phase",
    "href": "Sections/IGAS.html#testing-phase",
    "title": "IGAS Project",
    "section": "Testing Phase",
    "text": "Testing Phase\nIn Experiment 1, a single constant-trained group was compared against a single varied-trained group. At the transfer phase, all participants were tested from 3 positions: 1) the positions(s) from their own training, 2) the training position(s) of the other group, and 3) a position novel to both groups. Overall, group performance was compared with a mixed type III ANOVA, with condition (varied vs. constant) as a between-subject factor and throwing location as a within-subject variable. The effect of throwing position was strong, F(3,213) = 56.12, p&lt;.001, η2G = .23. The effect of training condition was significant F(1,71)=8.19, p&lt;.01, η2G = .07. There was no significant interaction between group and position, F(3,213)=1.81, p=.15, η2G = .01.\n\n\nCode\nexp1.Test &lt;- e1 %&gt;% filter(stage==\"Transfer\") %&gt;% select(-trainHalf)%&gt;% group_by(positionX) %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% \n  mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%\n  ungroup() %&gt;% group_by(sbjCode,conditType,positionX,ThrowPosition) %&gt;%\nsummarise(MeanTargetDeviance = mean(AbsDistFromCenter),MeanScaleDev = mean(scaledDev),.groups=\"keep\")%&gt;% as.data.frame()\n\n#manuscript plot\ne1test1=exp1.Test %&gt;% ggplot(aes(x=positionX,y=MeanTargetDeviance,group=conditType,fill=conditType))+\n  geom_bar(stat=\"summary\",fun=mean,position=dodge)+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+theme(plot.title = element_text(hjust = 0.5))+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)+scale_x_discrete(name=\"Testing Location\",labels=e1Labels)\n\ne1test1\n\n\n\n\n\n\n\n\nFigure 4: Testing performance for each of the 4 testing positions, compared between training conditions. Positions 610 and 910 were trained on by the varied group, and novel for the constant group. Position 760 was trained on by the constant group, and novel for the varied group. Position 835 was novel for both groups. Shorter bars are indicative of better performance (the ball landing closer to the center of the target). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\nCode\nexp1.Test &lt;- e1 %&gt;% filter(stage==\"Transfer\") %&gt;% select(-trainHalf)%&gt;% group_by(positionX) %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% \n  mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%\n  ungroup() %&gt;% group_by(sbjCode,conditType,positionX,ThrowPosition) %&gt;%\nsummarise(MeanTargetDeviance = mean(AbsDistFromCenter),MeanScaleDev = mean(scaledDev),.groups=\"keep\")%&gt;% as.data.frame()\n\n\ntest= exp1.Test %&gt;% dplyr::rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n   summarise(Mean=round(mean(MeanTargetDeviance),2),sd=round(sd(MeanTargetDeviance),2),.groups=\"keep\")\n test=test %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n test = test %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n test=test[,1:3]\n\nkable(test,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") %&gt;%   \n  kable_classic() #%&gt;% kableExtra::footnote(general=captionText,general_title = \"\")\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n610\n132.48(50.85)\n104.2(38.92)\n\n\n760\n207.26(89.19)\n167.12(72.29)\n\n\n835\n249.13(105.92)\n197.22(109.71)\n\n\n910\n289.36(122.48)\n212.86(113.93)",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#discussion",
    "href": "Sections/IGAS.html#discussion",
    "title": "IGAS Project",
    "section": "Discussion",
    "text": "Discussion\nIn Experiment 1, we found that varied training resulted in superior testing performance than constant training, from both a position novel to both groups, and from the position at which the constant group was trained, which was novel to the varied condition. The superiority of varied training over constant training even at the constant training position is of particular note, given that testing at this position should have been highly similar for participants in the constant condition. It should also be noted, though, that testing at the constant trained position is not exactly identical to training from that position, given that the context of testing is different in several ways from that of training, such as the testing trials from the different positions being intermixed, as well as a simple change in context as a function of time. Such contextual differences will be further considered in the General Discussion.\nIn addition to the variation of throwing position during training, the participants in the varied condition of Experiment 1 also received training practice from the closest/easiest position, as well as from the furthest/most difficult position that would later be encountered by all participants during testing. The varied condition also had the potential advantage of interpolating both of the novel positions from which they would later be tested. Experiment 2 thus sought to address these issues by comparing a varied condition to multiple constant conditions.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#methods-1",
    "href": "Sections/IGAS.html#methods-1",
    "title": "IGAS Project",
    "section": "Methods",
    "text": "Methods\n\nParticipants\nA total of 306 Indiana University psychology students participated in Experiment 2, which was also conducted online. As was the case in experiment 1, the undergraduate population from which we recruited participants was 63% female and primarily composed of 18–22-year-old individuals. Using the same procedure as experiment 1, we excluded 98 participants for exceptionally poor performance at one of the dependent measures of the task, or for displaying a pattern of responses indicative of a lack of engagement with the task. A total of 208 participants were included in the final analyses with 31 in the varied group and 32, 28, 37, 25, 29, 26 participants in the constant groups training from location 400, 500, 625, 675, 800, and 900, respectively. All participants were compensated with course credit.\n\n\nTask and Procedure\nThe task of Experiment 2 was identical to that of Experiment 1, in all but some minor adjustments to the height of the barrier, and the relative distance between the barrier and the target. Additionally, the intermittent testing trials featured in experiment 1 were not utilized in experiment 2, and all training and testing trials were presented with feedback. An abbreviated demo of the task used for Experiment 2 can be found at (https://pcl.sitehost.iu.edu/tg/demos/igas_expt2_demo.html).\nThe procedure for Experiment 2 was also quite similar to experiment 1. Participants completed 140 training trials, all of which were from the same position for the constant groups and split evenly (70 trials each - randomized) for the varied group. In the testing phase, participants completed 30 trials from each of the six locations that had been used separately across each of the constant groups during training. Each of the constant groups thus experience one trained location and five novel throwing locations in the testing phase, while the varied group experiences 2 previously trained, and 4 novel locations.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#results-1",
    "href": "Sections/IGAS.html#results-1",
    "title": "IGAS Project",
    "section": "Results",
    "text": "Results\n\nData Processing and Statistical Packages\nAfter confirming that condition and throwing position did not have any significant interactions, we standardized performance within each position, and then average across position to yield a single performance measure per participant. This standardization did not influence our pattern of results. As in experiment 1, we performed type III ANOVA’s due to our unbalanced design, however the pattern of results presented below is not altered if type 1 or type III tests are used instead. The statistical software for the primary analyses was the same as for experiment 1. Individual learning rates in the testing phase, compared between groups in the supplementary analyses, were fit using the TEfit package in R (Cochrane, 2020).\n\n\nTraining Phase\nThe different training conditions trained from positions that were not equivalently difficult and are thus not easily amenable to comparison. As previously stated, the primary interest of the training data is confirmation that some learning did occur. Figure 5 depicts the training performance of the varied group alongside that of the aggregate of the six constant groups (5a), and each of the 6 separate constant groups (5b). An ANOVA comparison with training stage (beginning, middle, end) as a within-group factor and group (the varied condition vs. the 6 constant conditions collapsed together) as a between-subject factor revealed no significant effect of group on training performance, F(1,206)=.55,p=.49, \\(\\eta^{2}_G\\) &lt;.01, a significant effect of training stage F(2,412)=77.91, p&lt;.001, \\(\\eta^{2}_G\\) =.05, and no significant interaction between group and training stage, F(2,412)=.489 p=.61, \\(\\eta^{2}_G\\) &lt;.01. We also tested for a difference in training performance between the varied group and the two constant groups that trained matching throwing positions (i.e., the constant groups training from position 500, and position 800). The results of our ANOVA on this limited dataset mirrors that of the full-group analysis, with no significant effect of group F(1,86)=.48, p=.49, \\(\\eta^{2}_G\\) &lt;.01, a significant effect of training stage F(2,172)=56.29, p&lt;.001, \\(\\eta^{2}_G\\) =.11, and no significant interaction between group and training stage, F(2,172)=.341 p=.71, \\(\\eta^{2}_G\\) &lt;.01.\n\n\nCode\ne2$stage &lt;- factor(e2$stage, levels = c(\"Beginning\", \"Middle\", \"End\",\"Transfer\"),ordered = TRUE)\n\nexp2TrainPosition &lt;- e2  %&gt;% filter(stage!=\"Transfer\") %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group2,conditType,trainHalf,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter))%&gt;% as.data.frame()\n\nexp2TrainPosition3 &lt;- e2  %&gt;% filter(stage!=\"Transfer\") %&gt;%ungroup() %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup() %&gt;%\n  group_by(sbjCode,Group2,conditType,stage,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),MeanScaledDev=mean(scaledDev,trim=.05))%&gt;% as.data.frame()\n\nexp2Train &lt;- e2  %&gt;% filter(stage!=\"Transfer\")  %&gt;% \n  group_by(sbjCode,Group2,conditType,trainHalf) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter)) %&gt;% as.data.frame()\n\nexp2Train3 &lt;- e2  %&gt;% filter(stage!=\"Transfer\")  %&gt;% ungroup() %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup() %&gt;%\n  group_by(sbjCode,Group2,conditType,stage) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;% as.data.frame()\n\ntransfer &lt;- filter(e2, stage==\"Transfer\") %&gt;% droplevels() %&gt;% select(-trainHalf,-initialVelocityY,ThrowPosition2)%&gt;% ungroup()\ntransfer &lt;- transfer %&gt;% group_by(positionX) %&gt;% mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup()\n\ntransfer &lt;- transfer %&gt;% group_by(sbjCode,positionX) %&gt;% mutate(ind=1,testPosIndex=cumsum(ind),posN=max(testPosIndex)) %&gt;%\n  select(-ind) %&gt;% mutate(testHalf = case_when(testPosIndex&lt;15 ~\"1st Half\",testPosIndex&gt;=15 ~\"2nd Half\")) %&gt;% convert_as_factor(testHalf)\n\nvariedTest &lt;- transfer %&gt;% filter(condit==7) %&gt;% mutate(extrapolate=ifelse(positionX==\"900\" | positionX==\"400\",\"extrapolation\",\"interpolation\")) \nconstantTest &lt;- transfer %&gt;% filter(condit!=7) %&gt;% mutate(extrapolate=ifelse(distFromTrain==0,\"interpolation\",\"extrapolation\"))\n\ntransfer &lt;- rbind(variedTest,constantTest)\ntransfer&lt;- transfer %&gt;% mutate(novel=ifelse(distFromTrain3==0,\"trainedLocation\",\"novelLocation\"))%&gt;% convert_as_factor(novel,extrapolate)\n\ntransfer &lt;- transfer %&gt;% relocate(sbjCode,condit2,Group,conditType2,stage,trial,novel,extrapolate,positionX,AbsDistFromCenter,globalAvg,globalSd,scaledDev,distFromTrain3) %&gt;% ungroup()\n\n\n# novelAll &lt;- transfer %&gt;% filter(distFromTrain!=0, distFromTrain3!=0) %&gt;% select(-globalAvg,-globalSd,-scaledDev)%&gt;% droplevels() %&gt;% ungroup()\n# novelAll &lt;- novelAll %&gt;% group_by(positionX) %&gt;%\n#  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n#   group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup()\n\nnovelAll &lt;- transfer %&gt;% filter(distFromTrain!=0, distFromTrain3!=0)\nnovelAllMatched &lt;- novelAll %&gt;% filter(condit!=5,condit!=2)\n\n\nconstantIden &lt;- transfer %&gt;% filter(condit !=7,distFromTrain==0) # only constant groups from their training position\nvariedTest &lt;- transfer %&gt;% filter(condit==7) # only varied testing\nvariedVsIden &lt;- rbind(constantIden,variedTest) # all varied combined with constant identity\n\n\nvariedNovel &lt;- variedTest %&gt;% filter(distFromTrain3 !=0) # removes 500 and 800 from varied\nconstantIden2 &lt;- transfer %&gt;% filter(condit !=7,condit!=5,condit!=2,distFromTrain==0) # only constant groups from training position 400,625,675,900\nvariedVsNovelIden &lt;- rbind(constantIden2,variedNovel) # novel positions for varied, trained for constant\n\nexp2.Test &lt;- transfer %&gt;%group_by(sbjCode,conditType,positionX,ThrowPosition)%&gt;%\n  summarise(MeanTargetDeviance = mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;%ungroup() %&gt;% as.data.frame()\n\nexp2.Test2 &lt;- exp2.Test %&gt;% group_by(sbjCode,conditType)%&gt;%\n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;%ungroup() %&gt;% as.data.frame()\n\nexp2.Test7 &lt;- transfer %&gt;%group_by(Group2,sbjCode,positionX,Group,conditType,ThrowPosition4) %&gt;% \n  summarise(MeanTargetDeviance = mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;% as.data.frame()\n\nexp2.Test7.agg &lt;- exp2.Test7  %&gt;%group_by(Group2,sbjCode,Group,conditType) %&gt;% \n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;% as.data.frame()\n\nexp2.Test7.agg2 &lt;- exp2.Test7  %&gt;%group_by(sbjCode,conditType) %&gt;% \n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;% as.data.frame()\n\n\n\n\nCode\n### New - 3 stage\ne2train1&lt;-exp2TrainPosition3 %&gt;% ggplot(aes(x=stage,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",position=dodge,fun=\"mean\")+\n  stat_summary(aes(x=stage,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+facet_wrap(~conditType,ncol=2)+\n  ylab(\"Mean Distance From Center Of Target\") +xlab(\"Training Stage\")+\n  theme(plot.title = element_text(face=\"bold\",hjust = 0.0,size=9),\n        plot.title.position = \"plot\")+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)+ggtitle(\"A\")\n\ne2train2&lt;-exp2TrainPosition3 %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",position=dodge,fun=\"mean\")+\n  facet_wrap(~conditType,ncol=2)+stat_summary(aes(x=positionX,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Training Location(s)\")+\n  theme(plot.title = element_text(face=\"bold\",hjust = 0,size=9),\n        plot.title.position = \"plot\")+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)+ggtitle(\"B\")\n\n#plot_grid(e2train1,e2train2,ncol=1)\n\ne2train1/e2train2\n\n\n\n\n\n\n\n\nFigure 5: Training performance for the six constant conditions, and the varied condition, binned into three stages. On the left side, the six constant groups are averaged together, as are the two training positions for the varied group. On the right side, the six constant groups are shown separately, with each set of bars representing the beginning, middle, and end of training for a single constant group that trained from the position indicated on the x-axis. Figure 5b also shows training performance separately for both of the throwing locations trained by the varied group. Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\nTesting Phase\nIn Experiment 2, a single varied condition (trained from two positions, 500 and 800), was compared against six separate constant groups (trained from a single position, 400, 500, 625, 675, 800 or 900). For the testing phase, all participants were tested from all six positions, four of which were novel for the varied condition, and five of which were novel for each of the constant groups. For a general comparison, we took the absolute deviations for each throwing position and computed standardized scores across all participants, and then averaged across throwing position. The six constant groups were then collapsed together allowing us to make a simple comparison between training conditions (constant vs. varied). A type III between-subjects ANOVA was performed, yielding a significant effect of condition F(1,206)=4.33, p=.039, \\(\\eta^{2}_G\\) =.02. Descriptive statistics for each condition are shown in table 2. In Figure 6 visualizes the consistent advantage of the varied condition over the constant groups across the testing positions. Figure 6 shows performance between the varied condition and the individual constant groups.\n\n\nCode\n# manuscript plot\ne2test1&lt;-exp2.Test %&gt;% ggplot(aes(x=ThrowPosition,y=MeanTargetDeviance,group=conditType,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+guides(fill=guide_legend(title=\"Training Condition\"))+\n  theme(plot.title=element_text(face=\"bold\",size=9),\n        plot.title.position = \"plot\",\n        legend.title.align=.25)+\n  ggtitle(\"A\")\n\n\ne2test2&lt;-exp2.Test7 %&gt;% \n  ggplot(aes(x=Group,y=MeanTargetDeviance,group=conditType,fill=conditType))+\n  geom_bar(stat=\"summary\",position=position_dodge(),fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=position_dodge())+\n  facet_wrap(~ThrowPosition4)+\n  ylab(\"Mean Distance From Center Of Target\")+\n  guides(fill=guide_legend(title=\"Training Condition\"))+\n  theme(plot.title=element_text(face=\"bold\",size=9),\n        plot.title.position = \"plot\",\n        legend.title.align=.25,\n        axis.text.x = element_text(size = 7,angle=45,hjust=1))+\n  scale_x_discrete(name=\" Training Group\",labels=e2Labels)+ggtitle(\"B\")\n\ne2test1 / e2test2\n\n\n\n\n\n\n\n\nFigure 6: Testing phase performance from each of the six testing positions. The six constant conditions are averaged together into a single constant group, compared against the single varied-trained group.B) Transfer performance from each of the 6 throwing locations from which all participants were tested. Each bar represents performance from one of seven distinct training groups (six constant groups in red, one varied group in blue). The x axis labels indicate the location(s) from which each group trained. Lower values along the y axis reflect better performance at the task (closer distance to target center). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\n\nCode\ntab2= exp2.Test %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n   summarise(Mean=round(mean(MeanTargetDeviance),2),sd=round(sd(MeanTargetDeviance),2),.groups=\"keep\")\n tab2=tab2 %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n tab2 = tab2 %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% \n   select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab2=tab2[,1:3]\n\n\nkable(tab2,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") %&gt;% \n  kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 1: Transfer performance from each of the 6 throwing locations from which all participants were tested. Each bar represents performance from one of seven distinct training groups (six constant groups in red, one varied group in blue). The x axis labels indicate the location(s) from which each group trained. Lower values along the y axis reflect better performance at the task (closer distance to target center). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n100.59(46.3)\n83.92(33.76)\n\n\n500\n152.28(69.82)\n134.38(61.38)\n\n\n625\n211.21(90.95)\n183.51(75.92)\n\n\n675\n233.32(93.35)\n206.32(94.64)\n\n\n800\n283.24(102.85)\n242.65(89.73)\n\n\n900\n343.51(114.33)\n289.62(110.07)\n\n\n\n\n\n\n\n\n\n\n\nNext, we compared the testing performance of constant and varied groups from only positions that participants had not encountered during training. Constant participants each had 5 novel positions, whereas varied participants tested from 4 novel positions (400,625,675,900). We first standardized performance within in each position, and then averaged across positions. Here again, we found a significant effect of condition (constant vs. varied): F(1,206)=4.30, p=.039, \\(\\eta^{2}_G\\) = .02 .\n\n\nCode\nsum.novelAll &lt;- novelAll %&gt;% group_by(sbjCode,conditType,positionX) %&gt;% \n  summarise(MeanTargetDev=mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05),.groups=\"keep\") %&gt;% as.data.frame()\n\ntab3=sum.novelAll %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n  summarise(Mean=round(mean(MeanTargetDev),2),sd=round(sd(MeanTargetDev),2),.groups=\"keep\")\n\n tab3=tab3 %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n \n tab3 = tab3 %&gt;% \n   mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab3=tab3[,1:3]\n\n\n\nkable(tab3,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") %&gt;% \n  kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 2: Testing performance from novel positions. Includes data only from positions that were not encountered during the training stage (e.g. excludes positions 500 and 800 for the varied group, and one of the six locations for each of the constant groups). Table presents Mean absolute deviations from the center of the target, and standard deviations in parenthesis.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n98.84(45.31)\n83.92(33.76)\n\n\n500\n152.12(69.94)\nNA\n\n\n625\n212.91(92.76)\n183.51(75.92)\n\n\n675\n232.9(95.53)\n206.32(94.64)\n\n\n800\n285.91(102.81)\nNA\n\n\n900\n346.96(111.35)\n289.62(110.07)\n\n\n\n\n\n\n\n\n\n\n\nFinally, corresponding to the comparison of position 760 from experiment 1, we compared the test performance of the varied group against the constant group from only the positions that the constant groups trained. Such positions were novel to the varied group (thus this analysis omitted two constant groups that trained from positions 500 or 800 as those positions were not novel to the varied group). Figure 7 displays the particular subset of comparisons utilized for this analysis. Again, we standardized performance within each position before performing the analyses on the aggregated data. In this case, the effect of condition did not reach statistical significance F(1,149)=3.14, p=.079, \\(\\eta^{2}_G\\) = .02. Table 4 provides descriptive statistics.\n\n\nCode\nsum.variedVsNovelIden &lt;- variedVsNovelIden  %&gt;%\n  group_by(sbjCode,conditType,positionX) %&gt;% \n  summarise(MeanTargetDev=mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05),.groups=\"keep\") %&gt;% as.data.frame()\n\ne2Test2 &lt;- sum.variedVsNovelIden %&gt;% ggplot(aes(x=positionX,y=MeanTargetDev,group=conditType,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+theme(plot.title = element_text(hjust = 0.5))+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)\n\n\ne2Test2\n\n\n\n\n\n\n\n\nFigure 7: A comparison of throwing location that are identical to those trained by the constant participants (e.g. constant participants trained at position 900, tested from position 900), which are also novel to the varied-trained participants (thus excluding positions 500 and 800). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\nCode\ntab4=sum.variedVsNovelIden %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n  summarise(Mean=round(mean(MeanTargetDev),2),sd=round(sd(MeanTargetDev),2),.groups=\"keep\")\n\ntab4=tab4 %&gt;% group_by(Condition) %&gt;% \n   mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n \ntab4 = tab4 %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab4=tab4[,1:3]\n\nkable(tab4,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") %&gt;% \n  kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 3: Testing performance from the locations trained by constant participants and novel to varied participants. Locations 500 and 800 are not included as these were trained by the varied participants. Table presents Mean absolute deviation from the center of the target, and standard deviations in parenthesis.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n108.85(50.63)\n83.92(33.76)\n\n\n625\n204.75(84.66)\n183.51(75.92)\n\n\n675\n235.75(81.15)\n206.32(94.64)\n\n\n900\n323.5(130.9)\n289.62(110.07)",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#discussion-1",
    "href": "Sections/IGAS.html#discussion-1",
    "title": "IGAS Project",
    "section": "Discussion",
    "text": "Discussion\nThe results of experiment 2 largely conform to the findings of experiment 1. Participants in both varied and constant conditions improved at the task during the training phase. We did not observe the common finding of training under varied conditions producing worse performance during acquisition than training under constant conditions (Catalano & Kleiner, 1984; Wrisberg et al., 1987), which has been suggested to relate to the subsequent benefits of varied training in retention and generalization testing (Soderstrom & Bjork, 2015). However our finding of no difference in training performance between constant and varied groups has been observed in previous work (Chua et al., 2019; Moxley, 1979; Pigott & Shapiro, 1984).\nIn the testing phase, our varied group significantly outperformed the constant conditions in both a general comparison, and in an analysis limited to novel throwing positions. The observed benefit of varied over constant training echoes the findings of many previous visuomotor skill learning studies that have continued to emerge since the introduction of Schmidt’s influential Schema Theory (Catalano & Kleiner, 1984; Chua et al., 2019; Goodwin et al., 1998; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976; Pigott & Shapiro, 1984; Roller et al., 2001; Schmidt, 1975; Willey & Liu, 2018b; Wrisberg et al., 1987; Wulf, 1991). We also join a much smaller set of research to observe this pattern in a computerized task (Seow et al., 2019). One departure from the experiment 1 findings concerns the pattern wherein the varied group outperformed the constant group even from the training position of the constant group, which was significant in experiment 1, but did not reach significance in experiment 2. Although this pattern has been observed elsewhere in the literature (Goode et al., 2008; Kerr & Booth, 1978), the overall evidence for this effect appears to be far weaker than for the more general benefit of varied training in conditions novel to all training groups.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#fitting-model-parameters-separately-by-group",
    "href": "Sections/IGAS.html#fitting-model-parameters-separately-by-group",
    "title": "IGAS Project",
    "section": "Fitting model parameters separately by group",
    "text": "Fitting model parameters separately by group\nTo directly control for similarity in Experiment 2, we developed a model-based measure of the similarity between training throws and testing conditions. This similarity measure was a significant predictor of testing performance, e.g., participants whose training throws were more similar to throws that resulted in target hits from the testing positions, tended to perform better during the testing phase. Importantly, the similarity measure did not explain away the group-level benefits of varied training, which remained significant in our linear model predicting testing performance after similarity was added to the model. However, previous research has suggested that participants may differ in their level of generalization as a function of prior experience, and that such differences in generalization gradients can be captured by fitting the generalization parameter of an instance-based model separately to each group (Hahn et al., 2005; Lamberts, 1994). Relatedly, the influential Bayesian generalization model developed by Tenenbaum & Griffiths (2001) predicts that the breadth of generalization will increase when a rational agent encounters a wider variety of examples. Following these leads, we assume that in addition to learning the task itself, participants are also adjusting how generalizable their experience should be. Varied versus constant participants may be expected to learn to generalize their experience to different degrees. To accommodate this difference, the generalization parameter of the instance-based model (in the present case, the c parameter) can be allowed to vary between the two groups to reflect the tendency of learners to adaptively tune the extent of their generalization. One specific hypothesis is that people adaptively set a value of c to fit the variability of their training experience (Nosofsky & Johansen, 2000; Sakamoto et al., 2006). If one’s training experience is relatively variable, as with the variable training condition, then one might infer that future test situations will also be variable, in which case a low value of c will allow better generalization because generalization will drop off slowly with training-to-testing distance. Conversely, if one’s training experience has little variability, as found in the constant training conditions, then one might adopt a high value of c so that generalization falls off rapidly away from the trained positions.\nTo address this possibility, we compared the original instance-based model of similarity fit against a modified model which separately fits the generalization parameter, c, to varied and constant participants. To perform this parameter fitting, we used the optim function in R, and fit the model to find the c value(s) that maximized the correlation between similarity and testing performance.\nBoth models generate distinct similarity values between training and testing locations. Much like the analyses in Experiment 2, these similarity values are regressed against testing performance in models of the form shown below. As was the case previously, testing performance is defined as the mean absolute distance from the center of the target (with a separate score for each participant, from each position).\nLinear models 1 and 3 both show that similarity is a significant predictor of testing performance (p&lt;.01). Of greater interest is the difference between linear model 2, in which similarity is computed from a single c value fit from all participants (Similarity1c), with linear model 4, which fits the c parameter separately between groups (Similarity2c). In linear model 2, the effect of training group remains significant when controlling for Similarity1c (p&lt;.01), with the varied group still performing significantly better. However, in linear model 4 the addition of the Similarity2c predictor results in the effect of training group becoming nonsignificant (p=.40), suggesting that the effect of varied vs. constant training is accounted for by the Similarity2c predictor. Next, to further establish a difference between the models, we performed nested model comparisons using ANOVA, to see if the addition of the training group parameter led to a significant improvement in model performance. In the first comparison, ANOVA(Linear Model 1, Linear Model 2), the addition of the training group predictor significantly improved the performance of the model (F=22.07, p&lt;.01). However, in the second model comparison, ANOVA (Linear model 3, Linear Model 4) found no improvement in model performance with the addition of the training group predictor (F=1.61, p=.20).\nFinally, we sought to confirm that similarity values generated from the adjusted Similarity2c model had more predictive power than those generated from the original Similarity1c model. Using the BIC function in R, we compared BIC values between linear model 1 (BIC=14604.00) and linear model 3 (BIC = 14587.64). The lower BIC value of model 3 suggests a modest advantage for predicting performance using a similarity measure computed with two c values over similarity computed with a single c value. When fit with separate c values, the best fitting c parameters for the model consistently optimized such that the c value for the varied group (c=.00008) was smaller in magnitude than the c value for the constant group(c= .00011). Recall that similarity decreases as a Gaussian function of distance (equation 1 above), and a smaller value of c will result in a more gradual drop-off in similarity as the distance between training throws and testing solutions increases.\nIn summary, our modeling suggests that an instance-based model which assumes equivalent generalization gradients between constant and varied trained participants is unable to account for the extent of benefits of varied over constant training observed at testing. The evidence for this in the comparative model fits is that when a varied/constant dummy-coded variable for condition is explicitly added to the model, the variable adds a significant contribution to the prediction of test performance, with the variable condition yielding better performance than the constant conditions. However, if the instance-based generalization model is modified to assume that the training groups can differ in the steepness of their generalization gradient, by incorporating a separate generalization parameter for each group, then the instance-based model can account for our experimental results without explicitly taking training group into account. Henceforth this model will be referred to as the Instance-based Generalization with Adaptive Similarity (IGAS) model.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#limitations",
    "href": "Sections/IGAS.html#limitations",
    "title": "IGAS Project",
    "section": "Limitations",
    "text": "Limitations\nA limitation of this study concerns the ordering of the testing/transfer trials at the conclusion of both experiments. Participants were tested from each separate position (4 in Experiment 1, 6 in Experiment 2) in a random, intermixed order. Because the varied group was trained from two positions that were also randomly ordered, they may have benefited from experience with this type of sequencing, whereas the constant groups had no experience with switching between positions trial to trial. This concern is somewhat ameliorated by the fact that the testing phase performance of the constant groups from their trained position was not significantly worse than their level of performance at the end of the training phase, suggesting that they were not harmed by random ordering of positions during testing. It should also be noted that the computerized task utilized in the present work is relatively simple compared to many of the real-world tasks utilized in prior research. It is thus conceivable that the effect of variability in more complex tasks is distinct from the process put forward in the present work. An important challenge for future work will be to assess the extent to which IGAS can account for generalization in relatively complex tasks with far more degrees of freedom.\nIt is common for psychological process models of categorization learning to use an approach such as multidimensional scaling so as to transform the stimuli from the physical dimensions used in the particular task into the psychological dimensions more reflective of the actual human representations (Nosofsky, 1992; Shepard, 1987). Such scaling typically entails having participants rate the similarity between individual items and using these similarity judgements to then compute the psychological distances between stimuli, which can then be fed into a subsequent model. In the present investigation, there was no such way to scale the x and y velocity components in terms of the psychological similarity, and thus our modelling does rely on the assumption that the psychological distances between the different throwing positions are proportional to absolute distances in the metric space of the task (e.g. the relative distance between positions 400 and 500 is equivalent to that between 800 and 900). However, an advantage of our approach is that we are measuring similarity in terms of how participants behave (applying a velocity to the ball), rather than the metric features of the task stimuli.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/IGAS.html#conclusion",
    "href": "Sections/IGAS.html#conclusion",
    "title": "IGAS Project",
    "section": "Conclusion",
    "text": "Conclusion\nOur experiments demonstrate a reliable benefit of varied training in a simple projectile launching task. Such results were accounted for by an instance-based model that assumes that varied training results in the computation of a broader similarity-based generalization gradient. Instance-based models augmented with this assumption may be a valuable approach towards better understanding skill generalization and transfer.",
    "crumbs": [
      "IGAS Project"
    ]
  },
  {
    "objectID": "Sections/htw_exam.html",
    "href": "Sections/htw_exam.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All CodeView Source\nCode\n# load and view data\npacman::p_load(tidyverse,patchwork,here, pander, latex2exp, flextable)\npurrr::walk(here::here(c(\"Functions/Display_Functions.R\", \"Functions/alm_core.R\",\"Functions/misc_model_funs.R\")),source)\n\npurrr::walk(here::here(c(\"Functions/Display_Functions.R\")),source)\n\nselect &lt;- dplyr::select; mutate &lt;- dplyr::mutate \n\nds &lt;- readRDS(here::here(\"data/e1_md_11-06-23.rds\"))\ndsAvg &lt;- ds |&gt; group_by(condit,expMode2,tr, x) |&gt; \n  summarise(y=mean(y),.groups=\"keep\") \n\nvAvg &lt;- dsAvg |&gt; filter(condit==\"Varied\")\ncAvg &lt;- dsAvg |&gt; filter(condit==\"Constant\")\n\n#i1 &lt;- ds |&gt; filter(id==\"3\")\n\ninput.layer &lt;- c(100,350,600,800,1000,1200)\noutput.layer &lt;- c(100,350,600,800,1000,1200)\n\n\npurrr::walk(c(\"con_group_exam_fits\", \"var_group_exam_fits\", \"hybrid_group_exam_fits\"), \n            ~ list2env(readRDS(here::here(paste0(\"data/model_cache/\", .x, \".rds\"))), \n            envir = .GlobalEnv))\n\n# pluck(ex_te_v, \"Fit\") |&gt; mutate(w= ifelse(exists(\"w\"), round(w,2),NA))\n# pluck(hybrid_te_v, \"Fit\") |&gt; mutate(w= ifelse(exists(\"w\"), round(w,2), NA))\nCode\n alm_plot()\n\n\n\n\n\n\n\n\nFigure 1: The basic structure of the ALM model."
  },
  {
    "objectID": "Sections/htw_exam.html#alm-exam-description",
    "href": "Sections/htw_exam.html#alm-exam-description",
    "title": "",
    "section": "ALM & Exam Description",
    "text": "ALM & Exam Description\nDeLosh et al. (1997) introduced the associative learning model (ALM), a connectionist model within the popular class of radial-basis networks. ALM was inspired by, and closely resembles Kruschke’s influential ALCOVE model of categorization (Kruschke, 1992).\nALM is a localist neural network model, with each input node corresponding to a particular stimulus, and each output node corresponding to a particular response value. The units in the input layer activate as a function of their Gaussian similarity to the input stimulus. So, for example, an input stimulus of value 55 would induce maximal activation of the input unit tuned to 55. Depending on thevalue of the generalization parameter, the nearby units (e.g. 54 and 56; 53 and 57) may also activate to some degree. ALM is structured with input and output nodes that correspond to regions of the stimulus space, and response space, respectively. The units in the input layer activate as a function of their similarity to a presented stimulus. As was the case with the exemplar-based models, similarity in ALM is exponentially decaying function of distance. The input layer is fully connected to the output layer, and the activation for any particular output node is simply the weighted sum of the connection weights between that node and the input activations. The network then produces a response by taking the weighted average of the output units (recall that each output unit has a value corresponding to a particular response). During training, the network receives feedback which activates each output unit as a function of its distance from the ideal level of activation necessary to produce the correct response. The connection weights between input and output units are then updated via the standard delta learning rule, where the magnitude of weight changes are controlled by a learning rate parameter.\nSee Table 1 for a full specification of the equations that define ALM and EXAM."
  },
  {
    "objectID": "Sections/htw_exam.html#model-fitting-and-comparison",
    "href": "Sections/htw_exam.html#model-fitting-and-comparison",
    "title": "",
    "section": "Model Fitting and Comparison",
    "text": "Model Fitting and Comparison\nFollowing the procedure used by Mcdaniel et al. (2009), we will assess the ability of both ALM and EXAM to account for the empirical data when fitting the models to 1) only the training data, and 2) both training and testing data. Models were fit to the aggregated participant data by minimizing the root-mean squared deviation (RMSE). Because ALM has been shown to do poorly at accounting for human patterns extrapolation (DeLosh et al., 1997), we will also generate predictions from the EXAM model for the testing stage. EXAM which operates identically to ALM during training, but includes a linear extrapolation mechanism for generating novel responses during testing.\nFor the hybrid model, predictions are computed by first generating separate predictions from ALM and EXAM, and then combining them using the following equation: \\(\\hat{y} = (1 - w) \\cdot alm.pred + w \\cdot exam.pred\\). For the grid search, the weight parameter is varied from 0 to 1, and the resulting RMSE is recorded.\nEach model was fit to the data in 3 different ways. 1) To just the testing data, 2) Both the training and testing data, 3) Only the training data. In all cases, the model only updates its weights during the training phase, and the weights are frozen during the testing phase. In all cases, only the ALM model generates predictions during the training phase. For the testing phase, all 3 models are used to generate predictions.\n\n\n\nCode\n##| column: body-outset-right\n\n\nreshaped_df &lt;- all_combined_params %&gt;%\n  select(-Value,-Test_RMSE) |&gt;\n  rename(\"Fit Method\" = Fit_Method) |&gt;\n  pivot_longer(cols=c(c,lr,w),names_to=\"Parameter\") %&gt;%\n  unite(Group, Group, Parameter) %&gt;%\n  pivot_wider(names_from = Group, values_from = value)\n\nheader_df &lt;- data.frame(\n  col_keys = c(\"Model\", \"Fit Method\",\"Constant_c\", \"Constant_lr\", \"Constant_w\", \"Varied_c\", \"Varied_lr\", \"Varied_w\"),\n  line1 = c(\"\", \"\", \"Constant\", \"\", \"\", \"Varied\", \"\",\"\"),\n  line2 = c(\"Model\", \"Fit Method\", \"c\", \"lr\", \"w\", \"c\", \"lr\", \"w\")\n)\n\nft &lt;- flextable(reshaped_df) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% add_header_lines(values = \" \") %&gt;%\n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;% \n  hline(part = \"header\", i = 2, j=3:5) %&gt;% \n  hline(part = \"header\", i = 2, j=6:8)\n\nft\n\n\n\n\nTable 2: Fit Parameters and Model RMSE. The Test_RMSE column is the main performance indicator of interest, and represents the RMSE for just the testing data. The Fit_Method column indicates the data used to fit the model. The \\(w\\) parameter determines the balance between the ALM and EXAM response generation processes, and is only included for the hybrid model. A weight of .5 would indicate equal contribution from both models. \\(w\\) values approaching 1 indicate stronger weight for EXAM.\n\n\n\n ConstantVariedModelFit MethodclrwclrwALMTest Only0.0000.1000.1342.030ALMTest & Train0.0470.0800.0670.100ALMTrain Only0.0600.1000.0470.080EXAMTest Only0.0071.3270.4091.910EXAMTest & Train0.0810.1610.0740.100EXAMTrain Only0.0600.1000.0470.080HybridTest Only0.0081.58010.3952.0170.64HybridTest & Train0.0670.13410.1342.0170.79HybridTrain Only0.0420.06700.0420.0670.00\n\n\n\n\n\n\nTesting Observations vs. Predictions\n\n\nCode\ntvte&lt;- pluck(a_te_v, \"test\") |&gt; \n  mutate(Fit_Method=\"Test Only\") |&gt;\n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_te_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_v, \"test\") |&gt; pull(pred))\n\ntvtetr&lt;-pluck(a_tetr_v, \"test\") |&gt; \n  mutate(Fit_Method=\"Test & Train\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tetr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_v, \"test\") |&gt; pull(pred))\n\ntvtr&lt;- pluck(a_tr_v, \"test\")|&gt; \n  mutate(Fit_Method=\"Train Only\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_v, \"test\") |&gt; pull(pred))\n\ntcte&lt;- pluck(a_te_c, \"test\") |&gt; \n  mutate(Fit_Method=\"Test Only\") |&gt; \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_te_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_c, \"test\") |&gt; pull(pred))\n\ntctetr&lt;-pluck(a_tetr_c, \"test\") |&gt; \n  mutate(Fit_Method=\"Test & Train\") |&gt;  \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tetr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_c, \"test\") |&gt; pull(pred))\n\ntctr&lt;- pluck(a_tr_c, \"test\")|&gt; \n  mutate(Fit_Method=\"Train Only\") |&gt;  \n  rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_c, \"test\") |&gt; pull(pred))\n\nvPreds &lt;- rbind(tvte,tvtetr, tvtr) |&gt; relocate(Fit_Method,.before=x) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 0)))\n\ncPreds &lt;- rbind(tcte,tctetr, tctr) |&gt; relocate(Fit_Method,.before=x) |&gt; \n   mutate(across(where(is.numeric), \\(x) round(x, 0)))\n\nallPreds &lt;- rbind(vPreds |&gt; mutate(Group=\"Varied\"), cPreds |&gt; mutate(Group=\"Constant\")) |&gt;\n  pivot_longer(cols=c(\"ALM\",\"EXAM\",\"Hybrid\"), names_to=\"Model\",values_to = \"Prediction\") |&gt; \n  mutate(Error=Observed-Prediction, Abs_Error=((Error)^2)) |&gt; \n  group_by(Group,Fit_Method, Model) #|&gt; summarise(Mean_Error=mean(Error), Abs_Error=mean(Abs_Error))\n\n\n\n\nCode\nallPreds |&gt; summarise(Error=mean(Error), Abs_Error=sqrt(mean(Abs_Error))) |&gt; \n  mutate(Fit_Method=factor(Fit_Method, levels=c(\"Test Only\", \"Test & Train\", \"Train Only\"))) |&gt;\n  tabulator(rows=c(\"Fit_Method\", \"Model\"), columns=c(\"Group\"), \n             `ME` = as_paragraph(Error), \n            `RMSE` = as_paragraph(Abs_Error)) |&gt; as_flextable()\n\n\n\n\nTable 3: Model Perforamnce - averaged over all X values/Bands. ME=Mean Average Error, RMSE = Root mean squared error.\n\n\n\nFit_MethodModelConstantVariedMERMSEMERMSETest OnlyALM223.8348.056.395.4EXAM-59.2127.5-6.045.9Hybrid-58.2127.4-3.033.8Test & TrainALM193.2328.782.3106.6EXAM-28.8132.113.260.2Hybrid-16.7136.716.746.5Train OnlyALM194.5329.286.3109.1EXAM75.3199.917.565.4Hybrid197.5330.488.3110.3"
  },
  {
    "objectID": "Sections/htw_exam.html#varied-testing-predictions",
    "href": "Sections/htw_exam.html#varied-testing-predictions",
    "title": "",
    "section": "Varied Testing Predictions",
    "text": "Varied Testing Predictions\n\n\nCode\n##| column: screen-inset-right\n\n####\n\nvte &lt;-  pluck(a_te_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_te_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test Only\")\n\nvtetr &lt;-  pluck(a_tetr_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tetr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") + \n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test and Train\")\n\nvtr &lt;-  pluck(a_tr_v, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex_tr_v, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_v, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Train Only\")\n\n vte/vtetr/vtr\n\n\n\n\n\n\n\n\nFigure 2: Varied Group - Mean Model predictions vs. observations\n\n\n\n\n\n\n\nCode\n##| column: screen-inset-right\n\n\n# Create a custom header dataframe\nheader_df &lt;- data.frame(\n  col_keys = c(\"Fit_Method\", \"x\",\"Observed\" ,\"ALM_Predicted\", \"ALM_Residual\", \"EXAM_Predicted\",\"EXAM_Residual\", \"Hybrid_Predicted\",\"Hybrid_Residual\"),\n  line1 = c(\"\",\"\",\"\", \"ALM\", \"\", \"EXAM\", \"\", \"Hybrid\",\"\"),\n  line2 = c(\"Fit Method\", \"X\", \"Observed\", \"Predicted\",\"Residual\", \"Predicted\",\"Residual\", \"Predicted\",\"Residual\")\n)\n\n\nbest_vPreds &lt;- vPreds %&gt;%\n  pivot_longer(cols = c(ALM, EXAM, Hybrid), names_to = \"Model\", values_to = \"Predicted\") |&gt;\n  mutate(Residual=(Observed-Predicted), abs_res =abs(Residual)) |&gt; group_by(Fit_Method,x) |&gt;\n  mutate(best=if_else(abs_res==min(abs_res),1,0)) |&gt; select(-abs_res)\n\nlong_vPreds &lt;- best_vPreds |&gt; select(-best) |&gt;\n  pivot_longer(cols=c(Predicted,Residual), names_to=\"Model_Perf\") |&gt;\n  relocate(Model, .after=Fit_Method) |&gt; \n  unite(Model,Model,Model_Perf) |&gt;\n  pivot_wider(names_from=Model,values_from=value)\n\nbest_wide &lt;- best_vPreds |&gt; select(-Residual,-Predicted,-Observed) |&gt; ungroup() |&gt;\n  pivot_wider(names_from=Model,values_from=best) |&gt; select(ALM,EXAM,Hybrid)\n\nbest_indexV &lt;- row_indices &lt;- apply(best_wide, 1, function(row) {\n which(row == 1)\n})\n\n\napply_best_formatting &lt;- function(ft, best_index) {\n  for (i in 1:length(best_index)) {\n      #ft &lt;- ft %&gt;% surround(i=i,j=best_index[i],border=fp_border_default(color=\"red\",width=1))\n      ind = best_index[[i]]\n      ind &lt;- ind  %&gt;% map_dbl(~ .x*2+3)\n      ft &lt;- ft %&gt;% highlight(i=i,j=ind,color=\"wheat\")\n      }\n  return(ft)\n}\n\nft &lt;- flextable(long_vPreds) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% \n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;%\n  hline(part = \"header\", i = 1, j=4:9) %&gt;%\n  vline(j=c(\"Observed\",\"ALM_Residual\",\"EXAM_Residual\")) %&gt;%\n  hline(part = \"body\", i=c(6,12)) |&gt; \n  bold(i=long_vPreds$x %in% c(100,350,600), j=2) \n\n  # bold the cell with the lowest residual, based on best_wide df\n  # for each row, the cell that should be bolded matches which column in best_wide==1 at that row\nft &lt;- apply_best_formatting(ft, best_indexV)\nft\n\n\n\n\nTable 4: Varied group - mean model predictions vs. observations. Extrapolation Bands are bolded. For each Modelling fitting and band combination, the model with the smallest residual is highlighted. Only the lower bound of each velocity band is shown (bands are all 200 units).\n\n\n\nALMEXAMHybridFit MethodXObservedPredictedResidualPredictedResidualPredictedResidualTest Only100663675-12716-53708-45Test Only35076467589817-53792-28Test Only600884675209895-118759Test Only8001,0831,07851,000831,091-8Test Only1,0001,1961,202-61,199-31,204-8Test Only1,2001,2831,230531,28211,22162Test & Train100663675-12716-53707-44Test & Train35076467589817-53788-24Test & Train600884675209902-1885133Test & Train8001,0831,000831,000831,00479Test & Train1,0001,1961,163331,165311,1960Test & Train1,2001,2831,191921,194891,22756Train Only100663675-12716-53675-12Train Only35076467589817-5367589Train Only600884675209905-21675209Train Only8001,0831,000831,0008399984Train Only1,0001,1961,150461,150461,14353Train Only1,2001,2831,1801031,1801031,176107\n\n\n\n\n\n\n\nCode\npander(tvte, caption=\"Varied fit to test only\")\npander(tvtetr,caption=\"Varied fit to train and test\")\npander(tvtr,caption=\"Varied fit to train only\")"
  },
  {
    "objectID": "Sections/htw_exam.html#constant-testing-predictions",
    "href": "Sections/htw_exam.html#constant-testing-predictions",
    "title": "",
    "section": "Constant Testing Predictions",
    "text": "Constant Testing Predictions\n\n\nCode\n##| column: screen-inset-right\n\n####\n\ncte &lt;-  pluck(a_te_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_te_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_te_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test Only\")\n\nctetr &lt;-  pluck(a_tetr_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tetr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tetr_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") + \n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Test and Train\")\n\nctr &lt;-  pluck(a_tr_c, \"test\") |&gt; rename(ALM=pred,Observed=y) %&gt;% \n  cbind(.,EXAM=pluck(ex0_tr_c, \"test\") |&gt; pull(pred)) %&gt;%\n  cbind(., Hybrid=pluck(hybrid_tr_c, \"test\") |&gt; pull(pred)) |&gt;  \n  pivot_longer(Observed:Hybrid, names_to=\"Model\", values_to = \"vx\") |&gt; \n  ggplot(aes(x,vx,fill=Model, group=Model)) +geom_bar(position=\"dodge\",stat=\"identity\") +\n  scale_fill_manual(values=col_themes$wes2)+\n  scale_x_continuous(breaks=sort(unique(ds$x)), labels=sort(unique(ds$x)))+ylim(0,1500) +\n  theme(legend.title = element_blank(), legend.position=\"top\") +ggtitle(\"Fit to Train Only\")\n  \ncte/ctetr/ctr\n\n\n\n\n\n\n\n\nFigure 3: Constant Group - Mean Model predictions vs. observations\n\n\n\n\n\n\n\nCode\n##| column: screen-inset-right\n\n\n\nbest_cPreds &lt;- cPreds %&gt;%\n  pivot_longer(cols = c(ALM, EXAM, Hybrid), names_to = \"Model\", values_to = \"Predicted\") |&gt;\n  mutate(Residual=(Observed-Predicted), abs_res =abs(Residual)) |&gt; group_by(Fit_Method,x) |&gt;\n  mutate(best=if_else(abs_res==min(abs_res),1,0)) |&gt; select(-abs_res)\n\nlong_cPreds &lt;- best_cPreds |&gt; select(-best) |&gt;\n  pivot_longer(cols=c(Predicted,Residual), names_to=\"Model_Perf\") |&gt;\n  relocate(Model, .after=Fit_Method) |&gt; \n  unite(Model,Model,Model_Perf) |&gt;\n  pivot_wider(names_from=Model,values_from=value)\n\nbest_wideC &lt;- best_cPreds |&gt; select(-Residual,-Predicted,-Observed) |&gt; ungroup() |&gt;\n  pivot_wider(names_from=Model,values_from=best) |&gt; select(ALM,EXAM,Hybrid)\n\nbest_indexC &lt;- row_indices &lt;- apply(best_wideC, 1, function(row) {\n which(row == 1)\n})\n\n\nft &lt;- flextable(long_cPreds) %&gt;% \n  set_header_df(\n    mapping = header_df,\n    key = \"col_keys\"\n  ) %&gt;% \n  theme_booktabs() %&gt;% \n  merge_v(part = \"header\") %&gt;% \n  merge_h(part = \"header\") %&gt;%\n  align(align = \"center\", part = \"all\") %&gt;% \n  #autofit() %&gt;% \n  empty_blanks() %&gt;% \n  fix_border_issues() %&gt;%\n  hline(part = \"header\", i = 1, j=4:9) %&gt;%\n  vline(j=c(\"Observed\",\"ALM_Residual\",\"EXAM_Residual\")) %&gt;%\n  hline(part = \"body\", i=c(6,12)) |&gt; \n  bold(i=long_cPreds$x %in% c(100,350,600, 1000,1200), j=2) \n\n  # bold the cell with the lowest residual, based on best_wide df\n  # for each row, the cell that should be bolded matches which column in best_wide==1 at that row\n\nft &lt;- apply_best_formatting(ft, best_indexC)\nft\n\n\n\n\nTable 5: Constant group - mean model predictions vs. observations. The X values of Extrapolation Bands are bolded. For each Modelling fitting and band combination, the model with the smallest residual is highlighted. Only the lower bound of each velocity band is shown (bands are all 200 units).\n\n\n\nALMEXAMHybridFit MethodXObservedPredictedResidualPredictedResidualPredictedResidualTest Only100527675-148717-190717-190Test Only350666675-9822-156821-155Test Only600780675105927-147926-146Test Only8009806753051,010-301,009-29Test Only1,0001,1636754881,094691,09370Test Only1,2001,2776756021,178991,176101Test & Train100527675-148712-185711-184Test & Train350666675-9806-140800-134Test & Train600780675105900-120889-109Test & Train800980859121975596020Test & Train1,0001,1636754881,0491141,031132Test & Train1,2001,2776756021,1241531,102175Train Only100527675-148697-170675-148Train Only350666675-9752-86675-9Train Only600780675105807-27675105Train Only800980851129851129833147Train Only1,0001,163675488895268675488Train Only1,2001,277675602939338675602"
  },
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Dissertation Manuscript",
    "section": "",
    "text": "HTML\n   \n  \n  \n    HTML (new window)\n  \n\n  \n    PDF\n   \n  \n\n    PDF (download)\n  \n\n    \n    DOCX (download)\n  \n  \n  \n  \n  \n  \n  \n  \n  Click buttons above to select format or download",
    "crumbs": [
      "Dissertation Manuscript"
    ]
  },
  {
    "objectID": "Sections/HTW.html#overview-of-present-study",
    "href": "Sections/HTW.html#overview-of-present-study",
    "title": "HTW Project",
    "section": "Overview Of Present Study",
    "text": "Overview Of Present Study\nThe present study investigates the influence of training variability on learning, generalization, and extrapolation in a uni-dimensional visuomotor function learning task. To the best of our knowledge, this research is the first to employ the classic constant vs. varied training manipulation, commonly used in the literature on the benefits of variability, in the context of a uni-dimensional function learning task. Across three experiments, we compare constant and varied training conditions in terms of learning performance, extrapolation accuracy, and the ability to reliably discriminate between stimuli.\nTo account for the empirical results, we will apply a series of computational models, including the Associative Learning Model (ALM) and the Extrapolation-Association Model (EXAM). Notably, this study is the first to employ approximate Bayesian computation (ABC) to fit these models to individual subject data, enabling us to thoroughly investigate the full range of posterior predictions of each model, and to examine the the ability of these influential models of function learning to account for both the group level and individual level data.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#methods",
    "href": "Sections/HTW.html#methods",
    "title": "HTW Project",
    "section": "Methods",
    "text": "Methods\nParticipants A total of 156 participants were recruited from the Indiana University Introductory Psychology Course. Participants were randomly assigned to one of two training conditions: varied training or constant training.\nTask. The “Hit The Wall” (HTW) visuomotor extrapolation task task was programmed in Javascript, making heavy use of the phaser.io game library. The HTW task involved launching a projectile such that it would strike the “wall” at target speed indicated at the top of the screen (see Figure 2). The target velocities were given as a range, or band, of acceptable velocity values (e.g. band 800-1000). During the training stage, participants received feedback indicating whether they had hit the wall within the target velocity band, or how many units their throw was above or below from the target band. Participants were instructed that only the x velocity component of the ball was relevant to the task. The y velocity, or the location at which the ball struck the wall, had no influence on the task feedback.\n/\n\n\n\n\n\n\n\n\nFigure 2: The Hit the wall task. Participants launch the blue ball to hit the red wall at the target velocity band indicated at the top of the screen. The ball must be released from within the orange square - but the location of release, and the location at which the ball strikes the wall are both irrelevant to the task feedback.\n\n\n\n\n\nProcedure. All participants completed the task online. Participants were provided with a description of the experiment and indicated informed consent. Figure 3 illustrates the general procedure. Participants completed a total of 90 trials during the training stage. In the varied training condition, participants encountered three velocity bands (800-1000, 1000-1200, and 1200-1400). Participants in the constant training condition trained on only one velocity band (800-1000) - the closest band to what would be the novel extrapolation bands in the testing stage.\nFollowing the training stage, participants proceeded immediately to the testing stage. Participants were tested from all six velocity bands, in two separate stages. In the novel extrapolation testing stage, participants completed “no-feedback” testing from three novel extrapolation bands (100-300, 350-550, and 600-800), with each band consisting of 15 trials. Participants were also tested from the three velocity bands that were trained by the varied condition (800-1000, 1000-1200, and 1200-1400). In the constant training condition, two of these bands were novel, while in the varied training condition, all three bands were encountered during training. The order in which participants completed the novel-extrapolation and testing-from-3-varied bands was counterbalanced across participants. A final training stage presented participants with “feedback” testing for each of the three extrapolation bands (100-300, 350-550, and 600-800).\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1\n\nTest  \nNovel Bands \n100-300\n350-550\n600-800\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n800-1000\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n100-300\n350-550\n600-800\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 3: Experiment 1 Design. Constant and Varied participants complete different training conditions.\n\n\n\n\n\n\n\nCode\n# pacman::p_load(dplyr,purrr,tidyr,tibble,ggplot2,\n#   brms,tidybayes, rstanarm,emmeans,broom,bayestestR,\n#   stringr, here,conflicted, patchwork, knitr)\n# #options(brms.backend=\"cmdstanr\",mc.cores=4)\n# options(digits=2, scipen=999, dplyr.summarise.inform=FALSE)\n# walk(c(\"brms\",\"dplyr\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\n# walk(c(\"Display_Functions\",\"org_functions\"), ~ source(here::here(paste0(\"Functions/\", .x, \".R\"))))\ne1 &lt;- readRDS(here(\"data/e1_08-21-23.rds\")) \ne1Sbjs &lt;- e1 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ntestE1 &lt;- e1 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE1 &lt;-  e1 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE1_max &lt;- trainE1 |&gt; filter(Trial_Bin == nbins, bandInt==800)\ntrainE1_avg &lt;- trainE1_max |&gt; group_by(id,condit) |&gt; summarise(avg = mean(dist))\n\n\n\nAnalyses Strategy\nAll data processing and statistical analyses were performed in R version 4.32 Team (2020). To assess differences between groups, we used Bayesian Mixed Effects Regression. Model fitting was performed with the brms package in R Bürkner (2017), and descriptive stats and tables were extracted with the BayestestR package Makowski et al. (2019). Mixed effects regression enables us to take advantage of partial pooling, simultaneously estimating parameters at the individual and group level. Our use of Bayesian, rather than frequentist methods allows us to directly quantify the uncertainty in our parameter estimates, as well as avoiding convergence issues common to the frequentist analogues of our mixed models.\nEach model was set to run with 4 chains, 5000 iterations per chain, with the first 2500 discarded as warmup chains. Rhat values were within an acceptable range, with values &lt;=1.02 (see appendix for diagnostic plots). We used uninformative priors for the fixed effects of the model (condition and velocity band), and weakly informative Student T distributions for for the random effects. For each model, we report 1) the mean values of the posterior distribution for the parameters of interest, 2) the lower and upper credible intervals (CrI), and the probability of direction value (pd).\n\n\n\n\n\n\n\n\nGroup Comparison\nCode\nData\n\n\n\n\nEnd of Training Accuracy\nbrm(dist ~ condit)\nFinal Training Block\n\n\nTest Accuracy\nbrm(dist ~ condit * bandType + (1|id) + (1|bandInt)\nAll Testing trials\n\n\nBand Discrimination\nbrm(vx ~ condit * band +(1 + bandInt|id)\nAll Testing Trials\n\n\n\n\n\nIn each experiment we compare varied and constant conditions in terms of 1) accuracy in the final training block; 2) testing accuracy as a function of band type (trained vs. extrapolation bands); 3) extent of discrimination between all six testing bands. We quantified accuracy as the absolute deviation between the response velocity and the nearest boundary of the target band. Thus, when the target band was velocity 600-800, throws of 400, 650, and 900 would result in deviation values of 200, 0, and 100, respectively. The degree of discrimination between bands was index by fitting a linear model predicting the response velocity as a function of the target velocity. Participants who reliably discriminated between velocity bands tended to haves slope values ~1, while participants who made throws irrespective of the current target band would have slopes ~0.\n\n\nResults\n\n\nCode\np1 &lt;- trainE1 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    facet_wrap(~vb)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e1_train_deviation.png\"), p1, width = 8, height = 4,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 4: Experiment 1 Training Stage. Deviations from target band across training blocks. Lower values represent greater accuracy.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e1-train-dist\n##| tbl-cap: \"Experiment 1 - Learning curves. \"\n##| output: asis\n\nbmm_e1_train&lt;- trainE1_max %&gt;% \n  brm(dist ~ condit, \n      file=here(\"data/model_cache/e1_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\nmtr1 &lt;- as.data.frame(describe_posterior(bmm_e1_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\ncolnames(mtr1) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\n# mtr1 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#    kable(booktabs = TRUE)\n\ncdtr1 &lt;- get_coef_details(bmm_e1_train, \"conditVaried\")\n\n\n\n\n\nTable 1: Experiment 1 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive estimates indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n106.34\n95.46\n117.25\n1\n\n\nconditVaried\n79.64\n57.92\n101.63\n1\n\n\n\n\n\n\n\n\nTraining. Figure 4 displays the average deviations across training blocks for the varied group, which trained on three velocity bands, and the constant group, which trained on one velocity band. To compare the training conditions at the end of training, we analyzed performance on the 800-1000 velocity band, which both groups trained on. The full model results are shown in Table 1. The varied group had a significantly greater deviation than the constant group in the final training block, (\\(\\beta\\) = 79.64, 95% CrI [57.92, 101.63]; pd = 100%).\n\n\nCode\n##| label: tbl-e1-bmm-dist\n##| tbl-cap: \"E1. Training vs. Extrapolation\"\n#| \nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e1_dist_Cond_Type_RF_2\")\nbmtd &lt;- brm(dist ~ condit * bandType + (1|bandInt) + (1|id), \n    data=testE1, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted1 &lt;- as.data.frame(describe_posterior(bmtd, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted1) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\n# r_bandInt_params &lt;- get_variables(bmtd)[grepl(\"r_bandInt\", get_variables(bmtd))]\n# posterior_summary(bmtd,variable=r_bandInt_params)\n# \n# r_bandInt_params &lt;- get_variables(bmtd)[grepl(\"r_id:bandInt\", get_variables(bmtd))]\n# posterior_summary(bmtd,variable=r_bandInt_params)\n\n# mted1 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt; kable(booktabs = TRUE)\ncdted1 &lt;- get_coef_details(bmtd, \"conditVaried\")\ncdted2 &lt;-get_coef_details(bmtd, \"bandTypeExtrapolation\")\ncdted3 &lt;-get_coef_details(bmtd, \"conditVaried:bandTypeExtrapolation\")\n\n\n\n\n\nTable 2: Experiment 1 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficients indicate larger deviations from the baselines (Condition=constant & bandType=Trained) - and a positive interaction coefficient indicates disproporionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n152.55\n70.63\n229.85\n1.0\n\n\nconditVaried\n39.00\n-21.10\n100.81\n0.9\n\n\nbandTypeExtrapolation\n71.51\n33.24\n109.60\n1.0\n\n\nconditVaried:bandTypeExtrapolation\n66.46\n32.76\n99.36\n1.0\n\n\n\n\n\n\nTesting. To compare accuracy between groups in the testing stage, we fit a Bayesian mixed effects model predicting deviation from the target band as a function of training condition (varied vs. constant) and band type (trained vs. extrapolation), with random intercepts for participants and bands. The model results are shown in Table 2. The main effect of training condition was not significant (\\(\\beta\\) = 39, 95% CrI [-21.1, 100.81]; pd = 89.93%). The extrapolation testing items had a significantly greater deviation than the training bands (\\(\\beta\\) = 71.51, 95% CrI [33.24, 109.6]; pd = 99.99%). Most importantly, the interaction between training condition and band type was significant (\\(\\beta\\) = 66.46, 95% CrI [32.76, 99.36]; pd = 99.99%), As shown in Figure 5, the varied group had disproportionately larger deviations compared to the constant group in the extrapolation bands.\n\n\nCode\npe1td &lt;- testE1 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe1ce &lt;- bmtd |&gt; emmeans( ~condit + bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\")\n\np2 &lt;- (pe1td + pe1ce) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e1_test-dev.png\"), p2, width=8, height=4, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 5: A) Deviations from target band during testing without feedback stage. B) Conditional effect of condition (Constant vs. Varied) and testing band type (training vs. extrapolation) on testing accuracy. Error bars represent 95% credible intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e1-bmm-vx\n##| tbl-cap: \"Experiment 1. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\ne1_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e1_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n#GetModelStats(e1_vxBMM) |&gt; kable(booktabs = TRUE)\n\ncd1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e1_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\n\n\n\nTable 3: Experiment 1. Bayesian Mixed Model Predicting velocity as a function of condition (Constant vs. Varied) and Velocity Band. Larger coefficients on Band represent greater sensitivity/discrimination.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n408.55\n327.00\n490.61\n1.00\n\n\nconditVaried\n164.05\n45.50\n278.85\n1.00\n\n\nBand\n0.71\n0.62\n0.80\n1.00\n\n\ncondit*Band\n-0.14\n-0.26\n-0.01\n0.98\n\n\n\n\n\n\nFinally, to assess the ability of both conditions to discriminate between velocity bands, we fit a model predicting velocity as a function of training condition and velocity band, with random intercepts and random slopes for each participant. See Table 4 for the full model results. The estimated coefficient for training condition (\\(\\beta\\) = 164.05, 95% CrI [45.5, 278.85], pd = 99.61%) suggests that the varied group tends to produce harder throws than the constant group, but is not in and of itself useful for assessing discrimination. Most relevant to the issue of discrimination is the coefficient on the Band predictor (\\(\\beta\\) = 0.71 95% CrI [0.62, 0.8], pd = 100%). Although the median slope does fall underneath the ideal of value of 1, the fact that the 95% credible interval does not contain 0 provides strong evidence that participants exhibited some discrimination between bands. The estimate for the interaction between slope and condition (\\(\\beta\\) = -0.14, 95% CrI [-0.26, -0.01], pd = 98.39%), suggests that the discrimination was somewhat modulated by training condition, with the varied participants showing less sensitivity between bands than the constant condition. This difference is depicted visually in Figure 6.\n\n\nCode\ntestE1 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 6: Empirical distribution of velocities producing in testing stage. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\npe1vce &lt;- e1_vxBMM |&gt; emmeans( ~condit + bandInt,re_formula=NA, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE1$vb), \n                     limits = c(0, 1400)) + \n  scale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e1_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e1_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction &lt;- fixef(e1_vxBMM)[,1][\"conditVaried:bandInt\"]\n\nre &lt;- data.frame(ranef(e1_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e1Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction*(condit==\"Varied\"),slope = Estimate + adjust )\n\n\npid_den1 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\")\n\npid_slopes1 &lt;- re |&gt;  mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n     theme(legend.title=element_blank(), \n           axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_wrap2(~condit,axes=\"all\",scales=\"free_y\")\n\n\np3 &lt;- (pe1vce + pid_den1 + pid_slopes1) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e1_test-vx.png\"), p3,width=9,height=11, bg=\"white\",dpi=600)\np3\n\n\n\n\nTable 4\n\n\n\n\n\n\nExperiment 1. Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#e1-summary",
    "href": "Sections/HTW.html#e1-summary",
    "title": "HTW Project",
    "section": "E1 Summary",
    "text": "E1 Summary\nIn Experiment 1, we investigated how variability in training influenced participants’ ability learn and extrapolate in a visuomotor task. Our findings that training with variable conditions rresulted in lower final training performance is consistent with much of the prior researchon the influence of training variability (Raviv et al., 2022; Soderstrom & Bjork, 2015), and is particularly unsurprising in the present work, given that the constant group received three times the amount of training on the velocity band common to the two conditions.\nMore importantly, the varied training group exhibited significantly larger deviations from the target velocity bands during the testing phase, particularly for the extrapolation bands that were not encountered by either condition during training.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#experiment-2",
    "href": "Sections/HTW.html#experiment-2",
    "title": "HTW Project",
    "section": "Experiment 2",
    "text": "Experiment 2\n\n\nCode\nwalk(c(\"brms\",\"dplyr\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\nwalk(c(\"Display_Functions\",\"org_functions\"), ~ source(here::here(paste0(\"Functions/\", .x, \".R\"))))\ne2 &lt;- readRDS(here(\"data/e2_08-04-23.rds\")) \ne2Sbjs &lt;- e2 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ntestE2 &lt;- e2 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE2 &lt;-  e2 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE2_max &lt;- trainE2 |&gt; filter(Trial_Bin == nbins, bandInt==600)\n\n# e2 |&gt; group_by(condit, bandOrder) |&gt; summarise(n_distinct(id))\n\n\n\nMethods & Procedure\nThe task and procedure of Experiment 2 was identical to Experiment 1, with the exception that the training and testing bands were reversed (see Figure 7). The Varied group trained on bands 100-300, 350-550, 600-800, and the constant group trained on band 600-800. Both groups were tested from all six bands. A total of 110 participants completed the experiment (Varied: 55, Constant: 55).\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n100-300\n350-550\n600-800\n\n\n\nTest1\n\nTest  \nNovel Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n600-800\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n100-300\n350-550\n600-800\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 7: Experiment 2 Design. Constant and Varied participants complete different training conditions. The training and testing bands are the reverse of Experiment 1.\n\n\n\n\n\n\n\nResults\n\n\nCode\np1 &lt;- trainE2 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    facet_wrap(~vb)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e2_train_deviation.png\"), p1, width = 8, height = 4,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 8: Experiment 2 Training Stage. Deviations from target band across training blocks. Lower values represent greater accuracy.\n\n\n\n\n\n\n\nCode\nbmm_e2_train &lt;- trainE2_max %&gt;% \n  brm(dist ~ condit, \n      file=here(\"data/model_cache/e2_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\nmtr2 &lt;- as.data.frame(describe_posterior(bmm_e2_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\ncolnames(mtr2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\ncdtr2 &lt;- get_coef_details(bmm_e2_train, \"conditVaried\")\n# mtr2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\n\n\n\n\nTable 5: Experiment 2 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n91.01\n80.67\n101.26\n1\n\n\nconditVaried\n36.15\n16.35\n55.67\n1\n\n\n\n\n\n\n\n\nTraining. Figure 8 presents the deviations across training blocks for both constant and varied training groups. We again compared training performance on the band common to both groups (600-800). The full model results are shown in Table 1. The varied group had a significantly greater deviation than the constant group in the final training block, ( \\(\\beta\\) = 36.15, 95% CrI [16.35, 55.67]; pd = 99.95%).\n\n\nCode\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e2_dist_Cond_Type_RF_2\")\nbmtd2 &lt;- brm(dist ~ condit * bandType + (1|bandInt) + (1|id), \n    data=testE2, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted2 &lt;- as.data.frame(describe_posterior(bmtd2, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\ncd2ted1 &lt;- get_coef_details(bmtd2, \"conditVaried\")\ncd2ted2 &lt;-get_coef_details(bmtd2, \"bandTypeExtrapolation\")\ncd2ted3 &lt;-get_coef_details(bmtd2, \"conditVaried:bandTypeExtrapolation\")\n\n\n\n\n\nTable 6: Experiment 2 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant & trained bands) - and a positive interaction coefficient indicates disproporionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n190.91\n125.03\n259.31\n1.00\n\n\nconditVaried\n-20.58\n-72.94\n33.08\n0.78\n\n\nbandTypeExtrapolation\n38.09\n-6.94\n83.63\n0.95\n\n\nconditVaried:bandTypeExtrapolation\n82.00\n41.89\n121.31\n1.00\n\n\n\n\n\n\n \n\nTesting Accuracy. The analysis of testing accuracy examined deviations from the target band as influenced by training condition (Varied vs. Constant) and band type (training vs. extrapolation bands). The results, summarized in Table 6, reveal no significant main effect of training condition (\\(\\beta\\) = -20.58, 95% CrI [-72.94, 33.08]; pd = 77.81%). However, the interaction between training condition and band type was significant (\\(\\beta\\) = 82, 95% CrI [41.89, 121.31]; pd = 100%), with the varied group showing disproportionately larger deviations compared to the constant group on the extrapolation bands (see Figure 9).\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\npe2td &lt;- testE2 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\n\npe2ce &lt;- bmtd2 |&gt; emmeans( ~condit + bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\")\n\np2 &lt;- (pe2td + pe2ce) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-dev.png\"), p2, width=8, height=4, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 9: A) Deviations from target band during testing without feedback stage. B) Estimated marginal means for the interaction between training condition and band type. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e2-bmm-vx\n##| tbl-cap: \"Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne2_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e2_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n#GetModelStats(e2_vxBMM ) |&gt; kable(escape=F,booktabs=T, caption=\"Fit to all 6 bands\")\n\ncd2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried\")\nsc2 &lt;- get_coef_details(e2_vxBMM, \"bandInt\")\nintCoef2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\n\nTable 7: Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n362.64\n274.85\n450.02\n1.00\n\n\nconditVaried\n-8.56\n-133.97\n113.98\n0.55\n\n\nBand\n0.71\n0.58\n0.84\n1.00\n\n\ncondit*Band\n-0.06\n-0.24\n0.13\n0.73\n\n\n\n\n\n\nTesting Discrimination. Finally, to assess the ability of both conditions to discriminate between velocity bands, we fit a model predicting velocity as a function of training condition and velocity band, with random intercepts and random slopes for each participant. The full model results are shown in Table 8. The overall slope on target velocity band predictor was significantly positive, (\\(\\beta\\) = 0.71, 95% CrI [0.58, 0.84]; pd= 100%), indicating that participants exhibited discrimination between bands. The interaction between slope and condition was not significant, (\\(\\beta\\) = -0.06, 95% CrI [-0.24, 0.13]; pd= 72.67%), suggesting that the two conditions did not differ in their ability to discriminate between bands (see Figure 10).\n\n\nCode\ntestE2 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 10: E2 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n}\n\npe2vce &lt;- e2_vxBMM |&gt; emmeans( ~condit + bandInt,re_formula=NA, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE2$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e2_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e2_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction &lt;- fixef(e2_vxBMM)[,1][\"conditVaried:bandInt\"]\n\nre &lt;- data.frame(ranef(e2_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e2Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction*(condit==\"Varied\"),slope = Estimate + adjust )\n\npid_den2 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\")\n\npid_slopes2 &lt;- re |&gt;  mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n      theme(legend.title=element_blank(), \n        axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_wrap2(~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe2vce + pid_den2 + pid_slopes2) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-vx.png\"), p3,width=9,height=11, bg=\"white\",dpi=600)\np3\n\n\n\n\nTable 8\n\n\n\n\n\n\nConditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\n\n\nExperiment 2 Summary\nExperiment 2 extended the findings of Experiment 1 by examining the effects of training variability on extrapolation performance in a visuomotor function learning task, but with reversed training and testing bands. Similar to Experiment 1, the Varied group exhibited poorer performance during training and testing. However unlike experiment 1, the Varied group did not show a significant difference in discrimination between bands.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#experiment-3",
    "href": "Sections/HTW.html#experiment-3",
    "title": "HTW Project",
    "section": "Experiment 3",
    "text": "Experiment 3\n\n\nCode\ne3 &lt;- readRDS(here(\"data/e3_08-04-23.rds\")) |&gt; \n    mutate(trainCon=case_when(\n    bandOrder==\"Original\" ~ \"800\",\n    bandOrder==\"Reverse\" ~ \"600\",\n    TRUE ~ NA_character_\n    ), trainCon=as.numeric(trainCon)) \ne3Sbjs &lt;- e3 |&gt; group_by(id,condit,bandOrder) |&gt; summarise(n=n())\ntestE3 &lt;- e3 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE3 &lt;-  e3 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit,bandOrder, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE3_max &lt;- trainE3 |&gt; filter(Trial_Bin == nbins, bandInt==trainCon)\n\n\n\nMethods & Procedure\nThe major adjustment of Experiment 3 is for participants to receive ordinal feedback during training, in contrast to the continuous feedback of the prior experiments. After each training throw, participants are informed whether a throw was too soft, too hard, or correct (i.e. within the target velocity range). All other aspects of the task and design are identical to Experiments 1 and 2. We utilized the order of training and testing bands from both of the prior experiments, thus assigning participants to both an order condition (Original or Reverse) and a training condition (Constant or Varied). Participants were once again recruited from the online Indiana University Introductory Psychology Course pool. Following exclusions, 195 participants were included in the final analysis, n=51 in the Constant-Original condition, n=59 in the Constant-Reverse condition, n=39 in the Varied-Original condition, and n=46 in the Varied-Reverse condition.\n\n\nResults\n\n\nCode\nbmm_e3_train &lt;- trainE3_max %&gt;% \n  brm(dist ~ condit*bandOrder, \n      file=here(\"data/model_cache/e3_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\n# mtr3 &lt;- as.data.frame(describe_posterior(bmm_e3_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mtr3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mtr3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\ncd3tr1 &lt;- get_coef_details(bmm_e3_train, \"conditVaried\")\ncd3tr2 &lt;-get_coef_details(bmm_e3_train, \"bandOrderReverse\")\ncd3tr3 &lt;-get_coef_details(bmm_e3_train, \"conditVaried:bandOrderReverse\")\n\n\n\n\n\nTable 9: Experiment 3 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n121.86\n109.24\n134.60\n1.00\n\n\nconditVaried\n64.93\n36.99\n90.80\n1.00\n\n\nbandOrderReverse\n1.11\n-16.02\n18.16\n0.55\n\n\nconditVaried:bandOrderReverse\n-77.02\n-114.16\n-39.61\n1.00\n\n\n\n\n\n\nTraining. Figure 11 displays the average deviations from the target band across training blocks, and Table 9 shows the results of the Bayesian regression model predicting the deviation from the common band at the end of training (600-800 for reversed order, and 800-1000 for original order conditions). The main effect of training condition is significant, with the varied condition showing larger deviations ( \\(\\beta\\) = 64.93, 95% CrI [36.99, 90.8]; pd = 100%). The main effect of band order is not significant \\(\\beta\\) = 1.11, 95% CrI [-16.02, 18.16]; pd = 55.4%, however the interaction between training condition and band order is significant, with the varied condition showing greater accuracy in the reverse order condition ( \\(\\beta\\) = -77.02, 95% CrI [-114.16, -39.61]; pd = 100%).\n\n\nCode\np1 &lt;- trainE3 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    ggh4x::facet_nested_wrap(~bandOrder*vb,ncol=3)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e3_train_deviation.png\"), p1, width = 9, height = 8,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 11: E3. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e3_dist_Cond_Type_RF_2\")\nbmtd3 &lt;- brm(dist ~ condit * bandType*bandOrder + (1|bandInt) + (1|id), \n    data=testE3, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted3 &lt;- as.data.frame(describe_posterior(bmtd3, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\n#ce_bmtd3 &lt;- plot(conditional_effects(bmtd3),points=FALSE,plot=FALSE)\n#wrap_plots(ce_bmtd3)\n\n#ggsave(here::here(\"Assets/figs\", \"e3_cond_effects_dist.png\"), wrap_plots(ce_bmtd3), width=11, height=11, bg=\"white\")\n\ncd3ted1 &lt;- get_coef_details(bmtd3, \"conditVaried\")\ncd3ted2 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation\")\ncd3ted3 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation\")\ncd3ted4 &lt;-get_coef_details(bmtd3, \"bandOrderReverse\")\ncd3ted5 &lt;-get_coef_details(bmtd3, \"conditVaried:bandOrderReverse\")\ncd3ted6 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation:bandOrderReverse\")\ncd3ted7 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation:bandOrderReverse\")\n\n\n\n\n\nTable 10: Experiment 3 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant training; trained bands & original order) - and a positive interaction coefficient indicates disproportionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n288.65\n199.45\n374.07\n1.00\n\n\nconditVaried\n-40.19\n-104.68\n23.13\n0.89\n\n\nbandTypeExtrapolation\n-23.35\n-57.28\n10.35\n0.92\n\n\nbandOrderReverse\n-73.72\n-136.69\n-11.07\n0.99\n\n\nconditVaried:bandTypeExtrapolation\n52.66\n14.16\n90.23\n1.00\n\n\nconditVaried:bandOrderReverse\n-37.48\n-123.28\n49.37\n0.80\n\n\nbandTypeExtrapolation:bandOrderReverse\n80.69\n30.01\n130.93\n1.00\n\n\nconditVaried:bandTypeExtrapolation:bandOrderReverse\n30.42\n-21.00\n81.65\n0.87\n\n\n\n\n\n\nTesting Accuracy. Table 10 presents the results of the Bayesian mixed efects model predicting absolute deviation from the target band during the testing stage. There was no significant main effect of training condition,\\(\\beta\\) = -40.19, 95% CrI [-104.68, 23.13]; pd = 89.31%, or band type,\\(\\beta\\) = -23.35, 95% CrI [-57.28, 10.35]; pd = 91.52%. However the effect of band order was significant, with the reverse order condition showing lower deviations, \\(\\beta\\) = -73.72, 95% CrI [-136.69, -11.07]; pd = 98.89%. The interaction between training condition and band type was also significant \\(\\beta\\) = 52.66, 95% CrI [14.16, 90.23]; pd = 99.59%, with the varied condition showing disproprionately large deviations on the extrapolation bands compared to the constant group. There was also a significant interaction between band type and band order, \\(\\beta\\) = 80.69, 95% CrI [30.01, 130.93]; pd = 99.89%, such that the reverse order condition showed larger deviations on the extrapolation bands. No other interactions were significant.\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3td &lt;- testE3 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n    facet_wrap(~bandOrder,ncol=1) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\npe3ce &lt;- bmtd3 |&gt; emmeans( ~condit *bandOrder*bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\") + \n facet_wrap(~bandOrder,ncol=1)\n\np2 &lt;- pe3td + pe3ce + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e3_test-dev.png\"), p2, width=9, height=8, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 12: Experiment 3 Testing Accuracy. A) Deviations from target band during testing without feedback stage. B) Conditional effect of condition (Constant vs. Varied) and testing band type (training vs. extrapolation) on testing accuracy. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e3-bmm-vx\n##| tbl-cap: \"Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne3_vxBMM &lt;- brm(vx ~ condit * bandOrder * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e3_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n# m1 &lt;- as.data.frame(describe_posterior(e3_vxBMM, centrality = \"Mean\"))\n# m2 &lt;- fixef(e3_vxBMM)\n# mp3 &lt;- m1[, c(1,2,4,5,6)]\n# colnames(mp3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")                       \n# mp3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_replace_all(Term, \"b_bandInt\", \"Band\")) |&gt;\n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T)\n\n#wrap_plots(plot(conditional_effects(e3_vxBMM),points=FALSE,plot=FALSE))\n\ncd1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e3_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried:bandInt\")\nintCoef2 &lt;- get_coef_details(e3_vxBMM, \"bandOrderReverse:bandInt\")\ncoef3 &lt;- get_coef_details(e3_vxBMM,\"conditVaried:bandOrderReverse:bandInt\")\n\n\n\n\n\nTable 11: Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n601.83\n504.75\n699.42\n1.00\n\n\nconditVaried\n12.18\n-134.94\n162.78\n0.56\n\n\nbandOrderReverse\n13.03\n-123.89\n144.67\n0.58\n\n\nBand\n0.49\n0.36\n0.62\n1.00\n\n\nconditVaried:bandOrderReverse\n-338.15\n-541.44\n-132.58\n1.00\n\n\nconditVaried:Band\n-0.04\n-0.23\n0.15\n0.67\n\n\nbandOrderReverse:bandInt\n-0.10\n-0.27\n0.08\n0.86\n\n\nconditVaried:bandOrderReverse:bandInt\n0.42\n0.17\n0.70\n1.00\n\n\n\n\n\n\nTesting Discrimination. The full results of the discrimination model are presented in Table 10. For the purposes of assessing group differences in discrimination, only the coefficients including the band variable are of interest. The baseline effect of band represents the slope cofficient for the constant training - original order condition, this effect was significant \\(\\beta\\) = 0.49, 95% CrI [0.36, 0.62]; pd = 100%. Neither of the two way interactions reached significance, \\(\\beta\\) = -0.04, 95% CrI [-0.23, 0.15]; pd = 66.63%, \\(\\beta\\) = -0.1, 95% CrI [-0.27, 0.08]; pd = 86.35%. However, the three way interaction between training condition, band order, and target band was significant, \\(\\beta\\) = 0.42, 95% CrI [0.17, 0.7]; pd = 99.96% - indicating that the varied condition showed a greater slope coefficient on the reverse order bands, compared to the constant condition - this is clearly shown in Figure 13, where the steepness of the best fitting line for the varied-reversed condition is noticably steeper than the other conditions.\n\n\nCode\n##| column: screen-inset-right\n# testE3 |&gt; filter(bandOrder==\"Original\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit()\n# testE3 |&gt; filter(bandOrder==\"Reverse\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit() +ggtitle(\"test\")\n\ntestE3 |&gt; group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + \n   ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\n\n\n\n\n\n\nFigure 13: e3 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\n##| eval: FALSE\n# pe3tv &lt;- testE3 %&gt;% group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3vce &lt;- e3_vxBMM |&gt; emmeans( ~condit* bandOrder* bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  facet_wrap(~bandOrder,ncol=1) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE3$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e3_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e3_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction1 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandInt\"]\nfixed_effect_interaction2 &lt;- fixef(e3_vxBMM)[,1][\"bandOrderReverse:bandInt\"]\nfixed_effect_interaction3 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandOrderReverse:bandInt\"]\n\nre &lt;- data.frame(ranef(e3_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e3Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction1*(condit==\"Varied\") + \n           fixed_effect_interaction2*(bandOrder==\"Reverse\") + \n           fixed_effect_interaction3*(condit==\"Varied\" & bandOrder==\"Reverse\"),\n  slope = Estimate + adjust )\n\npid_den3 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\") +\n  facet_wrap(~bandOrder,ncol=1)\n\npid_slopes3 &lt;- re |&gt;  \n    mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n    geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n    theme(legend.title=element_blank(), \n      axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_nested_wrap(bandOrder~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe3vce + pid_den3 + pid_slopes3) + plot_annotation(tag_levels= 'A')\n\n#ggsave(here::here(\"Assets/figs\", \"e3_test-vx.png\"), p3,width=11,height=13, bg=\"white\",dpi=800)\np3\n\n\n\n\n\n\n\n\nFigure 14: Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\nExperiment 3 Summary",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#computational-model",
    "href": "Sections/HTW.html#computational-model",
    "title": "HTW Project",
    "section": "Computational Model",
    "text": "Computational Model\n\n\nCode\n####| cache: false\npacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, \n               stringr,future,furrr, knitr, reactable,ggstance, htmltools,\n               ggdist,ggh4x,brms,tidybayes,emmeans,bayestestR, gt)\n#walk(c(\"dplyr\"), conflict_prefer_all, quiet = TRUE)\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\noptions(digits=3, scipen=999, dplyr.summarise.inform=FALSE)\nwalk(c(\"Display_Functions\",\"fun_alm\",\"fun_indv_fit\",\"fun_model\", \"prep_model_data\",\"org_functions\"), ~source(here::here(paste0(\"Functions/\", .x, \".R\"))))\n\n\n\n\nCode\ninvisible(list2env(load_sbj_data(), envir = .GlobalEnv))\ninvisible(list2env(load_e1(), envir = .GlobalEnv))\ne1Sbjs &lt;- e1 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ne2_model &lt;- load_e2()\ne3_model &lt;- load_e3()\n\n\n\n\nCode\nalm_plot()\n\n\n\n\n\n\n\n\nFigure 15: The Associative Learning Model (ALM). The diagram illustrates the basic structure of the ALM model as used in the present work. Input nodes are activated as a function of their similarity to the lower-boundary of the target band. The generalization parameter, \\(c\\), determines the degree to which nearby input nodes are activated. The output nodes are activated as a function of the weighted sum of the input nodes - weights are updated via the delta rule.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#model-fitting",
    "href": "Sections/HTW.html#model-fitting",
    "title": "HTW Project",
    "section": "Model Fitting",
    "text": "Model Fitting\nTo fit ALM and EXAM to our participant data, we employ a similar method to Mcdaniel et al. (2009), wherein we examine the performance of each model after being fit to various subsets of the data. Each model was fit to the data in with separate procedures: 1) fit to maximize predictions of the testing data, 2) fit to maximize predictions of both the training and testing data, 3) fit to maximize predictions of the just the training data. We refer to this fitting manipulations as “Fit Method” in the tables and figures below. It should be emphasized that for all three fit methods, the ALM and EXAM models behave identically - with weights updating only during the training phase.Models to were fit separately to the data of each individual participant. The free parameters for both models are the generalization (\\(c\\)) and learning rate (\\(lr\\)) parameters. Parameter estimation was performed using approximate bayesian computation (ABC), which we describe in detail below.\n\n\n\n\n\n\n Approximate Bayesian Computation\nTo estimate the parameters of ALM and EXAM, we used approximate bayesian computation (ABC), enabling us to obtain an estimate of the posterior distribution of the generalization and learning rate parameters for each individual. ABC belongs to the class of simulation-based inference methods (Cranmer et al., 2020), which have begun being used for parameter estimation in cognitive modeling relatively recently (Kangasrääsiö et al., 2019; Turner et al., 2016; Turner & Van Zandt, 2012). Although they can be applied to any model from which data can be simulated, ABC methods are most useful for complex models that lack an explicit likelihood function (e.g. many neural network models).\nThe general ABC procedure is to 1) define a prior distribution over model parameters. 2) sample candidate parameter values, \\(\\theta^*\\), from the prior. 3) Use \\(\\theta^*\\) to generate a simulated dataset, \\(Data_{sim}\\). 4) Compute a measure of discrepancy between the simulated and observed datasets, \\(discrep\\)(\\(Data_{sim}\\), \\(Data_{obs}\\)). 5) Accept \\(\\theta^*\\) if the discrepancy is less than the tolerance threshold, \\(\\epsilon\\), otherwise reject \\(\\theta^*\\). 6) Repeat until desired number of posterior samples are obtained.\nAlthough simple in the abstract, implementations of ABC require researchers to make a number of non-trivial decisions as to i) the discrepancy function between observed and simulated data, ii) whether to compute the discrepancy between trial level data, or a summary statistic of the datasets, iii) the value of the minimum tolerance \\(\\epsilon\\) between simulated and observed data. For the present work, we follow the guidelines from previously published ABC tutorials (Farrell & Lewandowsky, 2018; Turner & Van Zandt, 2012). For the test stage, we summarized datasets with mean velocity of each band in the observed dataset as \\(V_{obs}^{(k)}\\) and in the simulated dataset as \\(V_{sim}^{(k)}\\), where \\(k\\) represents each of the six velocity bands. For computing the discrepancy between datasets in the training stage, we aggregated training trials into three equally sized blocks (separately for each velocity band in the case of the varied group). After obtaining the summary statistics of the simulated and observed datasets, the discrepancy was computed as the mean of the absolute difference between simulated and observed datasets (Equation 1 and Equation 2). For the models fit to both training and testing data, discrepancies were computed for both stages, and then averaged together.\n\n\\[\ndiscrep_{Test}(Data_{sim}, Data_{obs}) = \\frac{1}{6} \\sum_{k=1}^{6} |V_{obs}^{(k)} - V_{sim}^{(k)}|\n\\tag{1}\\]\n\\[\n\\begin{aligned} \\\\\ndiscrep_{Train,constant}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks}} \\sum_{j=1}^{N_{blocks}} |V_{obs,constant}^{(j)} - V_{sim,constant}^{(j)}| \\\\ \\\\\ndiscrep_{Train,varied}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks} \\times 3} \\sum_{j=1}^{N_{blocks}} \\sum_{k=1}^{3} |V_{obs,varied}^{(j,k)} - V_{sim,varied}^{(j,k)}|\n\\end{aligned}\n\\tag{2}\\]\n\nThe final component of our ABC implementation is the determination of an appropriate value of \\(\\epsilon\\). The setting of \\(\\epsilon\\) exerts strong influence on the approximated posterior distribution. Smaller values of \\(\\epsilon\\) increase the rejection rate, and improve the fidelity of the approximated posterior, while larger values result in an ABC sampler that simply reproduces the prior distribution. Because the individual participants in our dataset differed substantially in terms of the noisiness of their data, we employed an adaptive tolerance setting strategy to tailor \\(\\epsilon\\) to each individual. The initial value of \\(\\epsilon\\) was set to the overall standard deviation of each individuals velocity values. Thus, sampled parameter values that generated simulated data within a standard deviation of the observed data were accepted, while worse performing parameters were rejected. After every 300 samples the tolerance was allowed to increase only if the current acceptance rate of the algorithm was less than 1%. In such cases, the tolerance was shifted towards the average discrepancy of the 5 best samples obtained thus far. To ensure the acceptance rate did not become overly permissive, \\(\\epsilon\\) was also allowed to decrease every time a sample was accepted into the posterior.\n\n\n\nFor each of the 156 participants from Experiment 1, the ABC algorithm was run until 200 samples of parameters were accepted into the posterior distribution. Obtaining this number of posterior samples required an average of 205,000 simulation runs per participant. Fitting each combination of participant, Model (EXAM & ALM), and fitting method (Test only, Train only, Test & Train) required a total of 192 million simulation runs. To facilitate these intensive computational demands, we used the Future Package in R (Bengtsson, 2021), allowing us to parallelize computations across a cluster of ten M1 iMacs, each with 8 cores.\n\nModelling Results\n\nGroup level Patterns\n\n\nCode\npost_tabs &lt;- abc_tables(post_dat,post_dat_l)\ntrain_tab &lt;- abc_train_tables(pd_train,pd_train_l)\n\ne1_tab &lt;- rbind(post_tabs$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Test\"), train_tab$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne1_tab %&gt;%\n  group_by(`Task Stage`, Fit_Method, Model, condit) %&gt;%\n  summarize(ME = mean(mean_error), .groups = \"drop\") %&gt;%\n  pivot_wider(\n    names_from = c(Model, condit),\n    values_from = ME,\n    names_sep = \"_\"  # Add this line to specify the separator for column names\n  ) %&gt;%\n  rename(\"Fit Method\" = Fit_Method) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = c(`Task Stage`)) %&gt;%\n  cols_label(\n    `Task Stage` = \"Task Stage\"\n  ) %&gt;%\n  fmt_number(\n    columns = starts_with(\"ALM\") | starts_with(\"EXAM\"),\n    decimals = 2\n  ) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = cell_fill(color = \"white\"),\n     locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_style(\n    style = cell_borders(sides = \"top\", color = \"black\", weight = px(1)),\n    locations = cells_column_labels()\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10, \n    quarto.disable_processing = TRUE\n  ) \n\n\n\n\nTable 13: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      Task Stage\n      Fit Method\n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    Test\nFit to Test Data\n199.93\n103.36\n104.01\n85.68\n    Test\nFit to Test & Training Data\n216.97\n170.28\n127.94\n144.86\n    Test\nFit to Training Data\n467.73\n291.38\n273.30\n297.91\n    Train\nFit to Test Data\n297.82\n2,016.01\n53.90\n184.00\n    Train\nFit to Test & Training Data\n57.40\n132.32\n42.92\n127.90\n    Train\nFit to Training Data\n51.77\n103.48\n51.43\n107.03\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nc_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=log(c), x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.2)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"c parameter\") +\n  theme(legend.title = element_blank(), legend.position=\"right\",plot.title=element_text(hjust=.4))\n\nlr_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=lr, x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.4)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"learning rate parameter\") +\n  theme(legend.title = element_blank(), legend.position = \"none\",plot.title=element_text(hjust=.5))\nc_post + lr_post\n\n\n\n\n\n\n\n\nFigure 16: Posterior Distributions of \\(c\\) and \\(lr\\) parameters. Points represent median values, thicker intervals represent 66% credible intervals and thin intervals represent 95% credible intervals around the median. Note that the y axes of the plots for the c parameter are scaled logarithmically.\n\n\n\n\n\n\n\nCode\ntrain_resid &lt;- pd_train |&gt; group_by(id,condit,Model,Fit_Method, Block,x) |&gt; \n  summarise(y=mean(y), pred=mean(pred), mean_error=abs(y-pred)) |&gt;\n  group_by(id,condit,Model,Fit_Method,Block) |&gt;\n  summarise(mean_error=mean(mean_error)) |&gt;\n  ggplot(aes(x=interaction(Block,Model), y = mean_error, fill=factor(Block))) + \n  stat_bar + \n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, scales=\"free\",ncol=2) +\n   scale_x_discrete(guide = \"axis_nested\") +\n  scale_fill_manual(values=c(\"gray10\",\"gray50\",\"gray92\"))+\n  labs(title=\"Model Residual Errors - Training Stage\", y=\"RMSE\", x= \"Model\",fill=\"Training Block\") +\n  theme(legend.position=\"top\")\n\ntest_resid &lt;-  post_dat |&gt; \n   group_by(id,condit,x,Model,Fit_Method,bandType) |&gt;\n    summarise(y=mean(y), pred=mean(pred), error=abs(y-pred)) |&gt; \n  mutate(vbLab = factor(paste0(x,\"-\",x+200))) |&gt;\n  ggplot(aes(x = Model, y = abs(error), fill=vbLab,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n  #scale_fill_manual(values=wes_palette(\"AsteroidCity2\"))+\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, axes = \"all\",ncol=2,scale=\"free\") +\n  labs(title=\"Model Residual Errors - Testing Stage\",y=\"RMSE\", x=\"Velocity Band\") \n\n(train_resid / test_resid) +\n  #plot_layout(heights=c(1,1.5)) & \n  plot_annotation(tag_levels = list(c('A','B')),tag_suffix = ') ') \n\n\n\n\n\n\n\n\nFigure 17: Model residuals for each combination of training condition, fit method, and model. Residuals reflect the difference between observed and predicted values. Lower values indicate better model fit. Note that y axes are scaled differently between facets. A) Residuals predicting each block of the training data. B) Residuals predicting each band during the testing stage. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\nThe posterior distributions of the \\(c\\) and \\(lr\\) parameters are shown Figure 16, and model predictions are shown alongside the empirical data in Figure 18. There were substantial individual differences in the posteriors of both parameters, with the within-group individual differences generally swamped any between-group or between-model differences. The magnitude of these individual differences remains even if we consider only the single best parameter set for each subject.\nWe used the posterior distribution of \\(c\\) and \\(lr\\) parameters to generate a posterior predictive distribution of the observed data for each participant, which then allows us to compare the empirical data to the full range of predictions from each model. Aggregated residuals are displayed in Figure 17. The pattern of training stage residual errors are unsurprising across the combinations of models and fitting method . Differences in training performance between ALM and EXAM are generally minor (the two models have identical learning mechanisms). The differences in the magnitude of residuals across the three fitting methods are also straightforward, with massive errors for the ‘fit to Test Only’ model, and the smallest errors for the ‘fit to train only’ models. It is also noteworthy that the residual errors are generally larger for the first block of training, which is likely due to the initial values of the ALM weights being unconstrained by whatever initial biases participants tend to bring to the task. Future work may explore the ability of the models to capture more fine grained aspects of the learning trajectories. However for the present purposes, our primary interest is in the ability of ALM and EXAM to account for the testing patterns while being constrained, or not constrained, by the training data. All subsequent analyses and discussion will thus focus on the testing stage.\nThe residuals of the model predictions for the testing stage (Figure 17) also show an unsurprising pattern across fitting methods - with models fit only to the test data showing the best performance, followed by models fit to both training and test data, and with models fit only to the training data showing the worst performance (note that y axes are scaled different between plots). Although EXAM tends to perform better for both Constant and Varied participants (see also Figure 19), the relative advantage of EXAM is generally larger for the Constant group - a pattern consistent across all three fitting methods. The primary predictive difference between ALM and EXAM is made clear in Figure 18, which directly compares the observed data against the posterior predictive distributions for both models. Regardless of how the models are fit, only EXAM can capture the pattern where participants are able to discriminate all 6 target bands.\n\n\nCode\npost_dat_l |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; \n #left_join(testAvgE1, by=join_by(id,condit,x==bandInt)) |&gt;\n ggplot(aes(x=Resp,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n    facet_wrap(~rename_fm(Fit_Method)+condit, ncol=2,strip.position = \"top\", scales = \"free_x\") +\n        scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n         strip.background = element_blank(),\n         strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(10,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions - Experiment 1 Data\", y=\"Vx\")\n\n\n\n\n\n\n\n\nFigure 18: Empirical data and Model predictions for mean velocity across target bands. Fitting methods (Test Only, Test & Train, Train Only) - are separated across rows, and Training Condition (Constant vs. Varied) are separated by columns. Each facet contains the predictions of ALM and EXAM, alongside the observed data.\n\n\n\n\n\n\n\nCode\npdl &lt;- post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; left_join(testAvgE1,by=c(\"id\",\"condit\",\"bandInt\")) |&gt; \n  filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\n# aerror is model error, which is predicted by Model(ALM vs. EXAM) & condit (Constant vs. Varied)\ne1_ee_brm_ae &lt;- brm(data=pdl,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e1_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbct_e1 &lt;- as.data.frame(bayestestR::describe_posterior(e1_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n\np1 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\np2 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \np_ce_1 &lt;- (p1 + p2+ p3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\nbm1 &lt;- get_coef_details(e1_ee_brm_ae, \"conditVaried\")\nbm2 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM\")\nbm3 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nposterior_estimates &lt;- as.data.frame(e1_ee_brm_ae) %&gt;%\n  select(starts_with(\"b_\")) %&gt;%\n  setNames(c(\"Intercept\", \"ModelEXAM\", \"conditVaried\", \"ModelEXAM_conditVaried\"))\n\nconstant_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM\nvaried_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM + posterior_estimates$conditVaried + posterior_estimates$ModelEXAM_conditVaried\ncomparison_EXAM &lt;- constant_EXAM - varied_EXAM\nsummary_EXAM &lt;- bayestestR::describe_posterior(comparison_EXAM, centrality = \"Mean\")\n\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NULL)\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NA)\n\n# full set of Model x condit contrasts\n# ALM - EXAM\nbtw_model &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model | condit, re_formula=NULL)  |&gt; \n  pluck(\"contrasts\") |&gt; \n  gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw,condit) |&gt; summarise(value=mean(.value), n=n()) \n\n# btw_model |&gt; ggplot(aes(x=value,y=contrast,fill=condit)) +stat_halfeye()\n\n# Constant - Varied\nemm_condit &lt;- e1_ee_brm_ae |&gt; emmeans(~ condit | Model, re_formula = NULL)\nbtw_con &lt;- emm_condit |&gt;  pairs() |&gt; gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw, Model) |&gt; summarise(value=mean(.value), n=n()) \n# btw_con |&gt; ggplot(aes(x=value,y=Model,fill=Model)) +stat_halfeye()                              \n\np_em_1&lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model*condit, re_formula=NA)  |&gt; \n  pluck(\"contrasts\") |&gt;\n  gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw) |&gt; summarise(value=mean(.value), n=n()) |&gt; \n  filter(!(contrast %in% c(\"ALM Constant - EXAM Constant\",\"ALM Constant - EXAM Varied\",\"ALM Varied - EXAM Varied \", \"EXAM Constant - ALM Varied\" ))) |&gt; \n  ggplot(aes(x=value,y=contrast,fill=contrast)) +stat_halfeye() + labs(x=\"Model Error Difference\",y=\"Contrast\") + theme(legend.position=\"none\") \n\np_ce_1 / p_em_1\n\n\n\n\n\n\n\n\nFigure 19\n\n\n\n\n\nTo quantitatively assess whether the differences in performance between models, we fit a bayesian regressions predicting the errors of the posterior predictions of each models as a function of the Model (ALM vs. EXAM) and training condition (Constant vs. Varied).\nModel errors were significantly lower for EXAM (\\(\\beta\\) = -37.54, 95% CrI [-60.4, -14.17], pd = 99.85%) than ALM. There was also a significant interaction between Model and Condition (\\(\\beta\\) = 60.42, 95% CrI [36.17, 83.85], pd = 100%), indicating that the advantage of EXAM over ALM was significantly greater for the constant group. To assess whether EXAM predicts constant performance significantly better for Constant than for Varied subjects, we calculated the difference in model error between the Constant and Varied conditions specifically for EXAM. The results indicated that the model error for EXAM was significantly lower in the Constant condition compared to the Varied condition, with a mean difference of -22.88 (95% CrI [-46.02, -0.97], pd = 0.98).\n\n\nCode\npost_tabs2 &lt;- abc_tables(e2_model$post_dat,e2_model$post_dat_l)\ntrain_tab2 &lt;- abc_train_tables(e2_model$pd_train,e2_model$pd_train_l)\n\npdl2 &lt;- e2_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne2_tab &lt;- rbind(post_tabs2$agg_pred_full |&gt;\n mutate(\"Task Stage\"=\"Test\"), train_tab2$agg_pred_full |&gt; \n mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\npost_tabs3 &lt;- abc_tables(e3_model$post_dat,e3_model$post_dat_l)\ntrain_tab3 &lt;- abc_train_tables(e3_model$pd_train,e3_model$pd_train_l)\n\npdl3 &lt;- e3_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne3_tab &lt;- rbind(post_tabs3$agg_pred_full |&gt; \n  mutate(\"Task Stage\"=\"Test\"), train_tab3$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne23_tab &lt;- rbind(e2_tab |&gt; mutate(Exp=\"E2\"), e3_tab |&gt; mutate(Exp=\"E3\")) \ngt_table &lt;- e23_tab %&gt;%\n  pivot_wider(\n    names_from = c(Exp, Model, condit),\n    values_from = mean_error,\n    names_glue = \"{Exp}_{Model}_{condit}\"\n  ) %&gt;%\n  arrange(Fit_Method, `Task Stage`) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = `Task Stage`) %&gt;%\n  cols_label(`Task Stage` = \"Task Stage\") %&gt;%\n  fmt_number(columns = matches(\"E2|E3\"), decimals = 1) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = list(\n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10,\n    quarto.disable_processing = TRUE\n  ) \ngt_table\n\n\n\n\nTable 14: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      \n      \n        E2\n      \n      \n        E3\n      \n    \n    \n      Task Stage\n      \n        ALM\n      \n      \n        EXAM\n      \n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    \n      Fit to Test Data\n    \n    Test\n239.7\n129.8\n99.7\n88.2\n170.1\n106.1\n92.3\n72.8\n    Train\n53.1\n527.1\n108.1\n169.3\n70.9\n543.5\n157.8\n212.7\n    \n      Fit to Test & Training Data\n    \n    Test\n266.0\n208.2\n125.1\n126.4\n197.7\n189.5\n130.0\n128.5\n    Train\n40.0\n35.4\n30.4\n23.6\n49.1\n85.6\n49.2\n78.4\n    \n      Fit to Training Data\n    \n    Test\n357.4\n295.9\n305.1\n234.5\n415.0\n298.8\n295.5\n243.7\n    Train\n42.5\n23.0\n43.2\n22.6\n51.4\n63.8\n51.8\n65.3\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nrbind(e2_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\"), \n e3_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb,bandOrder) |&gt;\n  summarize(vx=median(val)) |&gt; mutate(Exp=\"E3\")) |&gt;\n  ggplot( aes(x=condit,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) +\n  stat_bar + \n    facet_nested_wrap(~Exp+bandOrder+Resp, strip.position = \"top\", scales = \"free_x\") +\n    scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .7), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n        #  strip.background = element_blank(),\n        #  strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(20,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions Experiment 2 & 3\", y=\"vx\")\n\n\n\n\n\n\n\n\nFigure 20: Empirical data and Model predictions from Experiment 2 and 3 for the testing stage. Observed data is shown on the right. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\n\n\nCode\ne2_ee_brm_ae &lt;- brm(data=pdl2,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e2_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"conditVaried\")\nbm2_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM\")\nbm3_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nbct_e2 &lt;- as.data.frame(bayestestR::describe_posterior(e2_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) # %&gt;% kable(booktabs = TRUE)\n\ne3_ee_brm_ae &lt;- brm(data=pdl3,\n  aerror ~  Model * condit*bandOrder + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e3_ae_modelCondBo_RFint2.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e3 &lt;- get_coef_details(e3_ee_brm_ae, \"conditVaried\")\nbm2_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM\")\nbm3_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried\")\nbm4_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried:bandOrderReverse\")\n\n\nbct_e3  &lt;- as.data.frame(bayestestR::describe_posterior(e3_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\nbct &lt;- rbind(bct_e1 |&gt; mutate(exp=\"Exp 1\"),bct_e2 |&gt; \n               mutate(exp= \"Exp 2\"),bct_e3 |&gt; mutate(exp=\"Exp 3\")) |&gt; \n  relocate(exp, .before=Term)\n\nbct_table &lt;- bct %&gt;%\n  mutate(\n    across(c(Estimate, `95% CrI Lower`, `95% CrI Upper`), ~ round(., 2)),\n    pd = round(pd, 2)\n  ) %&gt;%\n  gt() %&gt;%\n  # tab_header(\n  #   title = \"Bayesian Model Results\",\n  #   subtitle = \"Estimates and Credible Intervals for Each Term Across Experiments\"\n  # ) %&gt;%\n  cols_label(\n    exp = \"Experiment\",\n    Term = \"Term\",\n    Estimate = \"Estimate\",\n    `95% CrI Lower` = \"95% CrI Lower\",\n    `95% CrI Upper` = \"95% CrI Upper\",\n    pd = \"pd\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(Estimate, `95% CrI Lower`, `95% CrI Upper`),\n    decimals = 2\n  ) %&gt;%\n  fmt_number(\n    columns = pd,\n    decimals = 2\n  ) %&gt;%\n  tab_spanner(\n    label = \"Credible Interval\",\n    columns = c(`95% CrI Lower`, `95% CrI Upper`)\n  ) %&gt;%\n  tab_style(\n    style = list(\n      #cell_fill(color = \"lightgray\"),\n      cell_text(weight = \"bold\"), \n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(\n      columns = c(Estimate, pd),\n      rows = Term==\"ModelEXAM:conditVaried\"\n    )\n  ) %&gt;%\n   tab_row_group(\n    label = \"Experiment 3\",\n    rows = exp == \"Exp 3\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 2\",\n    rows = exp == \"Exp 2\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 1\",\n    rows = exp == \"Exp 1\"\n  ) %&gt;%\n  tab_options(\n    table.font.size = 10,\n    heading.title.font.size = 16,\n    heading.subtitle.font.size = 14,\n    quarto.disable_processing = TRUE\n    #row_group.background.color = \"gray95\"\n  )\nbct_table\n\n\n\n\nTable 15: Results of Bayesian Regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and the interaction between Model and Condition. The values represent the estimate coefficient for each term, with 95% credible intervals in brackets. The intercept reflects the baseline of ALM and Constant. The other estimates indicate deviations from the baseline for the EXAM mode and varied condition. Lower values indicate better model fit.\n\n\n\n\n\n\n  \n    \n      Experiment\n      Term\n      Estimate\n      \n        Credible Interval\n      \n      pd\n    \n    \n      95% CrI Lower\n      95% CrI Upper\n    \n  \n  \n    \n      Experiment 1\n    \n    Exp 1\nIntercept\n176.30\n156.86\n194.59\n1.00\n    Exp 1\nModelEXAM\n−88.44\n−104.51\n−71.81\n1.00\n    Exp 1\nconditVaried\n−37.54\n−60.40\n−14.17\n1.00\n    Exp 1\nModelEXAM:conditVaried\n60.42\n36.17\n83.85\n1.00\n    \n      Experiment 2\n    \n    Exp 2\nIntercept\n245.87\n226.18\n264.52\n1.00\n    Exp 2\nModelEXAM\n−137.73\n−160.20\n−115.48\n1.00\n    Exp 2\nconditVaried\n−86.39\n−113.52\n−59.31\n1.00\n    Exp 2\nModelEXAM:conditVaried\n56.87\n25.26\n88.04\n1.00\n    \n      Experiment 3\n    \n    Exp 3\nIntercept\n164.83\n140.05\n189.44\n1.00\n    Exp 3\nModelEXAM\n−65.66\n−85.97\n−46.02\n1.00\n    Exp 3\nconditVaried\n−40.61\n−75.90\n−3.02\n0.98\n    Exp 3\nbandOrderReverse\n25.47\n−9.34\n58.68\n0.93\n    Exp 3\nModelEXAM:conditVaried\n41.90\n11.20\n72.54\n0.99\n    Exp 3\nModelEXAM:bandOrderReverse\n−7.32\n−34.53\n21.05\n0.70\n    Exp 3\nconditVaried:bandOrderReverse\n30.82\n−19.57\n83.56\n0.88\n    Exp 3\nModelEXAM:conditVaried:bandOrderReverse\n−60.60\n−101.80\n−18.66\n1.00\n  \n  \n  \n\n\n\n\n\n\n\nModel Fits to Experiment 2 and 3. Data from Experiments 2 and 3 were fit to ALM and EXAM in the same manner as Experiment1 . For brevity, we only plot and discuss the results of the “fit to training and testing data” models - results from the other fitting methods can be found in the appendix. The model fitting results for Experiments 2 and 3 closely mirrored those observed in Experiment 1. The Bayesian regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and their interaction (see Table 15) revealed a consistent main effect of Model across all three experiments. The negative coefficients for the ModelEXAM term (Exp 2: \\(\\beta\\) = -86.39, 95% CrI -113.52, -59.31, pd = 100%; Exp 3: \\(\\beta\\) = -40.61, 95% CrI -75.9, -3.02, pd = 98.17%) indicate that EXAM outperformed ALM in both experiments. Furthermore, the interaction between Model and Condition was significant in both Experiment 2 (\\(\\beta\\) = 56.87, 95% CrI 25.26, 88.04, pd = 99.98%) and Experiment 3 (\\(\\beta\\) = 41.9, 95% CrI 11.2, 72.54, pd = 99.35%), suggesting that the superiority of EXAM over ALM was more pronounced for the Constant group compared to the Varied group, as was the case in Experiment 1. Recall that Experiment 3 included participants in both the original and reverse order conditions - and that this manipulation interacted with the effect of training condition. We thus also controleld for band order in our Bayesian Regression assessing the relative performance of EXAM and ALM in Experiment 3. There was a significant three way interaction between Model, Training Condition, and Band Order (\\(\\beta\\) = -60.6, 95% CrI -101.8, -18.66, pd = 99.83%), indicating that the relative advantage of EXAM over ALM was only more pronounced in the original order condition, and not the reverse order condition (see Figure 21).\n\n\nCode\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\np1 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\") + labs(title=\"E2. Model Error\")\np2 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n p_e2 &lt;- (p1 + p2+ p3) \n#wrap_plots(plot(conditional_effects(e3_ee_brm_ae),points=FALSE,plot=FALSE))\n\np_e3 &lt;- plot(conditional_effects(e3_ee_brm_ae, \n                         effects = \"Model:condit\", \n                         conditions=make_conditions(e3_ee_brm_ae,vars=c(\"bandOrder\"))),\n     points=FALSE,plot=FALSE)$`Model:condit` + \n     labs(x=\"Model\",y=\"Model Error\", title=\"E3. Model Error\", fill=NULL, col=NULL) + \n     theme(legend.position=\"right\") + \n     scale_color_manual(values=wes_palette(\"Darjeeling1\")) \n\n# p1 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n#   ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\n# p2 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n#   labs(x=\"Model\",y=NULL)\n# p3 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n#   scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n#   labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n #p2 &lt;- (p1 + p2+ p3)\n (p_e2 / p_e3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\n\n\n\n\n\n\nFigure 21: Conditional effects of Model (ALM vs EXAM) and Condition (Constant vs. Varied) on Model Error for Experiment 2 and 3 data. Experiment 3 also includes a control for the order of training vs. testing bands (original order vs. reverse order).\n\n\n\n\n\nComputational Model Summary. Across the model fits to all three experiments, we found greater support for EXAM over ALM (negative coefficients on the ModelEXAM term in Table 15), and moreover that the constant participants were disproportionately well described by EXAM in comparison to ALM (positive coefficients on ModelEXAM:conditVaried terms in Table 15). This pattern is also clearly depicted in Figure 22, which plots the difference in model errors between ALM and EXAM for each individual participant. Both varied and constant conditions have a greater proportion of subjects better fit by EXAM (positive error differences), with the magnitude of EXAM’s advantage visibly greater for the constant group. It also bears mention that numerous participants were better fit by ALM, or did not show a clear preference for either model. A subset of these participants are shown in Figure 23.\n\n\nCode\ntid1 &lt;- post_dat  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-pred_dist, -dist) |&gt;\n  rbind(e2_model$post_dat |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat |&gt; mutate(Exp=\"E3\")) |&gt;\n  filter(Fit_Method==\"Test_Train\") |&gt;\n  group_by(id,condit,Model,Fit_Method,x, Exp) |&gt; \n    mutate(e2=abs(y-pred)) |&gt; \n    summarise(y1=median(y), pred1=median(pred),mean_error=abs(y1-pred1)) |&gt;\n    group_by(id,condit,Model,Fit_Method,Exp) |&gt; \n    summarise(mean_error=mean(mean_error)) |&gt; \n    arrange(id,condit,Fit_Method) |&gt;\n    round_tibble(1) \n\nbest_id &lt;- tid1 |&gt; \n  group_by(id,condit,Fit_Method) |&gt; \n  mutate(best=ifelse(mean_error==min(mean_error),1,0)) \n\nlowest_error_model &lt;- best_id %&gt;%\n  group_by(id, condit,Fit_Method, Exp) %&gt;%\n  summarise(Best_Model = Model[which.min(mean_error)],\n            Lowest_error = min(mean_error),\n            differential = min(mean_error) - max(mean_error)) %&gt;%\n  ungroup()\n\nerror_difference&lt;- best_id %&gt;%\n  select(id, condit, Model,Fit_Method, mean_error) %&gt;%\n  pivot_wider(names_from = Model, values_from = c(mean_error)) %&gt;%\n  mutate(Error_difference = (ALM - EXAM))\n\nfull_comparison &lt;- lowest_error_model |&gt; \n  left_join(error_difference, by=c(\"id\",\"condit\",\"Fit_Method\"))  |&gt; \n  group_by(condit,Fit_Method,Best_Model) |&gt; \n  mutate(nGrp=n(), model_rank = nGrp - rank(Error_difference) ) |&gt; \n  arrange(Fit_Method,-Error_difference)\n\nfull_comparison |&gt; \n  filter(Fit_Method==\"Test_Train\") |&gt; \n  ungroup() |&gt;\n  mutate(id = reorder(id, Error_difference)) %&gt;%\n  ggplot(aes(y=id,x=Error_difference,fill=Best_Model))+\n  geom_col() +\n  #ggh4x::facet_grid2(~condit,axes=\"all\",scales=\"free_y\", independent = \"y\")+\n  ggh4x::facet_nested_wrap(~condit+Exp,scales=\"free\") + \n  theme(axis.text.y = element_text(size=8)) +\n  labs(fill=\"Best Model\",\n  x=\"Mean Model Error Difference (ALM - EXAM)\",\n  y=\"Participant\")\n\n\n\n\n\n\n\n\nFigure 22: Difference in model errors for each participant, with models fit to both train and test data. Positive values favor EXAM, while negative values favor ALM.\n\n\n\n\n\n\n\nCode\ncId_tr &lt;- c(137, 181, 11)\nvId_tr &lt;- c(14, 193, 47)\ncId_tt &lt;- c(11, 93, 35)\nvId_tt &lt;- c(1,14,74)\ncId_new &lt;- c(175, 68, 93, 74)\n# filter(id %in% (filter(bestTestEXAM,group_rank&lt;=9, Fit_Method==\"Test\")\n\ne1_sbjs &lt;- c(49,68,155, 175,74)\ne3_sbjs &lt;-  c(245, 280, 249)\ne2_sbjs &lt;- c(197, 157, 312, 334)\ncFinal &lt;- c(49, 128,202 )\nvFinal &lt;- c(68,70,245)\n\n\nindv_post_l &lt;- post_dat_l  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-signed_dist) |&gt;\n  rbind(e2_model$post_dat_l |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat_l |&gt; mutate(Exp=\"E3\") |&gt; select(-fb)) |&gt;\n  filter(Fit_Method==\"Test_Train\", id %in% c(cFinal,vFinal))\n\ntestIndv &lt;- indv_post_l |&gt; \n#filter(id %in% c(cId_tt,vId_tt,cId_new), Fit_Method==\"Test_Train\") |&gt; \n   mutate(x=as.factor(x), Resp=as.factor(Resp)) |&gt;\n  group_by(id,condit,Fit_Method,Model,Resp) |&gt;\n   mutate(flab=paste0(\"Subject: \",id)) |&gt;\n  ggplot(aes(x = Resp, y = val, fill=vb, col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar_sd + \n  ggh4x::facet_nested_wrap(condit~flab, axes = \"all\",ncol=3) +\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = FALSE) +\n  scale_size_manual(values = c(\"black\" = .5), guide = FALSE) + \n  labs(title=\"Individual Participant fits from Test & Train Fitting Method\",\n       y=\"X Velocity\",fill=\"Target Velocity\") +\n   guides(fill = guide_legend(nrow = 1)) + \n  theme(legend.position = \"bottom\",axis.title.x = element_blank())\n\ntestIndv \n\n\n\n\n\n\n\n\nFigure 23: Model predictions alongside observed data for a subset of individual participants. A) 3 constant and 3 varied participants fit to both the test and training data. B) 3 constant and 3 varied subjects fit to only the trainign data. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/HTW.html#comparison-to-project-1",
    "href": "Sections/HTW.html#comparison-to-project-1",
    "title": "HTW Project",
    "section": "Comparison to Project 1",
    "text": "Comparison to Project 1\n\nDifferences between the tasks\nThere are a number of differences between Project 1’s Hit The Target (HTT), and Project 2’s Hit The Wall (HTW) tasks.\n\nTask Space Complexity: In HTW, the task space is also almost perfectly smooth, at least for the continuous feedback subjects, if they throw 100 units too hard, they’ll be told that they were 100 units too hard. Whereas in HTT,  it was possible to produce xy velocity combinations that were technically closer to the empirical solution space than other throws, but which resulted in worse feedback due to striking the barrier.\nPerceptual Distinctiveness: HTT offers perceptually distinct varied conditions that directly relate to the task’s demands, which may increase the sallience between training positions encounted by the varied group. In contrast, HTW’s varied conditions differ only in the numerical values displayed, lacking the same level of perceptual differentiation. Conversely in HTW, the only difference between conditions for the varied group are the numbers displayed at the top of the screen which indicate the current target band(e.g. 800-1000, or 1000-1200)\nIn HTW, our primary testing stage of interest has no feedback, whereas in HTT testing always included feedback (the intermittent testing in HTT expt 1 being the only exception). Of course, we do collect testing with feedback data at the end of HTW, but we haven’t focused on that data at all in our modelling work thus far. It’s also interesting to recall that the gap between varied and constant in HTW does seem to close substantially in the testing-with-feedback stage. The difference between no-feedback and feedback testing might be relevant if the benefits of variation have anything to do with improving subsequent learning (as opposed to subsequent immediate performance), OR if the benefits of constant training rely on having the most useful anchor, having the most useful anchor might be a lot less helpful if you’re getting feedback from novel positions and can thus immediately begin to form position-specific anchors for the novelties, rather than relying on a training anchor. \nHTW and HTT both have a similar amount of training trials (~200), and thus the constant groups acquire a similar amount of experience with their single position/velocity in both experiments. However, the varied conditions in both HTT experiments train on 2 positions, whereas the varied group in HTW trains on 3 velocity bands. This means that in HTT the varied group gets half as much experience on any one position as the constant group, and in HTW they only get 1/3 as much experience in any one position. There are likely myriad ways in which this might impact the success of the varied group regardless of how you think the benefits of variation might be occurring, e.g. maybe they also need to develop a coherent anchor, maybe they need more experience in order to extract a function, or more experience in order to properly learn to tune their c parameter.",
    "crumbs": [
      "HTW Project"
    ]
  },
  {
    "objectID": "Sections/full.html",
    "href": "Sections/full.html",
    "title": "Full Dissertation",
    "section": "",
    "text": "The factors that influence the generalization of learning are of considerable interest to both researchers exploring the human learning system and practitioners aiming to enhance the effectiveness of educational and training interventions. The present effort will focus specifically on the role of variability in the learning input. Variability manipulations typically regulate either the number of distinct instances presented to learners during training, or the dispersion of these instances. Such manipulations have been empirically demonstrated to affect subsequent generalization performance. This essay will offer an in-depth review of the extant literature on the influence of variability, spanning multiple relevant domains.\n\n\nStudies investigating the “benefits of variability” hypothesis usually assign participants to either a constant or varied group for the training stage of the experiment. Then, subjects in both groups complete an identical testing stage which often consists items/conditions seen during training, and novel items/conditions. If the varied group performs better in the testing stage, this is taken for evidence of the benefits of variability hypothesis. Even within this relatively straightforward between-groups design, researchers must navigate several crucial methodological choices, highlighted below:\n\nVariables Subject to Variation. In multidimensional tasks, researchers have the option to vary numerous variables. The experimenters must decide the specific dimension(s) across which variation will occur. For instance, in a projectile throwing accuracy task – researchers might vary the distance from the target, the size of the target, the weight of the projectile. They might also vary a contextual variable not directly relevant to the task, but which will still be encoded by the subject on a trial by trial basis, e.g. the background color.\nMagnitude of Variation, relative to the control condition. The simplest comparison would be to compare a constant group who trains with 1 example/condition, against a varied group that trains from 2 examples/conditions. However, it is not uncommon in the literature for the varied condition to train from 3 or 4 conditions. For example, Catalano & Kleiner (1984) train varied subjects from 4 different velocities in their coincident timing task, and (Goode et al., 2008) have varied subjects’ practice with 3 different variants (i.e. different letter scrambles of the same word) of an anagram for a given word, while their constant participants view the same variant 3 different times. Alternatively, rather than a constant vs. varied comparison, subjects in all conditions might experience a variety of training items, but with one group experiencing a greater number of unique items (Nosofsky, Sanders, Zhu, et al., 2018).\nLocations within Task-Space. For tasks in which the stimuli or conditions fall within a continuous metric space, the experimenter must decide whether the varied instances are relatively close together (e.g. throwing a ball from a distance of 4 feet and 5 feet), or far apart (throwing from 4 feet and 20 feet). Spreading the varied training items further apart may be beneficial in terms of providing a more representative sample of the task space to the learner, however large distances may also result in significant differences in difficulty between the training examples, which can be a common confound in variability studies.\nProximity of Testing to Training Conditions. Intuitively, the fairest form of comparison is to include testing conditions that are of an equivalent distance from both the varied and constant groups. However researchers might also attempt to demonstrate the benefits of variation as being sufficiently powerful to outperform constant training, even in cases where the constant group trained from a closer proximity to the testing conditions, or whose training conditions are identical to the testing conditions (Goode et al., 2008; Kerr & Booth, 1978).\n\n\n\n\nAn early and influential work on the influence of variability on category learning is that of Posner & Keele (1968). In an ambitious attempt to address the question of how category information is represented, the authors trained participants to categorize artificial dot patterns, manipulating whether learners were exposed to examples clustered close to the category prototypes (e.g. a low variability condition), or spread further away from the prototype (the varied-training group). It should be noted that both groups in this study were trained with the same number of unique instances and the manipulated difference was how spread out the instances were. The authors claim based on prior experiments using the same stimuli, that the training stimuli for the varied group were at least as far away from the testing stimuli as the training stimuli of the less-varied group. The authors interpreted their findings as evidence for the extraction of an abstraction or schema that is extracted and stored, and then over time becomes more likely to be the reference point from which generalization occurs, given that specific instances are thought to decay at a faster rate than prototypes or schema. The Posner and Keele study has been extremely influential and continues to be cited in contemporary research as clear evidence that schema abstraction underlies the benefits of varied training. It’s also referenced as a key influence in the development of “Schema Theory of Motor Learning” (Schmidt, 1975), which in turn influenced decades of investigations on the potential benefits of varied training in motor skill learning. However, the classic Posner & Keele study despite being far more carefully designed than many subsequent studies, and despite being a relative rarity in explicitly discussing and attempting to control for potential confounds of similarity between groups, may nevertheless be emblematic of a common issue in many investigations of the effects of varied training on learning. The problem with Posner & Keele’s conclusion was demonstrated clearly almost 3 decades later (Palmeri & Nosofsky, 2001), when researchers conducting a near replication of the original study also collected similarity judgements following training and performed multidimensional scaling analysis. Rather than being in the middle of the training stimuli as was the case in the physical stimuli space, the psychological representation of the prototype was shown reside at an extreme point, and generalization patterns by participants that would have seemed to warrant the learning of a prototype were then easily accounted for with only the assumption that the participants encoded instances. One of the primary concerns of the present paper is that many of the studies which purport to explain the benefits of variation via prototypes, schemas, or other abstractions, are often overlooking the potential of instance based similarity accounts.\n\n\n\nTraining variation has also been shown to promote transfer in motor learning. Much of this research has been influenced by the work of (Schmidt, 1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. Schema theory presumes a priori that learners possess general motor programs for classes of movements, such as an underhand throw. When called up for use, such programs must be parameterized, as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class, such as an underhand throw (though it is agnostic to the development of the movement classes themselves). Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices with multiple instances along some task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations.\nOne of the earliest, and still often cited investigations of Schmidt’s benefits of variability hypothesis was the work of Kerr & Booth (1978). Two groups of children, aged 8 and 12, were assigned to either constant or varied training of a bean bag throwing task. The constant group practiced throwing a bean-bag at a small target placed 3 feet in front of them, and the varied group practiced throwing from a distance of both 2 feet and 4 feet. Participants were blindfolded and unable to see the target while making each throw but would receive feedback by looking at where the beanbag had landed in between each training trial. 12 weeks later, all of the children were given a final test from a distance of 3 feet which was novel for the varied participants and repeated for the constant participants. Participants were also blindfolded for testing and did not receive trial by trial feedback in this stage. However, at the halfway point of the testing stage they were allowed to see the landing location of the 4 beanbags they had thrown, and then completed the final 4 testing throws. In both age groups, participants performed significantly better in the varied condition than the constant condition, though the effect was larger for the younger, 8-year-old children. Although this design does not directly assess the hypothesis of varied training producing superior generalization to constant training (since the constant group is not tested from a novel position), it nevertheless offers a compelling example of the merits of varied practice.\nOn occasion the Kerr and Booth design may be nested within a larger experimental design. One such study that used a movement timing task, wherein subjects had to move their hand from a starting location, to a target location, attempting to arrive at the target location at specific time following the onset of a cue (Wrisberg et al., 1987). This study utilized 4 different constant groups, and 3 varied groups, with one of the constant groups training under conditions identical to the testing conditions, and which were not trained on by any of the varied groups, e.g. the design of Kerr and Booth. However, in this case the varied group did not outperform the constant group. A more recent study attempting a slightly more direct replication of the original Kerr & Booth study (Willey & Liu, 2018b), having subjects throw beanbags at a target, with the varied group training from positions (5 and 9 feet) on either side of the constant group (7 feet). However, this study diverged from the original in that the participants were adults; they faced away from the target and threw the beanbag backwards over their bodies; they alternated using their right and left hands every 6 trials; and underwent a relatively extreme amount of training (20 sessions with 60 practice trials each, spread out over 5-7 weeks). Like Wrisberg et al. (1987), this study did not find a varied advantage from the constant training position, though the varied group did perform better at distances novel to both groups.\nSome support for the Kerr and Booth findings was found with a relatively less common experimental task of training participants in hitting a projectile at a target with the use of a racket (Green et al., 1995). Varied participants trained with tennis, squash, badminton, and short-tennis rackets were compared against constant subjects trained with only a tennis racket. One of the testing conditions had subjects repeat the use of the tennis racket, which had been used on all 128 training trials for the constant group, and only 32 training trials for the varied group. Nevertheless, the varied group outperformed the constant group when using the tennis racket at testing, and also performed better in conditions with several novel racket lengths. Of course, this finding is less surprising than that of Kerr & Booth, given that varied subjects did have some prior exposure to the constant groups condition. This highlights an issue rarely discussed in the literature, of how much practice from an additional position might be necessary to induce benefits. Experimenters almost uniformly have varied participants train with an equivalent number of trials from each of their conditions\nOne of the few studies that has replicated the surprising result of varied outperforming constant, from the constant training condition, did so in the relatively distant domain of verbal manipulation (Goode et al., 2008). All participants trained to solve anagrams of 40 different words ranging in length from 5 to 11 letters, with an anagram of each word repeated 3 times throughout training, for a total of 120 training trials. Although subjects in all conditions were exposed to the same 40 unique words (i.e. the solution to an anagram), participants in the varied group saw 3 different arrangements for each solution-word, such as DOLOF, FOLOD, and OOFLD for the solution word FLOOD, whereas constant subjects would train on three repetitions of LDOOF (spread evenly across training). Two different constant groups were used. Both constant groups trained with three repetitions of the same word scramble, but for constant group A, the testing phase consisted of the identical letter arrangement to that seen during training (e.g. LDOOF), whereas for constant group B, the testing phase consisted of a arrangement they had not seen during training, thus presenting them with a testing situation similar situation to the varied group. At the testing stage, the varied group outperformed both constant groups, a particularly impressive result, given that constant group A had 3 prior exposures to the word arrangement (i.e. the particular permutation of letters) which the varied group had not explicitly seen. However varied subjects in this study did not exhibit the typical decrement in the training phase typical of other varied manipulations in the literature, and actually achieved higher levels of anagram solving accuracy by the end of training than either of the constant groups – solving 2 more anagrams on average than the constant group. This might suggest that for tasks of this nature where the learner can simply get stuck with a particular word scramble, repeated exposure to the identical scramble might be less helpful towards finding the solution than being given a different arrangement of the same letters. This contention is supported by the fact that constant group A, who was tested on the identical arrangement as they experienced during training, performed no better at testing than did constant group B, who had trained on a different arrangement of the same word solution – further suggesting that there may not have been a strong identity advantage in this task.\nPitting varied against constant practice against each other on the home turf of the constant group provides a compelling argument for the benefits of varied training, as well as an interesting challenge for theoretical accounts that posit generalization to occur as some function of distance. However, despite its appeal this particular contrast is relatively uncommon in the literature. It is unclear whether this may be cause for concern over publication bias, or just researchers feeling the design is too risky. A far more common design is to have separate constant groups that each train exclusively from each of the conditions that the varied group encounters (Catalano & Kleiner, 1984; Chua et al., 2019; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976), or for a single constant group to train from just one of the conditions experienced by the varied participants (Pigott & Shapiro, 1984; Roller et al., 2001; Wrisberg & McLean, 1984; Wrisberg & Mead, 1983). A less common contrast places the constant group training in a region of the task space outside of the range of examples experienced by the varied group, but distinct from the transfer condition (Wrisberg et al., 1987; Wulf & Schmidt, 1997).\nOf particular relevant to the current essay is the early work of Catalano & Kleiner (1984), as theirs was one of the earliest studies to investigate the influence of varied vs. constant training on multiple testing locations of graded distance from the training condition. Participants were trained on coincident timing task, in which subjects observe a series of lightbulbs turning on sequentially at a consistent rate and attempt to time a button response with the onset of the final bulb. The constant groups trained with a single velocity of either 5,7,9, or 11 mph, while the varied group trained from all 4 of these velocities. Participants were then assigned to one of four possible generalization conditions, all of which fell outside of the range of the varied training conditions – 1, 3, 13 or 15 mph. As is often the case, the varied group performed worse during the training phase. In the testing phase, the general pattern was for all participants to perform worse as the testing conditions became further away from the training conditions, but since the drop off in performance as a function of distance was far less steep for the varied group, the authors suggested that varied training induced a decremented generalization gradient, such that the varied participants were less affected by the change between training and testing conditions.\n\n\n\nIn the category learning literature, the constant vs. varied comparison is much less suitable. Instead, researchers tend to compare a condition with many repetitions of a few items against condition with fewer repetitions of a wider array of exemplars. Much of the earlier work in this sub-area trained subjects on artificial categories, such as dot patterns (Homa & Vosburgh, 1976; Posner & Keele, 1968), where more varied or distorted training examples were often shown to produce superior generalization when categorizing novel exemplars. More recently, researchers have also begun to utilize more realistic stimuli in their experiments. Wahlheim et al. (2012) conducted one such study. In a within-participants design, participants were trained on bird categories with either high repetitions of a few exemplars, or few repetitions of many exemplars. Across four different experiments, which were conducted to address an unrelated question on metacognitive judgements, the researchers consistently found that participants generalized better to novel species following training with more unique exemplars (i.e. higher variability), while high repetition training produced significantly better performance categorizing the specific species they had trained on. A variability advantage was also found in the relatively complex domain of rock categorization (Nosofsky, Sanders, & McDaniel, 2018). For 10 different rock categories, participants were trained with either many repetitions of 3 unique examples of each category, or few repetitions of 9 unique examples, with an equal number of total training trials in each group (the design also included 2 other conditions less amenable to considering the impact of variation). The high-variability group, trained with 9 unique examples, showed significantly better generalization performance than the other conditions. Moreover, the pattern of results in this study could be nicely accounted for by an extended version of the Generalized Context Model.\nThe studies described thus far have studied the benefits of variability by exposing participants to a greater or lesser number of distinct examples during training. A distinct sub-literature within the category learning domain has focused much less on benefits derived from varied training, instead emphasizing how increased variability during the learning of a novel category influences how far the category boundary will then be generalized. The general approach is to train participants on examples from two categories, with the examples from one of the categories being more dispersed than the other. Participants are then tested with novel items located within ambiguous regions of the task space which allow the experimenters to assess whether the difference in variability influences how far participants generalize the category boundaries.\nA. L. Cohen et al. (2001) trained subjects on two categories, one with much more variability than the other. In experiment 1, a low variability category composed of 1 instance was compared against a high-variability category of 2 instances in one condition, and 7 instances in another. In experiment 2 both categories were composed of 3 instances, but for the low-variability group the instances were clustered close to each other, whereas the high-variability groups instances were spread much further apart. Participants were tested on an ambiguous novel instance that was located in between the two trained categories. Both experiments provided evidence that participants were much more likely to categorize the novel middle stimulus into a category with greater variation. Moreover, this effect was at odds with the predications of the baseline version of the GCM, thus providing some evidence that training variation may at least sometimes induce effects that cannot be entirely accounted for by exemplar-similarity accounts.\nFurther observations consonant with the results of A. L. Cohen et al. (2001) have since been observed in numerous investigations (Hahn et al., 2005; Hsu & Griffiths, 2010; Perlman et al., 2012; Sakamoto et al., 2008). The results of Sakamoto et al. (2008) are noteworthy. They first reproduced the basic finding of participants being more likely to categorize an unknown middle stimulus into a training category with higher variability. In a second experiment, they held the variability between the two training categories constant and instead manipulated the training sequence, such that the examples of one category appeared in an ordered fashion, with very small changes from one example to the other (the stimuli were lines that varied only in length), whereas examples in the alternate category were shown in a random order and thus included larger jumps in the stimulus space from trial to trial. They found that the middle stimulus was more likely to be categorized into the category that had been learned with a random sequence, which was attributed to an increased perception of variability which resulted from the larger trial to trial discrepancies.\nThe work of Hahn et al. (2005), is also of particular interest to the present discussion. Their experimental design was similar to previous studies, but they included a larger set of testing items which were used to assess generalization both between the two training categories as well as novel items located in the outer edges of the training categories. During generalization testing, participants were given the option to respond with “neither”, in addition to responses to the two training categories. The “neither” response was included to test how far away in the stimulus space participants would continue to categorize novel items as belonging to a trained category. Consistent with prior findings, high-variability training resulted in an increased probability of categorizing items in between the training categories as belong to the high variability category. Additionally, participants trained with higher variability also extended the category boundary further out into the periphery than participants trained with a lower variability category were willing to do. The authors then used the standard GCM framework to compare a variety of similarity-based models to account for their results. Of particular interest are their evaluations of a category response bias parameter, and a similarity scaling parameter. A model fit improvement when the response bias parameter is allowed to vary between the high-variability and low-variability trained groups is taken to suggest a simple bias for responding with one of the trained categories over the other. Alternatively, an improvement in fit due to a separate similarity scaling parameter may reflect the groups being differentially sensitive to the distances between stimuli. No improvement in model fit was found by allowing the response-bias parameter to differ between groups, however the model performance did improvement significantly when the similarity scaling parameter was fit separately. The best fitting similarity-scaling parameters were such that the high-variability group was less sensitive to the distances between stimuli, resulting in greater similarity values between their training items and testing items. This model accounted for both the extended generalization gradients of the varied particpants, and also for their poor performance in a recognition condition. Additional model comparisons suggested that this similarity rescaling applied across the entire stimulus space, rather than to the high variability category in particular.\nVariability effects have also been examined in the higher-level domain of how learners acquire novel concepts, and then instantiate (rather than merely recognize) that concept in untrained contexts (Braithwaite & Goldstone, 2015). This study trained participants on problems involving the concept of sampling with replacement (SWR). Training consisted of examples that were either highly similar in their semantic context (e.g. all involving people selecting objects) or in which the surface features were varied between examples (e.g. people choosing objects AND objects selected in a sequence). The experimenters also surveyed how much prior knowledge each participant had with SWR. They found that whether variation was beneficial depended on the prior knowledge of the participants – such that participants with some prior knowledge benefited from varied training, whereas participants with minimal prior knowledge performed better after training with similar examples. The authors hypothesized that in order to benefit from varied examples, participants must be able to detect the structure common to the diverse examples, and that participants with prior knowledge are more likely to be sensitive to such structure, and thus to benefit from varied training. To test this hypothesis more directly, the authors conducted a 2nd experiment, wherein they controlled prior knowledge by exposing some subjects to a short graphical or verbal pre-training lesson, designed to increase sensitivity to the training examples. Consistent with their hypothesis, participants exposed to the structural sensitivity pre-training benefited more from varied training than the controls participants who benefited more from training with similar examples.\nVariability has also been examined within the realm of language learning. A particularly impressive study is that of (Perry et al., 2010). In nine training sessions spread out over nine weeks infants were trained on object labels in a naturalistic play setting. All infants were introduced to three novel objects of the same category, with participants in the tight condition being exposed to three similar exemplars of the category, and participants in the varied condition being exposed to three dissimilar objects of the same category. Importantly, the similarity of the objects was carefully controlled for by having a separate group of adult subjects provide pairwise similarity judgements of the category objects prior to the study onset. Multidimensional scaling was then performed to obtain the coordinates of the objects psychological space, and out of the 10 objects for each category, the 3 most similar objects were selected for the tight group and the three least similar objects for the varied group, with the leftover four objects being retained for testing. By the end of the nine weeks, all of the infants had learned the labels of the training objects. The varied group demonstrated superior ability to correctly generalize the object labels to untrained exemplars of the same category, a pattern consistent with much of the existing literature. More interesting was the superior performance of the varied group on a higher order generalization task – such that they were able to appropriately generalize the bias they had learned during training for attending to the shape of objects to novel solid objects, but not to non-solids. The tight training group, on the other hand, tended to overgeneralize the shape bias, leading the researchers to suggest that the varied training induced a more context-sensitive understanding of when to apply their knowledge.\n\n\n\n\n\nA necessary consequence of varied training is that participants will have the experience of switching from one task condition to another. The number of switches can vary greatly, with the two extremes being varied participants completing all of their training trials in one before switching to the next condition (blocked sequencing), or if they alternate between conditions on a trial by trial basis (random/intermixed/interleaved sequencing). Not long after the initial influx of schema-theory inspired studies testing the benefits of variability hypothesis was shown that the influence of varied training might interact with the type of training sequence chosen by the experimenter (J. B. Shea & Morgan, 1979). In this seminal study, both groups of training subjects trained with the same number of trials of three separate movement patterns. A blocked group that completed all of their trials with one sequence before beginning the next sequence, and a random group that trained with all three movement patterns interspersed throughout the course of training. Participants were also randomly assigned to retention testing under either blocked or random sequence conditions, thus resulting in all four training-testing combinations of blocked-blocked; blocked-random; random-blocked; random-random. There was some effect of sequence context, such that both groups performed better when the testing sequence matched their training sequence. However, the main finding of interest was the advantage of random-training, which resulted in superior testing performance than blocked training regardless of whether the testing stage had a blocked or random sequence, an effect observed both immediately after training, and in a follow up test ten days after the end of training.\nPrior to the influential J. B. Shea & Morgan (1979) study, studies investigating the benefits of variability hypothesis had utilized both blocked and random training schedules, often without comment or justification. It was later observed (Lee et al., 1985) that positive evidence for benefits of varied training seemed more likely to occur for studies that utilized random schedules. The theoretical basis of such studies was invariably an appeal to Schmidt’s schema theory; however schema theory made no clear predictions of an effect of study sequence on retention or generalization, thus prompting the need for alternate accounts. One such account, the elaborative processing account (J. B. Shea & Zimny, 1983), draws on the earlier work (Battig, 1966) and argues that randomly sequencing conditions during training promotes comparison and contrastive processes between those conditions, which result in a deeper understanding of the training task than could arise via blocked sequencing. Supporting evidence for elaborative processing comes in the form of random-sequence trained subjects self-reporting more nuanced mental representations of movement patterns following training (J. B. Shea & Zimny, 1983), and by manipulating whether subjects are able to perform comparisons during training (Wright et al., 1992). An alternative, though not incompatible account suggests that the benefits of random-sequencing are a result of such sequences forcing the learner to continually reconstruct the relevant motor task in working memory (Lee & Magill, n.d.). Blocked training, on the other hand, allows the learner to maintain the same motor task in short term memory without decay for much of the training which facilitates training performance, but hinders ability to retrieve the appropriate motor memory in a later testing context. A much more recent study (Chua et al., 2019), replicates the standard findings of an advantage of varied training over constant training (expt 1, bean-bag throwing task), and of random training over blocked training (expt 2 & 3, bean-bag throwing & golf putting). The novelty of this study is that the experimenters queried subjects about their attentional focus throughout the training stage. In all three experiments varied or random trained-subjects reported significantly greater external attention (e.g. attending to the target distance), and constant or blocked subjects reported more internal attention (e.g. posture or hand position). The authors argue that the benefits of varied/random training may be mediated by changes in attentional focus, however the claims made in the paper seem to go far beyond what can be justified by the analyses reported – e.g. the increased external focus could be a simple byproduct of varied training. A stronger form of evidence that was not provided may have been to use multiple regression analyses to show that the testing advantage of the varied/random groups over the constant/blocked groups could be accounted for by the differences in self-reported attentional focus.\n\n\n\n\nOf course, the effects of varied training, and different training sequences, are likely to be far more complex than simply more varied training being better than less, or random training being better than blocked. Null effects of both manipulations have been reported (see Magill & Hall, 1990; Van Rossum, 1990 for reviews), and a variety of moderators have emerged. In one of the earlier examples of the complex relationship between study sequence and learning (Del Rey et al., 1982), experimenters recruited participants who self-reported either large amounts, or very little experience with athletic actives, and then trained participants on a coincident timing task under with either a single constant training velocity, or with four training velocities under either blocked, or random training sequence conditions - resulting in six experimental conditions: (athlete vs. non-athlete) x (constant vs. blocked vs. random training). Athlete participants had superior performance during training, regardless of sequence condition, and training performance was superior for all subjects in the constant group, followed by blocked training in the middle, and then random training resulting in the worst training performance. Of greater interest is the pattern of testing results for novel transfer conditions. Among the athlete-participants, transfer performance was best for those who received random training, followed by blocked, and then constant training. Non-athletes showed the opposite pattern, with superior performance for those who had constant training. A similar pattern was later observed in a golf-putting training study, wherein participants who had some prior golf experience benefited most from random-sequenced training, and participants with no golf experience benefited most from blocked training (Guadagnoli et al., 1999). More recently, the same pattern was observed in the concept learning literature (Braithwaite & Goldstone, 2015 expt 1.). This study trained participants on a mathematical concept and found that participants who self-reported some prior experience with the concept improved more from pre-test to post-test after training with varied examples, while participants who reported no prior experience showed greater gains following training with highly similar examples.\nIn addition to the influence of prior experiences described above, ample evidence also suggests that numerous aspects of the experiment may also interact with the influence of variation. One important study examined the impact of the amount of training completed in a force production task (C. H. Shea et al., 1990). This study employed a typical blocked vs. random training procedure, but with the additional manipulation of separate groups receiving 50, 200, or 400 total training trials. For the group that received only 50 training trials retention was best when training had been blocked. However, for the conditions that received 200 or 400 training trials the pattern was reversed, with random training resulting in superior retention than blocked training. These results were taken to suggest that the benefits of randomization may take time to emerge. Another experimental factor shown to interact with training sequence is the complexity of the training task (Albaret & Thon, 1998). In addition to random or blocked training, participants in this study were assigned to train on a drawing task at one of three different levels of complexity (reproducing from memory shapes composed of two, three or four components). On a transfer task 48 hours after the completion of training, only participants trained at the lower levels of task complexity (2 or 3 components) showed superior performance to the blocked condition. The authors suggest that the benefits of random sequencing, thought to arise from more elaborate cognitive processing, or the necessity of continually recalling task information from long term into short term memory, are more likely to be obscured as the complexity of the task forces the blocked participants to also engage in such processes.\nA final important influence of particular relevance to the practice-sequence literature concerns the exact structure of “random” sequencing. Although the term random is commonly used for convenience, experimenters do not typically leave the order of training entirely up to chance. Rather, the training sequence is often constrained such that each condition must occur a minimum number of times in each quartile of the training phase, thus resulting in an even distribution the conditions throughout training. While the assurance of the conditions being evenly spread throughout training is consistent across studies, other aspects of the sequence structure are a bit more idiosyncratic. Some researchers report setting a maximum number of consecutive repetitions, e.g. no more than 2 consecutive trials of the same condition (Del Rey et al., 1982; J. B. Shea & Morgan, 1979), or structure the random trials such that the same condition never occurs consecutively (Wulf, 1991). Also common is to structure experiments such that random condition really consists of many small blocks, where participants do a few trials of one condition consecutively and then switch to another condition (Chua et al., 2019; Willey & Liu, 2018b; Wrisberg et al., 1987), resulting in many more switches than would arise if training was perfectly blocked. The question of whether such differences in the structure of random sequencing are consequential has been addressed experimentally a few times, in all cases consisting of a 1) a no-repeat random condition; 2) a blocked random condition (typically 3 or 4 repeats before a switch); and 3) a standard fully-blocked condition. Blocked-random training resulted in better performance than either repeat-random, or fully - blocked training in both a bean-bag throwing (Pigott & Shapiro, 1984), and basketball shot training study (Landin & Hebert, 1997), and in a replication plus extension of the seminal (J. B. Shea & Morgan, 1979) study, blocked-random training was equally effective as no-repeat random training, with both random structures leading to better performance than the fully-blocked training condition. Consequences on different study schedules have also been repeatedly observed in the category learning literature (Carvalho & Goldstone, 2014, 2017). This line of research has revealed that the effects of blocking vs. interleaving can depend on the structure of the category being learned, and also that the different schedules can result in the participants requiring different representations. A fruitful line of inquiry in the motor skill learning literature may be to attempt to identify whether structural aspects of the motor task interact with different training sequences in a reliable manner.\nNumerous researchers have attempted to provide coherent frameworks to account for the full range of influences of training variation and sequencing described above (along with many other effects not discussed). Such accounts are generally quite similar, invoking ideas of desirable levels of difficulty (Bjork & Bjork, 1992; Schmidt & Bjork, 1992), or optimal challenge points (Guadagnoli & Lee, 2004). They tend to start by describing the dissociation between acquisition performance (performance during training) and testing performance (delayed retention and/or transfer), most strikingly observed as varied/random training participants performing worse than their constant/blocked counterparts during the training stage of the study, but then outperforming the constant/blocked comparisons at a later retention or transfer stage. This observation is then used to justify the idea that the most enduring and generalizable learning occurs by training at an optimal level of training difficulty, with difficulty being some function of the experience of the learner, and the cognitive or visuomotor processing demands of the task. It then follows that the factors that tend to make training more difficult (i.e. increased variability or randomization), are more likely to be beneficial when the learner has some experience, or when the processing demands of the task are not too extreme (which may only occur after some experience with the task). Such frameworks may be helpful heuristics in some cases, but they also seem to be overly flexible such that any null result of some intervention might be accounted for by a suboptimal amount of training trials, or by suggesting the training task was too difficult. The development of computational models that can account for how changes in the parameters of the motor-skill task scale with difficulty, would be a great step forward.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#the-study-of-variability",
    "href": "Sections/full.html#the-study-of-variability",
    "title": "Full Dissertation",
    "section": "",
    "text": "Studies investigating the “benefits of variability” hypothesis usually assign participants to either a constant or varied group for the training stage of the experiment. Then, subjects in both groups complete an identical testing stage which often consists items/conditions seen during training, and novel items/conditions. If the varied group performs better in the testing stage, this is taken for evidence of the benefits of variability hypothesis. Even within this relatively straightforward between-groups design, researchers must navigate several crucial methodological choices, highlighted below:\n\nVariables Subject to Variation. In multidimensional tasks, researchers have the option to vary numerous variables. The experimenters must decide the specific dimension(s) across which variation will occur. For instance, in a projectile throwing accuracy task – researchers might vary the distance from the target, the size of the target, the weight of the projectile. They might also vary a contextual variable not directly relevant to the task, but which will still be encoded by the subject on a trial by trial basis, e.g. the background color.\nMagnitude of Variation, relative to the control condition. The simplest comparison would be to compare a constant group who trains with 1 example/condition, against a varied group that trains from 2 examples/conditions. However, it is not uncommon in the literature for the varied condition to train from 3 or 4 conditions. For example, Catalano & Kleiner (1984) train varied subjects from 4 different velocities in their coincident timing task, and (Goode et al., 2008) have varied subjects’ practice with 3 different variants (i.e. different letter scrambles of the same word) of an anagram for a given word, while their constant participants view the same variant 3 different times. Alternatively, rather than a constant vs. varied comparison, subjects in all conditions might experience a variety of training items, but with one group experiencing a greater number of unique items (Nosofsky, Sanders, Zhu, et al., 2018).\nLocations within Task-Space. For tasks in which the stimuli or conditions fall within a continuous metric space, the experimenter must decide whether the varied instances are relatively close together (e.g. throwing a ball from a distance of 4 feet and 5 feet), or far apart (throwing from 4 feet and 20 feet). Spreading the varied training items further apart may be beneficial in terms of providing a more representative sample of the task space to the learner, however large distances may also result in significant differences in difficulty between the training examples, which can be a common confound in variability studies.\nProximity of Testing to Training Conditions. Intuitively, the fairest form of comparison is to include testing conditions that are of an equivalent distance from both the varied and constant groups. However researchers might also attempt to demonstrate the benefits of variation as being sufficiently powerful to outperform constant training, even in cases where the constant group trained from a closer proximity to the testing conditions, or whose training conditions are identical to the testing conditions (Goode et al., 2008; Kerr & Booth, 1978).",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#variability-literature-review",
    "href": "Sections/full.html#variability-literature-review",
    "title": "Full Dissertation",
    "section": "",
    "text": "An early and influential work on the influence of variability on category learning is that of Posner & Keele (1968). In an ambitious attempt to address the question of how category information is represented, the authors trained participants to categorize artificial dot patterns, manipulating whether learners were exposed to examples clustered close to the category prototypes (e.g. a low variability condition), or spread further away from the prototype (the varied-training group). It should be noted that both groups in this study were trained with the same number of unique instances and the manipulated difference was how spread out the instances were. The authors claim based on prior experiments using the same stimuli, that the training stimuli for the varied group were at least as far away from the testing stimuli as the training stimuli of the less-varied group. The authors interpreted their findings as evidence for the extraction of an abstraction or schema that is extracted and stored, and then over time becomes more likely to be the reference point from which generalization occurs, given that specific instances are thought to decay at a faster rate than prototypes or schema. The Posner and Keele study has been extremely influential and continues to be cited in contemporary research as clear evidence that schema abstraction underlies the benefits of varied training. It’s also referenced as a key influence in the development of “Schema Theory of Motor Learning” (Schmidt, 1975), which in turn influenced decades of investigations on the potential benefits of varied training in motor skill learning. However, the classic Posner & Keele study despite being far more carefully designed than many subsequent studies, and despite being a relative rarity in explicitly discussing and attempting to control for potential confounds of similarity between groups, may nevertheless be emblematic of a common issue in many investigations of the effects of varied training on learning. The problem with Posner & Keele’s conclusion was demonstrated clearly almost 3 decades later (Palmeri & Nosofsky, 2001), when researchers conducting a near replication of the original study also collected similarity judgements following training and performed multidimensional scaling analysis. Rather than being in the middle of the training stimuli as was the case in the physical stimuli space, the psychological representation of the prototype was shown reside at an extreme point, and generalization patterns by participants that would have seemed to warrant the learning of a prototype were then easily accounted for with only the assumption that the participants encoded instances. One of the primary concerns of the present paper is that many of the studies which purport to explain the benefits of variation via prototypes, schemas, or other abstractions, are often overlooking the potential of instance based similarity accounts.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#motor-skill-learning",
    "href": "Sections/full.html#motor-skill-learning",
    "title": "Full Dissertation",
    "section": "",
    "text": "Training variation has also been shown to promote transfer in motor learning. Much of this research has been influenced by the work of (Schmidt, 1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. Schema theory presumes a priori that learners possess general motor programs for classes of movements, such as an underhand throw. When called up for use, such programs must be parameterized, as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class, such as an underhand throw (though it is agnostic to the development of the movement classes themselves). Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices with multiple instances along some task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations.\nOne of the earliest, and still often cited investigations of Schmidt’s benefits of variability hypothesis was the work of Kerr & Booth (1978). Two groups of children, aged 8 and 12, were assigned to either constant or varied training of a bean bag throwing task. The constant group practiced throwing a bean-bag at a small target placed 3 feet in front of them, and the varied group practiced throwing from a distance of both 2 feet and 4 feet. Participants were blindfolded and unable to see the target while making each throw but would receive feedback by looking at where the beanbag had landed in between each training trial. 12 weeks later, all of the children were given a final test from a distance of 3 feet which was novel for the varied participants and repeated for the constant participants. Participants were also blindfolded for testing and did not receive trial by trial feedback in this stage. However, at the halfway point of the testing stage they were allowed to see the landing location of the 4 beanbags they had thrown, and then completed the final 4 testing throws. In both age groups, participants performed significantly better in the varied condition than the constant condition, though the effect was larger for the younger, 8-year-old children. Although this design does not directly assess the hypothesis of varied training producing superior generalization to constant training (since the constant group is not tested from a novel position), it nevertheless offers a compelling example of the merits of varied practice.\nOn occasion the Kerr and Booth design may be nested within a larger experimental design. One such study that used a movement timing task, wherein subjects had to move their hand from a starting location, to a target location, attempting to arrive at the target location at specific time following the onset of a cue (Wrisberg et al., 1987). This study utilized 4 different constant groups, and 3 varied groups, with one of the constant groups training under conditions identical to the testing conditions, and which were not trained on by any of the varied groups, e.g. the design of Kerr and Booth. However, in this case the varied group did not outperform the constant group. A more recent study attempting a slightly more direct replication of the original Kerr & Booth study (Willey & Liu, 2018b), having subjects throw beanbags at a target, with the varied group training from positions (5 and 9 feet) on either side of the constant group (7 feet). However, this study diverged from the original in that the participants were adults; they faced away from the target and threw the beanbag backwards over their bodies; they alternated using their right and left hands every 6 trials; and underwent a relatively extreme amount of training (20 sessions with 60 practice trials each, spread out over 5-7 weeks). Like Wrisberg et al. (1987), this study did not find a varied advantage from the constant training position, though the varied group did perform better at distances novel to both groups.\nSome support for the Kerr and Booth findings was found with a relatively less common experimental task of training participants in hitting a projectile at a target with the use of a racket (Green et al., 1995). Varied participants trained with tennis, squash, badminton, and short-tennis rackets were compared against constant subjects trained with only a tennis racket. One of the testing conditions had subjects repeat the use of the tennis racket, which had been used on all 128 training trials for the constant group, and only 32 training trials for the varied group. Nevertheless, the varied group outperformed the constant group when using the tennis racket at testing, and also performed better in conditions with several novel racket lengths. Of course, this finding is less surprising than that of Kerr & Booth, given that varied subjects did have some prior exposure to the constant groups condition. This highlights an issue rarely discussed in the literature, of how much practice from an additional position might be necessary to induce benefits. Experimenters almost uniformly have varied participants train with an equivalent number of trials from each of their conditions\nOne of the few studies that has replicated the surprising result of varied outperforming constant, from the constant training condition, did so in the relatively distant domain of verbal manipulation (Goode et al., 2008). All participants trained to solve anagrams of 40 different words ranging in length from 5 to 11 letters, with an anagram of each word repeated 3 times throughout training, for a total of 120 training trials. Although subjects in all conditions were exposed to the same 40 unique words (i.e. the solution to an anagram), participants in the varied group saw 3 different arrangements for each solution-word, such as DOLOF, FOLOD, and OOFLD for the solution word FLOOD, whereas constant subjects would train on three repetitions of LDOOF (spread evenly across training). Two different constant groups were used. Both constant groups trained with three repetitions of the same word scramble, but for constant group A, the testing phase consisted of the identical letter arrangement to that seen during training (e.g. LDOOF), whereas for constant group B, the testing phase consisted of a arrangement they had not seen during training, thus presenting them with a testing situation similar situation to the varied group. At the testing stage, the varied group outperformed both constant groups, a particularly impressive result, given that constant group A had 3 prior exposures to the word arrangement (i.e. the particular permutation of letters) which the varied group had not explicitly seen. However varied subjects in this study did not exhibit the typical decrement in the training phase typical of other varied manipulations in the literature, and actually achieved higher levels of anagram solving accuracy by the end of training than either of the constant groups – solving 2 more anagrams on average than the constant group. This might suggest that for tasks of this nature where the learner can simply get stuck with a particular word scramble, repeated exposure to the identical scramble might be less helpful towards finding the solution than being given a different arrangement of the same letters. This contention is supported by the fact that constant group A, who was tested on the identical arrangement as they experienced during training, performed no better at testing than did constant group B, who had trained on a different arrangement of the same word solution – further suggesting that there may not have been a strong identity advantage in this task.\nPitting varied against constant practice against each other on the home turf of the constant group provides a compelling argument for the benefits of varied training, as well as an interesting challenge for theoretical accounts that posit generalization to occur as some function of distance. However, despite its appeal this particular contrast is relatively uncommon in the literature. It is unclear whether this may be cause for concern over publication bias, or just researchers feeling the design is too risky. A far more common design is to have separate constant groups that each train exclusively from each of the conditions that the varied group encounters (Catalano & Kleiner, 1984; Chua et al., 2019; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976), or for a single constant group to train from just one of the conditions experienced by the varied participants (Pigott & Shapiro, 1984; Roller et al., 2001; Wrisberg & McLean, 1984; Wrisberg & Mead, 1983). A less common contrast places the constant group training in a region of the task space outside of the range of examples experienced by the varied group, but distinct from the transfer condition (Wrisberg et al., 1987; Wulf & Schmidt, 1997).\nOf particular relevant to the current essay is the early work of Catalano & Kleiner (1984), as theirs was one of the earliest studies to investigate the influence of varied vs. constant training on multiple testing locations of graded distance from the training condition. Participants were trained on coincident timing task, in which subjects observe a series of lightbulbs turning on sequentially at a consistent rate and attempt to time a button response with the onset of the final bulb. The constant groups trained with a single velocity of either 5,7,9, or 11 mph, while the varied group trained from all 4 of these velocities. Participants were then assigned to one of four possible generalization conditions, all of which fell outside of the range of the varied training conditions – 1, 3, 13 or 15 mph. As is often the case, the varied group performed worse during the training phase. In the testing phase, the general pattern was for all participants to perform worse as the testing conditions became further away from the training conditions, but since the drop off in performance as a function of distance was far less steep for the varied group, the authors suggested that varied training induced a decremented generalization gradient, such that the varied participants were less affected by the change between training and testing conditions.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#category-learning",
    "href": "Sections/full.html#category-learning",
    "title": "Full Dissertation",
    "section": "",
    "text": "In the category learning literature, the constant vs. varied comparison is much less suitable. Instead, researchers tend to compare a condition with many repetitions of a few items against condition with fewer repetitions of a wider array of exemplars. Much of the earlier work in this sub-area trained subjects on artificial categories, such as dot patterns (Homa & Vosburgh, 1976; Posner & Keele, 1968), where more varied or distorted training examples were often shown to produce superior generalization when categorizing novel exemplars. More recently, researchers have also begun to utilize more realistic stimuli in their experiments. Wahlheim et al. (2012) conducted one such study. In a within-participants design, participants were trained on bird categories with either high repetitions of a few exemplars, or few repetitions of many exemplars. Across four different experiments, which were conducted to address an unrelated question on metacognitive judgements, the researchers consistently found that participants generalized better to novel species following training with more unique exemplars (i.e. higher variability), while high repetition training produced significantly better performance categorizing the specific species they had trained on. A variability advantage was also found in the relatively complex domain of rock categorization (Nosofsky, Sanders, & McDaniel, 2018). For 10 different rock categories, participants were trained with either many repetitions of 3 unique examples of each category, or few repetitions of 9 unique examples, with an equal number of total training trials in each group (the design also included 2 other conditions less amenable to considering the impact of variation). The high-variability group, trained with 9 unique examples, showed significantly better generalization performance than the other conditions. Moreover, the pattern of results in this study could be nicely accounted for by an extended version of the Generalized Context Model.\nThe studies described thus far have studied the benefits of variability by exposing participants to a greater or lesser number of distinct examples during training. A distinct sub-literature within the category learning domain has focused much less on benefits derived from varied training, instead emphasizing how increased variability during the learning of a novel category influences how far the category boundary will then be generalized. The general approach is to train participants on examples from two categories, with the examples from one of the categories being more dispersed than the other. Participants are then tested with novel items located within ambiguous regions of the task space which allow the experimenters to assess whether the difference in variability influences how far participants generalize the category boundaries.\nA. L. Cohen et al. (2001) trained subjects on two categories, one with much more variability than the other. In experiment 1, a low variability category composed of 1 instance was compared against a high-variability category of 2 instances in one condition, and 7 instances in another. In experiment 2 both categories were composed of 3 instances, but for the low-variability group the instances were clustered close to each other, whereas the high-variability groups instances were spread much further apart. Participants were tested on an ambiguous novel instance that was located in between the two trained categories. Both experiments provided evidence that participants were much more likely to categorize the novel middle stimulus into a category with greater variation. Moreover, this effect was at odds with the predications of the baseline version of the GCM, thus providing some evidence that training variation may at least sometimes induce effects that cannot be entirely accounted for by exemplar-similarity accounts.\nFurther observations consonant with the results of A. L. Cohen et al. (2001) have since been observed in numerous investigations (Hahn et al., 2005; Hsu & Griffiths, 2010; Perlman et al., 2012; Sakamoto et al., 2008). The results of Sakamoto et al. (2008) are noteworthy. They first reproduced the basic finding of participants being more likely to categorize an unknown middle stimulus into a training category with higher variability. In a second experiment, they held the variability between the two training categories constant and instead manipulated the training sequence, such that the examples of one category appeared in an ordered fashion, with very small changes from one example to the other (the stimuli were lines that varied only in length), whereas examples in the alternate category were shown in a random order and thus included larger jumps in the stimulus space from trial to trial. They found that the middle stimulus was more likely to be categorized into the category that had been learned with a random sequence, which was attributed to an increased perception of variability which resulted from the larger trial to trial discrepancies.\nThe work of Hahn et al. (2005), is also of particular interest to the present discussion. Their experimental design was similar to previous studies, but they included a larger set of testing items which were used to assess generalization both between the two training categories as well as novel items located in the outer edges of the training categories. During generalization testing, participants were given the option to respond with “neither”, in addition to responses to the two training categories. The “neither” response was included to test how far away in the stimulus space participants would continue to categorize novel items as belonging to a trained category. Consistent with prior findings, high-variability training resulted in an increased probability of categorizing items in between the training categories as belong to the high variability category. Additionally, participants trained with higher variability also extended the category boundary further out into the periphery than participants trained with a lower variability category were willing to do. The authors then used the standard GCM framework to compare a variety of similarity-based models to account for their results. Of particular interest are their evaluations of a category response bias parameter, and a similarity scaling parameter. A model fit improvement when the response bias parameter is allowed to vary between the high-variability and low-variability trained groups is taken to suggest a simple bias for responding with one of the trained categories over the other. Alternatively, an improvement in fit due to a separate similarity scaling parameter may reflect the groups being differentially sensitive to the distances between stimuli. No improvement in model fit was found by allowing the response-bias parameter to differ between groups, however the model performance did improvement significantly when the similarity scaling parameter was fit separately. The best fitting similarity-scaling parameters were such that the high-variability group was less sensitive to the distances between stimuli, resulting in greater similarity values between their training items and testing items. This model accounted for both the extended generalization gradients of the varied particpants, and also for their poor performance in a recognition condition. Additional model comparisons suggested that this similarity rescaling applied across the entire stimulus space, rather than to the high variability category in particular.\nVariability effects have also been examined in the higher-level domain of how learners acquire novel concepts, and then instantiate (rather than merely recognize) that concept in untrained contexts (Braithwaite & Goldstone, 2015). This study trained participants on problems involving the concept of sampling with replacement (SWR). Training consisted of examples that were either highly similar in their semantic context (e.g. all involving people selecting objects) or in which the surface features were varied between examples (e.g. people choosing objects AND objects selected in a sequence). The experimenters also surveyed how much prior knowledge each participant had with SWR. They found that whether variation was beneficial depended on the prior knowledge of the participants – such that participants with some prior knowledge benefited from varied training, whereas participants with minimal prior knowledge performed better after training with similar examples. The authors hypothesized that in order to benefit from varied examples, participants must be able to detect the structure common to the diverse examples, and that participants with prior knowledge are more likely to be sensitive to such structure, and thus to benefit from varied training. To test this hypothesis more directly, the authors conducted a 2nd experiment, wherein they controlled prior knowledge by exposing some subjects to a short graphical or verbal pre-training lesson, designed to increase sensitivity to the training examples. Consistent with their hypothesis, participants exposed to the structural sensitivity pre-training benefited more from varied training than the controls participants who benefited more from training with similar examples.\nVariability has also been examined within the realm of language learning. A particularly impressive study is that of (Perry et al., 2010). In nine training sessions spread out over nine weeks infants were trained on object labels in a naturalistic play setting. All infants were introduced to three novel objects of the same category, with participants in the tight condition being exposed to three similar exemplars of the category, and participants in the varied condition being exposed to three dissimilar objects of the same category. Importantly, the similarity of the objects was carefully controlled for by having a separate group of adult subjects provide pairwise similarity judgements of the category objects prior to the study onset. Multidimensional scaling was then performed to obtain the coordinates of the objects psychological space, and out of the 10 objects for each category, the 3 most similar objects were selected for the tight group and the three least similar objects for the varied group, with the leftover four objects being retained for testing. By the end of the nine weeks, all of the infants had learned the labels of the training objects. The varied group demonstrated superior ability to correctly generalize the object labels to untrained exemplars of the same category, a pattern consistent with much of the existing literature. More interesting was the superior performance of the varied group on a higher order generalization task – such that they were able to appropriately generalize the bias they had learned during training for attending to the shape of objects to novel solid objects, but not to non-solids. The tight training group, on the other hand, tended to overgeneralize the shape bias, leading the researchers to suggest that the varied training induced a more context-sensitive understanding of when to apply their knowledge.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#complications-to-the-influence-of-variability",
    "href": "Sections/full.html#complications-to-the-influence-of-variability",
    "title": "Full Dissertation",
    "section": "",
    "text": "A necessary consequence of varied training is that participants will have the experience of switching from one task condition to another. The number of switches can vary greatly, with the two extremes being varied participants completing all of their training trials in one before switching to the next condition (blocked sequencing), or if they alternate between conditions on a trial by trial basis (random/intermixed/interleaved sequencing). Not long after the initial influx of schema-theory inspired studies testing the benefits of variability hypothesis was shown that the influence of varied training might interact with the type of training sequence chosen by the experimenter (J. B. Shea & Morgan, 1979). In this seminal study, both groups of training subjects trained with the same number of trials of three separate movement patterns. A blocked group that completed all of their trials with one sequence before beginning the next sequence, and a random group that trained with all three movement patterns interspersed throughout the course of training. Participants were also randomly assigned to retention testing under either blocked or random sequence conditions, thus resulting in all four training-testing combinations of blocked-blocked; blocked-random; random-blocked; random-random. There was some effect of sequence context, such that both groups performed better when the testing sequence matched their training sequence. However, the main finding of interest was the advantage of random-training, which resulted in superior testing performance than blocked training regardless of whether the testing stage had a blocked or random sequence, an effect observed both immediately after training, and in a follow up test ten days after the end of training.\nPrior to the influential J. B. Shea & Morgan (1979) study, studies investigating the benefits of variability hypothesis had utilized both blocked and random training schedules, often without comment or justification. It was later observed (Lee et al., 1985) that positive evidence for benefits of varied training seemed more likely to occur for studies that utilized random schedules. The theoretical basis of such studies was invariably an appeal to Schmidt’s schema theory; however schema theory made no clear predictions of an effect of study sequence on retention or generalization, thus prompting the need for alternate accounts. One such account, the elaborative processing account (J. B. Shea & Zimny, 1983), draws on the earlier work (Battig, 1966) and argues that randomly sequencing conditions during training promotes comparison and contrastive processes between those conditions, which result in a deeper understanding of the training task than could arise via blocked sequencing. Supporting evidence for elaborative processing comes in the form of random-sequence trained subjects self-reporting more nuanced mental representations of movement patterns following training (J. B. Shea & Zimny, 1983), and by manipulating whether subjects are able to perform comparisons during training (Wright et al., 1992). An alternative, though not incompatible account suggests that the benefits of random-sequencing are a result of such sequences forcing the learner to continually reconstruct the relevant motor task in working memory (Lee & Magill, n.d.). Blocked training, on the other hand, allows the learner to maintain the same motor task in short term memory without decay for much of the training which facilitates training performance, but hinders ability to retrieve the appropriate motor memory in a later testing context. A much more recent study (Chua et al., 2019), replicates the standard findings of an advantage of varied training over constant training (expt 1, bean-bag throwing task), and of random training over blocked training (expt 2 & 3, bean-bag throwing & golf putting). The novelty of this study is that the experimenters queried subjects about their attentional focus throughout the training stage. In all three experiments varied or random trained-subjects reported significantly greater external attention (e.g. attending to the target distance), and constant or blocked subjects reported more internal attention (e.g. posture or hand position). The authors argue that the benefits of varied/random training may be mediated by changes in attentional focus, however the claims made in the paper seem to go far beyond what can be justified by the analyses reported – e.g. the increased external focus could be a simple byproduct of varied training. A stronger form of evidence that was not provided may have been to use multiple regression analyses to show that the testing advantage of the varied/random groups over the constant/blocked groups could be accounted for by the differences in self-reported attentional focus.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#other-task-and-participant-effects",
    "href": "Sections/full.html#other-task-and-participant-effects",
    "title": "Full Dissertation",
    "section": "",
    "text": "Of course, the effects of varied training, and different training sequences, are likely to be far more complex than simply more varied training being better than less, or random training being better than blocked. Null effects of both manipulations have been reported (see Magill & Hall, 1990; Van Rossum, 1990 for reviews), and a variety of moderators have emerged. In one of the earlier examples of the complex relationship between study sequence and learning (Del Rey et al., 1982), experimenters recruited participants who self-reported either large amounts, or very little experience with athletic actives, and then trained participants on a coincident timing task under with either a single constant training velocity, or with four training velocities under either blocked, or random training sequence conditions - resulting in six experimental conditions: (athlete vs. non-athlete) x (constant vs. blocked vs. random training). Athlete participants had superior performance during training, regardless of sequence condition, and training performance was superior for all subjects in the constant group, followed by blocked training in the middle, and then random training resulting in the worst training performance. Of greater interest is the pattern of testing results for novel transfer conditions. Among the athlete-participants, transfer performance was best for those who received random training, followed by blocked, and then constant training. Non-athletes showed the opposite pattern, with superior performance for those who had constant training. A similar pattern was later observed in a golf-putting training study, wherein participants who had some prior golf experience benefited most from random-sequenced training, and participants with no golf experience benefited most from blocked training (Guadagnoli et al., 1999). More recently, the same pattern was observed in the concept learning literature (Braithwaite & Goldstone, 2015 expt 1.). This study trained participants on a mathematical concept and found that participants who self-reported some prior experience with the concept improved more from pre-test to post-test after training with varied examples, while participants who reported no prior experience showed greater gains following training with highly similar examples.\nIn addition to the influence of prior experiences described above, ample evidence also suggests that numerous aspects of the experiment may also interact with the influence of variation. One important study examined the impact of the amount of training completed in a force production task (C. H. Shea et al., 1990). This study employed a typical blocked vs. random training procedure, but with the additional manipulation of separate groups receiving 50, 200, or 400 total training trials. For the group that received only 50 training trials retention was best when training had been blocked. However, for the conditions that received 200 or 400 training trials the pattern was reversed, with random training resulting in superior retention than blocked training. These results were taken to suggest that the benefits of randomization may take time to emerge. Another experimental factor shown to interact with training sequence is the complexity of the training task (Albaret & Thon, 1998). In addition to random or blocked training, participants in this study were assigned to train on a drawing task at one of three different levels of complexity (reproducing from memory shapes composed of two, three or four components). On a transfer task 48 hours after the completion of training, only participants trained at the lower levels of task complexity (2 or 3 components) showed superior performance to the blocked condition. The authors suggest that the benefits of random sequencing, thought to arise from more elaborate cognitive processing, or the necessity of continually recalling task information from long term into short term memory, are more likely to be obscured as the complexity of the task forces the blocked participants to also engage in such processes.\nA final important influence of particular relevance to the practice-sequence literature concerns the exact structure of “random” sequencing. Although the term random is commonly used for convenience, experimenters do not typically leave the order of training entirely up to chance. Rather, the training sequence is often constrained such that each condition must occur a minimum number of times in each quartile of the training phase, thus resulting in an even distribution the conditions throughout training. While the assurance of the conditions being evenly spread throughout training is consistent across studies, other aspects of the sequence structure are a bit more idiosyncratic. Some researchers report setting a maximum number of consecutive repetitions, e.g. no more than 2 consecutive trials of the same condition (Del Rey et al., 1982; J. B. Shea & Morgan, 1979), or structure the random trials such that the same condition never occurs consecutively (Wulf, 1991). Also common is to structure experiments such that random condition really consists of many small blocks, where participants do a few trials of one condition consecutively and then switch to another condition (Chua et al., 2019; Willey & Liu, 2018b; Wrisberg et al., 1987), resulting in many more switches than would arise if training was perfectly blocked. The question of whether such differences in the structure of random sequencing are consequential has been addressed experimentally a few times, in all cases consisting of a 1) a no-repeat random condition; 2) a blocked random condition (typically 3 or 4 repeats before a switch); and 3) a standard fully-blocked condition. Blocked-random training resulted in better performance than either repeat-random, or fully - blocked training in both a bean-bag throwing (Pigott & Shapiro, 1984), and basketball shot training study (Landin & Hebert, 1997), and in a replication plus extension of the seminal (J. B. Shea & Morgan, 1979) study, blocked-random training was equally effective as no-repeat random training, with both random structures leading to better performance than the fully-blocked training condition. Consequences on different study schedules have also been repeatedly observed in the category learning literature (Carvalho & Goldstone, 2014, 2017). This line of research has revealed that the effects of blocking vs. interleaving can depend on the structure of the category being learned, and also that the different schedules can result in the participants requiring different representations. A fruitful line of inquiry in the motor skill learning literature may be to attempt to identify whether structural aspects of the motor task interact with different training sequences in a reliable manner.\nNumerous researchers have attempted to provide coherent frameworks to account for the full range of influences of training variation and sequencing described above (along with many other effects not discussed). Such accounts are generally quite similar, invoking ideas of desirable levels of difficulty (Bjork & Bjork, 1992; Schmidt & Bjork, 1992), or optimal challenge points (Guadagnoli & Lee, 2004). They tend to start by describing the dissociation between acquisition performance (performance during training) and testing performance (delayed retention and/or transfer), most strikingly observed as varied/random training participants performing worse than their constant/blocked counterparts during the training stage of the study, but then outperforming the constant/blocked comparisons at a later retention or transfer stage. This observation is then used to justify the idea that the most enduring and generalizable learning occurs by training at an optimal level of training difficulty, with difficulty being some function of the experience of the learner, and the cognitive or visuomotor processing demands of the task. It then follows that the factors that tend to make training more difficult (i.e. increased variability or randomization), are more likely to be beneficial when the learner has some experience, or when the processing demands of the task are not too extreme (which may only occur after some experience with the task). Such frameworks may be helpful heuristics in some cases, but they also seem to be overly flexible such that any null result of some intervention might be accounted for by a suboptimal amount of training trials, or by suggesting the training task was too difficult. The development of computational models that can account for how changes in the parameters of the motor-skill task scale with difficulty, would be a great step forward.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#similarity-and-instance-based-approaches-to-transfer-of-learning",
    "href": "Sections/full.html#similarity-and-instance-based-approaches-to-transfer-of-learning",
    "title": "Full Dissertation",
    "section": "Similarity and instance-based approaches to transfer of learning",
    "text": "Similarity and instance-based approaches to transfer of learning\nNotions of similarity have long played a central role in many prominent models of generalization of learning, as well as in the longstanding theoretical issue of whether learners abstract an aggregate, summary representation, or if they simply store individual instances. Early models of learning often assumed that discrete experiences with some task or category were not stored individually in memory, but instead promoted the formation of a summary representation, often referred to as a prototype or schema, and that exposure to novel examples would then prompt the retrieval of whichever preexisting prototype was most similar (Posner & Keele, 1968). Prototype models were later challenged by the success of instance-based or exemplar models – which were shown to provide an account of generalization as good or better than prototype models, with the advantage of not assuming the explicit construction of an internal prototype (Estes, 1994; Hintzman, 1984; Medin & Schaffer, 1978; Nosofsky, 1986 ). Instance-based models assume that learners encode each experience with a task as a separate instance/exemplar/trace, and that each encoded trace is in turn compared against novel stimuli. As the number of stored instances increases, so does the likelihood that some previously stored instance will be retrieved to aid in the performance of a novel task. Stored instances are retrieved in the context of novel stimuli or tasks if they are sufficiently similar, thus suggesting that the process of computing similarity is of central importance to generalization.\nSimilarity, defined in this literature as a function of psychological distance between instances or categories, has provided a successful account of generalization across numerous tasks and domains. In an influential study demonstrating an ordinal similarity effect, experimenters employed a numerosity judgment task in which participants quickly report the number of dots flashed on a screen. Performance (in terms of response times to new patterns) on novel dot configurations varied as an inverse function of their similarity to previously trained dot configurations Palmeri (1997). That is, performance was better on novel configurations moderately similar to trained configurations than to configurations with low-similarity, and also better on low-similarity configurations than to even less similar, unrelated configurations. Instance-based approaches have had some success accounting for performance in certain sub-domains of motor learning (R. G. Cohen & Rosenbaum, 2004; Crump & Logan, 2010; Meigh et al., 2018; Poldrack et al., 1999; Wifall et al., 2017). Crump & Logan (2010) trained participants to type words on an unfamiliar keyboard, while constraining the letters composing the training words to a pre-specified letter set. Following training, typing speed was tested on previously experienced words composed of previously experienced letters; novel words composed of letters from the trained letter set; and novel words composed of letters from an untrained letter set. Consistent with an instance-based account, transfer performance was graded such that participants were fastest at typing the words they had previously trained on, followed by novel words composed of letters they had trained on, and slowest performance for new words composed of untrained letters.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#the-effect-of-training-variability-on-transfer",
    "href": "Sections/full.html#the-effect-of-training-variability-on-transfer",
    "title": "Full Dissertation",
    "section": "The effect of training variability on transfer",
    "text": "The effect of training variability on transfer\nWhile similarity-based models account for transfer by the degree of similarity between previous and new experiences, a largely separate body of research has focused on improving transfer by manipulating characteristics of the initial training stage. Such characteristics have included training difficulty, spacing, temporal order, feedback schedules, and the primary focus of the current work – variability of training examples.\nResearch on the effects of varied training typically compares participants trained under constant, or minimal variability conditions to those trained from a variety of examples or conditions (Czyż, 2021; Soderstrom & Bjork, 2015). Varied training has been shown to influence learning in myriad domains including categorization of simple stimuli (Hahn et al., 2005; Maddox & Filoteo, 2011; Posner & Keele, 1968), complex categorization (Nosofsky, Sanders, Zhu, et al., 2018), language learning (Jones & Brandt, 2020; Perry et al., 2010; Twomey et al., 2018; Wonnacott et al., 2012), anagram completion (Goode et al., 2008), trajectory extrapolation (Fulvio et al., 2014), task switching (Sabah et al., 2019), associative learning (J. C. Lee et al., 2019), visual search (George & Egner, 2021; Gonzalez & Madhavan, 2011; Kelley & Yantis, 2009), voice identity learning (Lavan et al., 2019), simple motor learning (Braun et al., 2009; Kerr & Booth, 1978; Roller et al., 2001; Willey & Liu, 2018a), sports training (Green et al., 1995; North et al., 2019), and training on a complex video game (Seow et al., 2019).\nTraining variation has received a particularly large amount of attention within the domain of visuomotor skill learning. Much of this research has been influenced by the work of Schmidt (1975), who proposed a schema-based account of motor learning as an attempt to address the longstanding problem of how novel movements are produced. According to Schema Theory, learners possess general motor programs for classes of movements (e.g. throwing a ball with an underhand movement), as well as schema rules that determine how a motor program is parameterized or scaled for a particular movement. Schema theory predicts that varied training results in the formation of a more general schema-rule, which can allow for transfer to novel movements within a given movement class. Experiments that test this hypothesis are often designed to compare the transfer performance of a constant-trained group against that of a varied-trained group. Both groups train on the same task, but the varied group practices from multiple levels of a task-relevant dimension that remains invariant for the constant group. For example, investigators might train two groups of participants to throw a projectile at a target, with a constant group that throws from a single location, and a varied group that throws from multiple locations. Both groups are then tested from novel locations. Empirically observed benefits of the varied-trained group are then attributed to the variation they received during training, a finding observed in numerous studies (Catalano & Kleiner, 1984; Chua et al., 2019; Goodwin et al., 1998; Kerr & Booth, 1978; Wulf, 1991), and the benefits of this variation are typically thought to be mediated by the development of a more general schema for the throwing motion.\nOf course, the relationship between training variability and transfer is unlikely to be a simple function wherein increased variation is always beneficial. Numerous studies have found null, or in some cases negative effects of training variation (DeLosh et al., 1997; Sinkeviciute et al., 2019; Wrisberg et al., 1987), and many more have suggested that the benefits of variability may depend on additional factors such as prior task experience, the order of training trials, or the type of transfer being measured (Berniker et al., 2014; Braithwaite & Goldstone, 2015; Hahn et al., 2005; Lavan et al., 2019; North et al., 2019; Sadakata & McQueen, 2014; Zaman et al., 2021).",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#issues-with-previous-research",
    "href": "Sections/full.html#issues-with-previous-research",
    "title": "Full Dissertation",
    "section": "Issues with Previous Research",
    "text": "Issues with Previous Research\nAlthough the benefits of training variation in visuomotor skill learning have been observed many times, null findings have also been repeatedly found, leading some researchers to question the veracity of the variability of practice hypothesis (Newell, 2003; Van Rossum, 1990). Critics have also pointed out that investigations of the effects of training variability, of the sort described above, often fail to control for the effect of similarity between training and testing conditions. For training tasks in which participants have numerous degrees of freedom (e.g. projectile throwing tasks where participants control the x and y velocity of the projectile), varied groups are likely to experience a wider range of the task space over the course of their training (e.g. more unique combinations of x and y velocities). Experimenters may attempt to account for this possibility by ensuring that the training location(s) of the varied and constant groups are an equal distance away from the eventual transfer locations, such that their training throws are, on average, equally similar to throws that would lead to good performance at the transfer locations. However, even this level of experimental control may still be insufficient to rule out the effect of similarity on transfer. Given that psychological similarity is typically best described as either a Gaussian or exponentially decaying function of psychological distance (Ennis et al., 1988; Ghahramani et al., 1996; Logan, 1988; Nosofsky, 1992; Shepard, 1987; Thoroughman & Taylor, 2005 ), it is plausible that a subset of the most similar training instances could have a disproportionate impact on generalization to transfer conditions, even if the average distance between training and transfer conditions is identical between groups. Figure 1 demonstrates the consequences of a generalization gradient that drops off as a Gaussian function of distance from training, as compared to a linear drop-off.\n\n\nCode\np=2\nc&lt;- .0002\nsimdat &lt;- data.frame(x=rep(seq(200,1000),3),condit=c(rep(\"varied\",1602),rep(\"constant\",801)),\n                     train.position=c(rep(400,801),rep(800,801),rep(600,801)),c=.0002,p=2) %&gt;%\n                     mutate(plotjitter=ifelse(condit==\"varied\",0,7),\n                            linScale=ifelse(condit==\"varied\",980,1000),\n                            genGauss=exp(-c*(abs((x-train.position)^p))),\n                            genLinear=1000-abs(x-train.position)+plotjitter) %&gt;% \n  #group_by(condit) %&gt;% mutate(scaleLinear=(genLinear-min(genLinear))/(max(genLinear)-min(genLinear))) \n  group_by(x,condit) %&gt;%\n  reframe(genGauss=mean(genGauss),genLinear=mean(genLinear)/linScale,.groups = 'keep')\ncolorVec=c(\"darkblue\",\"darkred\")\nplotSpecs &lt;- list(geom_line(alpha=.7,size=.4),scale_color_manual(values=colorVec),\n                  geom_vline(alpha=.55,xintercept = c(400,800),color=colorVec[2]),\n                  geom_vline(alpha=.55,xintercept = c(600),color=colorVec[1]),\n                  ylim(c(0,1.05)),\n                  #xlim(c(250,950)),\n                  scale_x_continuous(breaks=seq(200,1000,by=200)),\n                  xlab(\"Test Stimulus\"),\n                  annotate(geom=\"text\",x=447,y=1.05,label=\"Varied\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=450,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=659,y=1.05,label=\"Constant\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=657,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=847,y=1.05,label=\"Varied\",size=3.1,fontface=\"plain\"),\n                  annotate(geom=\"text\",x=850,y=1.02,label=\"Training\",size=3.1,fontface=\"plain\"),\n                  theme(panel.border = element_rect(colour = \"black\", fill=NA, linewidth=1),\n                        legend.position=\"none\"))\n\nip1 &lt;- simdat  %&gt;% ggplot(aes(x,y=genGauss,group=condit,col=condit))+plotSpecs+ylab(\"\")\nip2 &lt;- simdat %&gt;%  ggplot(aes(x,y=genLinear,group=condit,col=condit))+plotSpecs+ylab(\"Amount of Generalization\")\n\nplot_grid(ip1,ip2,ncol=2,rel_heights=c(1))\n\n\n\n\n\n\n\n\nFigure 1: Left panel- Generalization predicted from a simple model that assumes a linear generalization function. A varied group (red vertical lines indicate the 2 training locations) trained from positions 400 and 800, and a constant group (blue vertical line), trained from position 600. Right panel- if a Gaussian generalization function is assumed, then varied training (400, 800) is predicted to result in better generalization to positions close to 400 and 800 than does constant training at 600. (For interpretation of the references to color in this figure legend, the reader is referred to the web version of this article.)\n\n\n\n\n\nIn addition to largely overlooking the potential for non-linear generalization to confound interpretations of training manipulations, the visuomotor skill learning literature also rarely considers alternatives to schema representations (Chamberlin & Magill, 1992b). Although schema-theory remains influential within certain literatures, instance or exemplar-based models have accounted for human behavior across myriad domains (Jamieson et al., 2022; Logan, 2002). As mentioned above, instance based accounts have been shown to perform well on a variety of different tasks with motoric components (Crump & Logan, 2010; Gandolfo et al., 1996; Meigh et al., 2018; Rosenbaum et al., 1995; van Dam & Ernst, 2015). However, such accounts have received little attention within the subdomain of visuomotor skill learning focused on the benefits of varied training.\nThe present work examines whether the commonly observed benefits of varied training can be accounted for by between-group differences in similarity between training and testing throws. We first attempt to replicate previous work finding an advantage of varied training over constant training in a projectile launching task. We then examine the extent to which this advantage can be explained by an instance-based similarity model.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#methods",
    "href": "Sections/full.html#methods",
    "title": "Full Dissertation",
    "section": "Methods",
    "text": "Methods\n\nSample Size Estimation\nTo obtain an independent estimate of effect size, we identified previous investigations which included between-subjects contrasts of varied and constant conditions following training on an accuracy based projectile launching task (Chua et al., 2019; Goodwin et al., 1998; Kerr & Booth, 1978; Wulf, 1991). We then averaged effects across these studies, yielding a Cohens f =.43. The GPower 3.1 software package (Faul et al., 2009), 2009) was then used to determine that a power of 80% requires a sample size of at least 23 participants per condition. All experiments reported in the present manuscript exceed this minimum number of participants per condition.\n\n\nParticipants\nParticipants were recruited from an undergraduate population that is 63% female and consists almost entirely of individuals aged 18-22 years. A total of 110 Indiana University psychology students participated in Experiment 1. We subsequently excluded 34 participants poor performance at one of the dependent measures of the task (2.5-3 standard deviations worse than the median subject at the task) or for displaying a pattern of responses that was clearly indicative of a lack of engagement with the task (e.g. simply dropping the ball on each trial rather than throwing it at the target), or for reporting that they completed the experiment on a phone or tablet device, despite the instructions not to use one of these devices. A total of 74 participants were retained for the final analyses, 35 in the varied group and 39 in the constant group.\n\n\nTask\nThe experimental task was programmed in JavaScript, using packages from the Phaser physics engine (https://phaser.io) and the jsPsych library (de Leeuw, 2015). The stimuli, presented on a black background, consisted of a circular blue ball – controlled by the participant via the mouse or trackpad cursor; a rectangular green target; a red rectangular barrier located between the ball and the target; and an orange square within which the participant could control the ball before releasing it in a throw towards the target. Because the task was administered online, the absolute distance between stimuli could vary depending on the size of the computer monitor being used, but the relative distance between the stimuli was held constant. Likewise, the distance between the center of the target, and the training and testing locations was scaled such that relative distances were preserved regardless of screen size. For the sake of brevity, subsequent mentions of this relative distance between stimuli, or the position where the ball landed in relation to the center of the target, will be referred to simply as distance. Figure 2 displays the layout of the task, as it would appear to a participant at the start of a trial, with the ball appearing in the center of the orange square. Using a mouse or trackpad, participants click down on the ball to take control of the ball, connecting the movement of the ball to the movement of the cursor. Participants can then “wind up” the ball by dragging it (within the confines of the orange square) and then launch the ball by releasing the cursor. If the ball does not land on the target, participants are presented with feedback in red text at the top right of the screen, on how many units away they were from the center of the target. If the ball was thrown outside of the boundary of the screen participants are given feedback as to how far away from the target center the ball would have been if it had continued its trajectory. If the ball strikes the barrier (from the side or by landing on top), feedback is presented telling participants to avoid hitting the barrier. If participants drag the ball outside of the orange square before releasing it, the trial terminates, and they are reminded to release the ball within the orange square. If the ball lands on the target, feedback is presented in green text, confirming that the target was hit, and presenting additional feedback on how many units away the ball was from the exact center of the target.\nLink to abbrevaited example of task.\n\n\nCode\nmf &lt;- cowplot::ggdraw()+cowplot::draw_image(here::here(\"Assets/methodsFig1.png\"),hjust=0)+theme(plot.margin = margin(0, 0, 0, 0))\nplot_grid(mf,ncol=1)\n\n\n\n\n\n\n\n\nFigure 2: The stimuli of the task consisted of a blue ball, which the participants would launch at the green target, while avoiding the red barrier. On each trial, the ball would appear in the center of the orange square, with the position of the orange square varying between experimental conditions. Participants were constrained to release the ball within the square",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#results",
    "href": "Sections/full.html#results",
    "title": "Full Dissertation",
    "section": "Results",
    "text": "Results",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#data-processing-and-statistical-packages",
    "href": "Sections/full.html#data-processing-and-statistical-packages",
    "title": "Full Dissertation",
    "section": "Data Processing and Statistical Packages",
    "text": "Data Processing and Statistical Packages\nTo prepare the data, we first removed trials that were not easily interpretable as performance indicators in our task. Removed trials included: 1) those in which participants dragged the ball outside of the orange starting box without releasing it, 2) trials in which participants clicked on the ball, and then immediately released it, causing the ball to drop straight down, 3) outlier trials in which the ball was thrown more than 2.5 standard deviations further than the average throw (calculated separately for each throwing position), and 4) trials in which the ball struck the barrier. The primary measure of performance used in all analyses was the absolute distance away from the center of the target. The absolute distance was calculated on every trial, and then averaged within each subject to yield a single performance score, for each position. A consistent pattern across training and testing phases in both experiments was for participants to perform worse from throwing positions further away from the target – a pattern which we refer to as the difficulty of the positions. However, there were no interactions between throwing position and training conditions, allowing us to collapse across positions in cases where contrasts for specific positions were not of interest. All data processing and statistical analyses were performed in R version 4.03 (R Core Team, 2020). ANOVAs for group comparisons were performed using the rstatix package (Kassambara, 2021)****.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#training-phase",
    "href": "Sections/full.html#training-phase",
    "title": "Full Dissertation",
    "section": "Training Phase",
    "text": "Training Phase\nFigure 3 below shows aggregate training performance binned into three stages representing the beginning, middle, and end of the training phase. Because the two conditions trained from target distances that were not equally difficult, it was not possible to directly compare performance between conditions in the training phase. Our focus for the training data analysis was instead to establish that participants did improve their performance over the course of training, and to examine whether there was any interaction between training stage and condition. Descriptive statistics for the intermittent testing phase are provided in the supplementary materials.\nWe performed an ANOVA comparison with stage as a within-group factor and condition as between-group factor. The analysis revealed a significant effect of training stage F(2,142)=62.4, p&lt;.001, \\(\\eta^{2}_G\\) = .17, such that performance improved over the course of training There was no significant effect of condition F(1,71)=1.42, p=.24, \\(\\eta^{2}_G\\) = .02, and no significant interaction between condition and training stage, F(2,142)=.10, p=.91, \\(\\eta^{2}_G\\) &lt; .01.\n\n\nCode\nexp1TrainPosition &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1) %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group,conditType,trainHalf,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1TrainPosition3 &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1) %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group,conditType,stage,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1Train &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1)  %&gt;%\n  group_by(sbjCode,Group,conditType,trainHalf) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\nexp1Train3 &lt;- e1 %&gt;% filter(stage!=\"Transfer\",mode==1)  %&gt;%\n  group_by(sbjCode,Group,conditType,stage) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),.groups = 'keep')\n\n\ne1train2 &lt;- exp1TrainPosition3 %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",fun=mean,position=dodge)+\n  facet_wrap(~conditType,ncol=2)+\n  stat_summary(aes(x=positionX,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+\n  ylab(\"Mean Distance From Center Of Target\")+\n  xlab(\"Training Location(s)\")+theme(plot.title = element_text(hjust = 0.5))+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)\n\n\n#plot_grid(title,e1train2,capt,ncol=1,rel_heights=c(.18,1,.15))\nplot_grid(e1train2,ncol=1)\n\n\n\n\n\n\n\n\nFigure 3: Training performance for varied and constant participants binned into three stages. Shorter bars indicate better performance (ball landing closer to the center of the target). Error bars indicate standard error of the mean.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#testing-phase",
    "href": "Sections/full.html#testing-phase",
    "title": "Full Dissertation",
    "section": "Testing Phase",
    "text": "Testing Phase\nIn Experiment 1, a single constant-trained group was compared against a single varied-trained group. At the transfer phase, all participants were tested from 3 positions: 1) the positions(s) from their own training, 2) the training position(s) of the other group, and 3) a position novel to both groups. Overall, group performance was compared with a mixed type III ANOVA, with condition (varied vs. constant) as a between-subject factor and throwing location as a within-subject variable. The effect of throwing position was strong, F(3,213) = 56.12, p&lt;.001, η2G = .23. The effect of training condition was significant F(1,71)=8.19, p&lt;.01, η2G = .07. There was no significant interaction between group and position, F(3,213)=1.81, p=.15, η2G = .01.\n\n\nCode\nexp1.Test &lt;- e1 %&gt;% filter(stage==\"Transfer\") %&gt;% select(-trainHalf)%&gt;% group_by(positionX) %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% \n  mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%\n  ungroup() %&gt;% group_by(sbjCode,conditType,positionX,ThrowPosition) %&gt;%\nsummarise(MeanTargetDeviance = mean(AbsDistFromCenter),MeanScaleDev = mean(scaledDev),.groups=\"keep\")%&gt;% as.data.frame()\n\n#manuscript plot\ne1test1=exp1.Test %&gt;% ggplot(aes(x=positionX,y=MeanTargetDeviance,group=conditType,fill=conditType))+\n  geom_bar(stat=\"summary\",fun=mean,position=dodge)+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+theme(plot.title = element_text(hjust = 0.5))+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)+scale_x_discrete(name=\"Testing Location\",labels=e1Labels)\n\ne1test1\n\n\n\n\n\n\n\n\nFigure 4: Testing performance for each of the 4 testing positions, compared between training conditions. Positions 610 and 910 were trained on by the varied group, and novel for the constant group. Position 760 was trained on by the constant group, and novel for the varied group. Position 835 was novel for both groups. Shorter bars are indicative of better performance (the ball landing closer to the center of the target). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\nCode\nexp1.Test &lt;- e1 %&gt;% filter(stage==\"Transfer\") %&gt;% select(-trainHalf)%&gt;% group_by(positionX) %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% \n  mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%\n  ungroup() %&gt;% group_by(sbjCode,conditType,positionX,ThrowPosition) %&gt;%\nsummarise(MeanTargetDeviance = mean(AbsDistFromCenter),MeanScaleDev = mean(scaledDev),.groups=\"keep\")%&gt;% as.data.frame()\n\n\ntest= exp1.Test %&gt;% dplyr::rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n   summarise(Mean=round(mean(MeanTargetDeviance),2),sd=round(sd(MeanTargetDeviance),2),.groups=\"keep\")\n test=test %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n test = test %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n test=test[,1:3]\n\nkable(test,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") # %&gt;%  # kable_classic() #%&gt;% kableExtra::footnote(general=captionText,general_title = \"\")\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n610\n132.48(50.85)\n104.2(38.92)\n\n\n760\n207.26(89.19)\n167.12(72.29)\n\n\n835\n249.13(105.92)\n197.22(109.71)\n\n\n910\n289.36(122.48)\n212.86(113.93)",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#discussion",
    "href": "Sections/full.html#discussion",
    "title": "Full Dissertation",
    "section": "Discussion",
    "text": "Discussion\nIn Experiment 1, we found that varied training resulted in superior testing performance than constant training, from both a position novel to both groups, and from the position at which the constant group was trained, which was novel to the varied condition. The superiority of varied training over constant training even at the constant training position is of particular note, given that testing at this position should have been highly similar for participants in the constant condition. It should also be noted, though, that testing at the constant trained position is not exactly identical to training from that position, given that the context of testing is different in several ways from that of training, such as the testing trials from the different positions being intermixed, as well as a simple change in context as a function of time. Such contextual differences will be further considered in the General Discussion.\nIn addition to the variation of throwing position during training, the participants in the varied condition of Experiment 1 also received training practice from the closest/easiest position, as well as from the furthest/most difficult position that would later be encountered by all participants during testing. The varied condition also had the potential advantage of interpolating both of the novel positions from which they would later be tested. Experiment 2 thus sought to address these issues by comparing a varied condition to multiple constant conditions.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#methods-1",
    "href": "Sections/full.html#methods-1",
    "title": "Full Dissertation",
    "section": "Methods",
    "text": "Methods\n\nParticipants\nA total of 306 Indiana University psychology students participated in Experiment 2, which was also conducted online. As was the case in experiment 1, the undergraduate population from which we recruited participants was 63% female and primarily composed of 18–22-year-old individuals. Using the same procedure as experiment 1, we excluded 98 participants for exceptionally poor performance at one of the dependent measures of the task, or for displaying a pattern of responses indicative of a lack of engagement with the task. A total of 208 participants were included in the final analyses with 31 in the varied group and 32, 28, 37, 25, 29, 26 participants in the constant groups training from location 400, 500, 625, 675, 800, and 900, respectively. All participants were compensated with course credit.\n\n\nTask and Procedure\nThe task of Experiment 2 was identical to that of Experiment 1, in all but some minor adjustments to the height of the barrier, and the relative distance between the barrier and the target. Additionally, the intermittent testing trials featured in experiment 1 were not utilized in experiment 2, and all training and testing trials were presented with feedback. An abbreviated demo of the task used for Experiment 2 can be found at (https://pcl.sitehost.iu.edu/tg/demos/igas_expt2_demo.html).\nThe procedure for Experiment 2 was also quite similar to experiment 1. Participants completed 140 training trials, all of which were from the same position for the constant groups and split evenly (70 trials each - randomized) for the varied group. In the testing phase, participants completed 30 trials from each of the six locations that had been used separately across each of the constant groups during training. Each of the constant groups thus experience one trained location and five novel throwing locations in the testing phase, while the varied group experiences 2 previously trained, and 4 novel locations.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#results-1",
    "href": "Sections/full.html#results-1",
    "title": "Full Dissertation",
    "section": "Results",
    "text": "Results\n\nData Processing and Statistical Packages\nAfter confirming that condition and throwing position did not have any significant interactions, we standardized performance within each position, and then average across position to yield a single performance measure per participant. This standardization did not influence our pattern of results. As in experiment 1, we performed type III ANOVA’s due to our unbalanced design, however the pattern of results presented below is not altered if type 1 or type III tests are used instead. The statistical software for the primary analyses was the same as for experiment 1. Individual learning rates in the testing phase, compared between groups in the supplementary analyses, were fit using the TEfit package in R (Cochrane, 2020).\n\n\nTraining Phase\nThe different training conditions trained from positions that were not equivalently difficult and are thus not easily amenable to comparison. As previously stated, the primary interest of the training data is confirmation that some learning did occur. Figure 5 depicts the training performance of the varied group alongside that of the aggregate of the six constant groups (5a), and each of the 6 separate constant groups (5b). An ANOVA comparison with training stage (beginning, middle, end) as a within-group factor and group (the varied condition vs. the 6 constant conditions collapsed together) as a between-subject factor revealed no significant effect of group on training performance, F(1,206)=.55,p=.49, \\(\\eta^{2}_G\\) &lt;.01, a significant effect of training stage F(2,412)=77.91, p&lt;.001, \\(\\eta^{2}_G\\) =.05, and no significant interaction between group and training stage, F(2,412)=.489 p=.61, \\(\\eta^{2}_G\\) &lt;.01. We also tested for a difference in training performance between the varied group and the two constant groups that trained matching throwing positions (i.e., the constant groups training from position 500, and position 800). The results of our ANOVA on this limited dataset mirrors that of the full-group analysis, with no significant effect of group F(1,86)=.48, p=.49, \\(\\eta^{2}_G\\) &lt;.01, a significant effect of training stage F(2,172)=56.29, p&lt;.001, \\(\\eta^{2}_G\\) =.11, and no significant interaction between group and training stage, F(2,172)=.341 p=.71, \\(\\eta^{2}_G\\) &lt;.01.\n\n\nCode\ne2$stage &lt;- factor(e2$stage, levels = c(\"Beginning\", \"Middle\", \"End\",\"Transfer\"),ordered = TRUE)\n\nexp2TrainPosition &lt;- e2  %&gt;% filter(stage!=\"Transfer\") %&gt;%ungroup() %&gt;% \n  group_by(sbjCode,Group2,conditType,trainHalf,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter))%&gt;% as.data.frame()\n\nexp2TrainPosition3 &lt;- e2  %&gt;% filter(stage!=\"Transfer\") %&gt;%ungroup() %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup() %&gt;%\n  group_by(sbjCode,Group2,conditType,stage,positionX) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),MeanScaledDev=mean(scaledDev,trim=.05))%&gt;% as.data.frame()\n\nexp2Train &lt;- e2  %&gt;% filter(stage!=\"Transfer\")  %&gt;% \n  group_by(sbjCode,Group2,conditType,trainHalf) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter)) %&gt;% as.data.frame()\n\nexp2Train3 &lt;- e2  %&gt;% filter(stage!=\"Transfer\")  %&gt;% ungroup() %&gt;% \n  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup() %&gt;%\n  group_by(sbjCode,Group2,conditType,stage) %&gt;% \n  summarise(MeanTargetDistance=mean(AbsDistFromCenter),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;% as.data.frame()\n\ntransfer &lt;- filter(e2, stage==\"Transfer\") %&gt;% droplevels() %&gt;% select(-trainHalf,-initialVelocityY,ThrowPosition2)%&gt;% ungroup()\ntransfer &lt;- transfer %&gt;% group_by(positionX) %&gt;% mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n  group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup()\n\ntransfer &lt;- transfer %&gt;% group_by(sbjCode,positionX) %&gt;% mutate(ind=1,testPosIndex=cumsum(ind),posN=max(testPosIndex)) %&gt;%\n  select(-ind) %&gt;% mutate(testHalf = case_when(testPosIndex&lt;15 ~\"1st Half\",testPosIndex&gt;=15 ~\"2nd Half\")) %&gt;% rstatix::convert_as_factor(testHalf)\n\nvariedTest &lt;- transfer %&gt;% filter(condit==7) %&gt;% mutate(extrapolate=ifelse(positionX==\"900\" | positionX==\"400\",\"extrapolation\",\"interpolation\")) \nconstantTest &lt;- transfer %&gt;% filter(condit!=7) %&gt;% mutate(extrapolate=ifelse(distFromTrain==0,\"interpolation\",\"extrapolation\"))\n\ntransfer &lt;- rbind(variedTest,constantTest)\ntransfer&lt;- transfer %&gt;% mutate(novel=ifelse(distFromTrain3==0,\"trainedLocation\",\"novelLocation\"))%&gt;% rstatix::convert_as_factor(novel,extrapolate)\n\ntransfer &lt;- transfer %&gt;% relocate(sbjCode,condit2,Group,conditType2,stage,trial,novel,extrapolate,positionX,AbsDistFromCenter,globalAvg,globalSd,scaledDev,distFromTrain3) %&gt;% ungroup()\n\n\n# novelAll &lt;- transfer %&gt;% filter(distFromTrain!=0, distFromTrain3!=0) %&gt;% select(-globalAvg,-globalSd,-scaledDev)%&gt;% droplevels() %&gt;% ungroup()\n# novelAll &lt;- novelAll %&gt;% group_by(positionX) %&gt;%\n#  mutate(globalAvg=mean(AbsDistFromCenter),globalSd=sd(AbsDistFromCenter)) %&gt;% \n#   group_by(sbjCode,positionX) %&gt;% mutate(scaledDev = scaleVar(globalAvg,globalSd,AbsDistFromCenter)) %&gt;%ungroup()\n\nnovelAll &lt;- transfer %&gt;% filter(distFromTrain!=0, distFromTrain3!=0)\nnovelAllMatched &lt;- novelAll %&gt;% filter(condit!=5,condit!=2)\n\n\nconstantIden &lt;- transfer %&gt;% filter(condit !=7,distFromTrain==0) # only constant groups from their training position\nvariedTest &lt;- transfer %&gt;% filter(condit==7) # only varied testing\nvariedVsIden &lt;- rbind(constantIden,variedTest) # all varied combined with constant identity\n\n\nvariedNovel &lt;- variedTest %&gt;% filter(distFromTrain3 !=0) # removes 500 and 800 from varied\nconstantIden2 &lt;- transfer %&gt;% filter(condit !=7,condit!=5,condit!=2,distFromTrain==0) # only constant groups from training position 400,625,675,900\nvariedVsNovelIden &lt;- rbind(constantIden2,variedNovel) # novel positions for varied, trained for constant\n\nexp2.Test &lt;- transfer %&gt;%group_by(sbjCode,conditType,positionX,ThrowPosition)%&gt;%\n  summarise(MeanTargetDeviance = mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;%ungroup() %&gt;% as.data.frame()\n\nexp2.Test2 &lt;- exp2.Test %&gt;% group_by(sbjCode,conditType)%&gt;%\n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;%ungroup() %&gt;% as.data.frame()\n\nexp2.Test7 &lt;- transfer %&gt;%group_by(Group2,sbjCode,positionX,Group,conditType,ThrowPosition4) %&gt;% \n  summarise(MeanTargetDeviance = mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05)) %&gt;% as.data.frame()\n\nexp2.Test7.agg &lt;- exp2.Test7  %&gt;%group_by(Group2,sbjCode,Group,conditType) %&gt;% \n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;% as.data.frame()\n\nexp2.Test7.agg2 &lt;- exp2.Test7  %&gt;%group_by(sbjCode,conditType) %&gt;% \n  summarise(MeanTargetDeviance = mean(MeanTargetDeviance),MeanScaledDev=mean(MeanScaledDev)) %&gt;% as.data.frame()\n\n\n\n\nCode\n### New - 3 stage\ne2train1&lt;-exp2TrainPosition3 %&gt;% ggplot(aes(x=stage,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",position=dodge,fun=\"mean\")+\n  stat_summary(aes(x=stage,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+facet_wrap(~conditType,ncol=2)+\n  ylab(\"Mean Distance From Center Of Target\") +xlab(\"Training Stage\")+\n  theme(plot.title = element_text(face=\"bold\",hjust = 0.0,size=9),\n        plot.title.position = \"plot\")+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)+ggtitle(\"A\")\n\ne2train2&lt;-exp2TrainPosition3 %&gt;% ggplot(aes(x=positionX,y=MeanTargetDistance))+\n  geom_bar(aes(group=stage,fill=stage),stat=\"summary\",position=dodge,fun=\"mean\")+\n  facet_wrap(~conditType,ncol=2)+stat_summary(aes(x=positionX,group=stage),fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.8)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Training Location(s)\")+\n  theme(plot.title = element_text(face=\"bold\",hjust = 0,size=9),\n        plot.title.position = \"plot\")+\n  guides(fill=guide_legend(title=\"Training Stage\"))+theme(legend.title.align=.25)+ggtitle(\"B\")\n\n#plot_grid(e2train1,e2train2,ncol=1)\n\ne2train1/e2train2\n\n\n\n\n\n\n\n\nFigure 5: Training performance for the six constant conditions, and the varied condition, binned into three stages. On the left side, the six constant groups are averaged together, as are the two training positions for the varied group. On the right side, the six constant groups are shown separately, with each set of bars representing the beginning, middle, and end of training for a single constant group that trained from the position indicated on the x-axis. Figure 5b also shows training performance separately for both of the throwing locations trained by the varied group. Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\nTesting Phase\nIn Experiment 2, a single varied condition (trained from two positions, 500 and 800), was compared against six separate constant groups (trained from a single position, 400, 500, 625, 675, 800 or 900). For the testing phase, all participants were tested from all six positions, four of which were novel for the varied condition, and five of which were novel for each of the constant groups. For a general comparison, we took the absolute deviations for each throwing position and computed standardized scores across all participants, and then averaged across throwing position. The six constant groups were then collapsed together allowing us to make a simple comparison between training conditions (constant vs. varied). A type III between-subjects ANOVA was performed, yielding a significant effect of condition F(1,206)=4.33, p=.039, \\(\\eta^{2}_G\\) =.02. Descriptive statistics for each condition are shown in table 2. In Figure 6 visualizes the consistent advantage of the varied condition over the constant groups across the testing positions. Figure 6 shows performance between the varied condition and the individual constant groups.\n\n\nCode\n# manuscript plot\ne2test1&lt;-exp2.Test %&gt;% ggplot(aes(x=ThrowPosition,y=MeanTargetDeviance,group=conditType,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+guides(fill=guide_legend(title=\"Training Condition\"))+\n  theme(plot.title=element_text(face=\"bold\",size=9),\n        plot.title.position = \"plot\",\n        legend.title.align=.25)+\n  ggtitle(\"A\")\n\n\ne2test2&lt;-exp2.Test7 %&gt;% \n  ggplot(aes(x=Group,y=MeanTargetDeviance,group=conditType,fill=conditType))+\n  geom_bar(stat=\"summary\",position=position_dodge(),fun=\"mean\")+ \n  stat_summary(fun.data=mean_se,geom=\"errorbar\",position=position_dodge())+\n  facet_wrap(~ThrowPosition4)+\n  ylab(\"Mean Distance From Center Of Target\")+\n  guides(fill=guide_legend(title=\"Training Condition\"))+\n  theme(plot.title=element_text(face=\"bold\",size=9),\n        plot.title.position = \"plot\",\n        legend.title.align=.25,\n        axis.text.x = element_text(size = 7,angle=45,hjust=1))+\n  scale_x_discrete(name=\" Training Group\",labels=e2Labels)+ggtitle(\"B\")\n\ne2test1 / e2test2\n\n\n\n\n\n\n\n\nFigure 6: Testing phase performance from each of the six testing positions. The six constant conditions are averaged together into a single constant group, compared against the single varied-trained group.B) Transfer performance from each of the 6 throwing locations from which all participants were tested. Each bar represents performance from one of seven distinct training groups (six constant groups in red, one varied group in blue). The x axis labels indicate the location(s) from which each group trained. Lower values along the y axis reflect better performance at the task (closer distance to target center). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\n\nCode\ntab2= exp2.Test %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n   summarise(Mean=round(mean(MeanTargetDeviance),2),sd=round(sd(MeanTargetDeviance),2),.groups=\"keep\")\n tab2=tab2 %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n tab2 = tab2 %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% \n   select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab2=tab2[,1:3]\n\n\nkable(tab2,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") #%&gt;% kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 1: Transfer performance from each of the 6 throwing locations from which all participants were tested. Each bar represents performance from one of seven distinct training groups (six constant groups in red, one varied group in blue). The x axis labels indicate the location(s) from which each group trained. Lower values along the y axis reflect better performance at the task (closer distance to target center). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n100.59(46.3)\n83.92(33.76)\n\n\n500\n152.28(69.82)\n134.38(61.38)\n\n\n625\n211.21(90.95)\n183.51(75.92)\n\n\n675\n233.32(93.35)\n206.32(94.64)\n\n\n800\n283.24(102.85)\n242.65(89.73)\n\n\n900\n343.51(114.33)\n289.62(110.07)\n\n\n\n\n\n\n\n\n\n\n\nNext, we compared the testing performance of constant and varied groups from only positions that participants had not encountered during training. Constant participants each had 5 novel positions, whereas varied participants tested from 4 novel positions (400,625,675,900). We first standardized performance within in each position, and then averaged across positions. Here again, we found a significant effect of condition (constant vs. varied): F(1,206)=4.30, p=.039, \\(\\eta^{2}_G\\) = .02 .\n\n\nCode\nsum.novelAll &lt;- novelAll %&gt;% group_by(sbjCode,conditType,positionX) %&gt;% \n  summarise(MeanTargetDev=mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05),.groups=\"keep\") %&gt;% as.data.frame()\n\ntab3=sum.novelAll %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n  summarise(Mean=round(mean(MeanTargetDev),2),sd=round(sd(MeanTargetDev),2),.groups=\"keep\")\n\n tab3=tab3 %&gt;% group_by(Condition) %&gt;% mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n \n tab3 = tab3 %&gt;% \n   mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab3=tab3[,1:3]\n\n\n\nkable(tab3,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") #%&gt;% kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 2: Testing performance from novel positions. Includes data only from positions that were not encountered during the training stage (e.g. excludes positions 500 and 800 for the varied group, and one of the six locations for each of the constant groups). Table presents Mean absolute deviations from the center of the target, and standard deviations in parenthesis.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n98.84(45.31)\n83.92(33.76)\n\n\n500\n152.12(69.94)\nNA\n\n\n625\n212.91(92.76)\n183.51(75.92)\n\n\n675\n232.9(95.53)\n206.32(94.64)\n\n\n800\n285.91(102.81)\nNA\n\n\n900\n346.96(111.35)\n289.62(110.07)\n\n\n\n\n\n\n\n\n\n\n\nFinally, corresponding to the comparison of position 760 from experiment 1, we compared the test performance of the varied group against the constant group from only the positions that the constant groups trained. Such positions were novel to the varied group (thus this analysis omitted two constant groups that trained from positions 500 or 800 as those positions were not novel to the varied group). Figure 7 displays the particular subset of comparisons utilized for this analysis. Again, we standardized performance within each position before performing the analyses on the aggregated data. In this case, the effect of condition did not reach statistical significance F(1,149)=3.14, p=.079, \\(\\eta^{2}_G\\) = .02. Table 4 provides descriptive statistics.\n\n\nCode\nsum.variedVsNovelIden &lt;- variedVsNovelIden  %&gt;%\n  group_by(sbjCode,conditType,positionX) %&gt;% \n  summarise(MeanTargetDev=mean(AbsDistFromCenter,trim=.05),MeanScaledDev=mean(scaledDev,trim=.05),.groups=\"keep\") %&gt;% as.data.frame()\n\ne2Test2 &lt;- sum.variedVsNovelIden %&gt;% ggplot(aes(x=positionX,y=MeanTargetDev,group=conditType,fill=conditType))+geom_bar(stat=\"summary\",position=dodge,fun=\"mean\")+ stat_summary(fun.data=mean_se,geom=\"errorbar\",position=dodge,width=.5)+ylab(\"Mean Distance From Center Of Target\") +xlab(\"Testing Location\")+theme(plot.title = element_text(hjust = 0.5))+guides(fill=guide_legend(title=\"Training Condition\"))+theme(legend.title.align=.25)\n\n\ne2Test2\n\n\n\n\n\n\n\n\nFigure 7: A comparison of throwing location that are identical to those trained by the constant participants (e.g. constant participants trained at position 900, tested from position 900), which are also novel to the varied-trained participants (thus excluding positions 500 and 800). Error bars indicate standard error of the mean.\n\n\n\n\n\n\n\n\n\n\nCode\ntab4=sum.variedVsNovelIden %&gt;% rename(Condition=\"conditType\") %&gt;% group_by(Condition,positionX) %&gt;%\n  summarise(Mean=round(mean(MeanTargetDev),2),sd=round(sd(MeanTargetDev),2),.groups=\"keep\")\n\ntab4=tab4 %&gt;% group_by(Condition) %&gt;% \n   mutate(GroupAvg=round(mean(Mean),2),groupSd=round(sd(Mean),2))\n \ntab4 = tab4 %&gt;% mutate(msd=paste(Mean,\"(\",sd,\")\",sep=\"\"),gsd=paste(GroupAvg,\"(\",groupSd,\")\",sep=\"\")) %&gt;% select(positionX,Condition,msd,gsd)%&gt;%pivot_wider(names_from = Condition,values_from=c(msd,gsd))\n tab4=tab4[,1:3]\n\nkable(tab4,escape=FALSE,booktabs=TRUE,col.names=c(\"Position\",\"Constant\",\"Varied\"),align=c(\"l\"))  %&gt;% kableExtra::kable_styling(position=\"left\") #%&gt;% kable_classic() #%&gt;% footnote(general=captionText,general_title = \"\")\n\n\n\n\nTable 3: Testing performance from the locations trained by constant participants and novel to varied participants. Locations 500 and 800 are not included as these were trained by the varied participants. Table presents Mean absolute deviation from the center of the target, and standard deviations in parenthesis.\n\n\n\n\n\n\n\nPosition\nConstant\nVaried\n\n\n\n\n400\n108.85(50.63)\n83.92(33.76)\n\n\n625\n204.75(84.66)\n183.51(75.92)\n\n\n675\n235.75(81.15)\n206.32(94.64)\n\n\n900\n323.5(130.9)\n289.62(110.07)",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#discussion-1",
    "href": "Sections/full.html#discussion-1",
    "title": "Full Dissertation",
    "section": "Discussion",
    "text": "Discussion\nThe results of experiment 2 largely conform to the findings of experiment 1. Participants in both varied and constant conditions improved at the task during the training phase. We did not observe the common finding of training under varied conditions producing worse performance during acquisition than training under constant conditions (Catalano & Kleiner, 1984; Wrisberg et al., 1987), which has been suggested to relate to the subsequent benefits of varied training in retention and generalization testing (Soderstrom & Bjork, 2015). However our finding of no difference in training performance between constant and varied groups has been observed in previous work (Chua et al., 2019; Moxley, 1979; Pigott & Shapiro, 1984).\nIn the testing phase, our varied group significantly outperformed the constant conditions in both a general comparison, and in an analysis limited to novel throwing positions. The observed benefit of varied over constant training echoes the findings of many previous visuomotor skill learning studies that have continued to emerge since the introduction of Schmidt’s influential Schema Theory (Catalano & Kleiner, 1984; Chua et al., 2019; Goodwin et al., 1998; McCracken & Stelmach, 1977; Moxley, 1979; Newell & Shapiro, 1976; Pigott & Shapiro, 1984; Roller et al., 2001; Schmidt, 1975; Willey & Liu, 2018b; Wrisberg et al., 1987; Wulf, 1991). We also join a much smaller set of research to observe this pattern in a computerized task (Seow et al., 2019). One departure from the experiment 1 findings concerns the pattern wherein the varied group outperformed the constant group even from the training position of the constant group, which was significant in experiment 1, but did not reach significance in experiment 2. Although this pattern has been observed elsewhere in the literature (Goode et al., 2008; Kerr & Booth, 1978), the overall evidence for this effect appears to be far weaker than for the more general benefit of varied training in conditions novel to all training groups.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#fitting-model-parameters-separately-by-group",
    "href": "Sections/full.html#fitting-model-parameters-separately-by-group",
    "title": "Full Dissertation",
    "section": "Fitting model parameters separately by group",
    "text": "Fitting model parameters separately by group\nTo directly control for similarity in Experiment 2, we developed a model-based measure of the similarity between training throws and testing conditions. This similarity measure was a significant predictor of testing performance, e.g., participants whose training throws were more similar to throws that resulted in target hits from the testing positions, tended to perform better during the testing phase. Importantly, the similarity measure did not explain away the group-level benefits of varied training, which remained significant in our linear model predicting testing performance after similarity was added to the model. However, previous research has suggested that participants may differ in their level of generalization as a function of prior experience, and that such differences in generalization gradients can be captured by fitting the generalization parameter of an instance-based model separately to each group (Hahn et al., 2005; Lamberts, 1994). Relatedly, the influential Bayesian generalization model developed by Tenenbaum & Griffiths (2001) predicts that the breadth of generalization will increase when a rational agent encounters a wider variety of examples. Following these leads, we assume that in addition to learning the task itself, participants are also adjusting how generalizable their experience should be. Varied versus constant participants may be expected to learn to generalize their experience to different degrees. To accommodate this difference, the generalization parameter of the instance-based model (in the present case, the c parameter) can be allowed to vary between the two groups to reflect the tendency of learners to adaptively tune the extent of their generalization. One specific hypothesis is that people adaptively set a value of c to fit the variability of their training experience (Nosofsky & Johansen, 2000; Sakamoto et al., 2006). If one’s training experience is relatively variable, as with the variable training condition, then one might infer that future test situations will also be variable, in which case a low value of c will allow better generalization because generalization will drop off slowly with training-to-testing distance. Conversely, if one’s training experience has little variability, as found in the constant training conditions, then one might adopt a high value of c so that generalization falls off rapidly away from the trained positions.\nTo address this possibility, we compared the original instance-based model of similarity fit against a modified model which separately fits the generalization parameter, c, to varied and constant participants. To perform this parameter fitting, we used the optim function in R, and fit the model to find the c value(s) that maximized the correlation between similarity and testing performance.\nBoth models generate distinct similarity values between training and testing locations. Much like the analyses in Experiment 2, these similarity values are regressed against testing performance in models of the form shown below. As was the case previously, testing performance is defined as the mean absolute distance from the center of the target (with a separate score for each participant, from each position).\nLinear models 1 and 3 both show that similarity is a significant predictor of testing performance (p&lt;.01). Of greater interest is the difference between linear model 2, in which similarity is computed from a single c value fit from all participants (Similarity1c), with linear model 4, which fits the c parameter separately between groups (Similarity2c). In linear model 2, the effect of training group remains significant when controlling for Similarity1c (p&lt;.01), with the varied group still performing significantly better. However, in linear model 4 the addition of the Similarity2c predictor results in the effect of training group becoming nonsignificant (p=.40), suggesting that the effect of varied vs. constant training is accounted for by the Similarity2c predictor. Next, to further establish a difference between the models, we performed nested model comparisons using ANOVA, to see if the addition of the training group parameter led to a significant improvement in model performance. In the first comparison, ANOVA(Linear Model 1, Linear Model 2), the addition of the training group predictor significantly improved the performance of the model (F=22.07, p&lt;.01). However, in the second model comparison, ANOVA (Linear model 3, Linear Model 4) found no improvement in model performance with the addition of the training group predictor (F=1.61, p=.20).\nFinally, we sought to confirm that similarity values generated from the adjusted Similarity2c model had more predictive power than those generated from the original Similarity1c model. Using the BIC function in R, we compared BIC values between linear model 1 (BIC=14604.00) and linear model 3 (BIC = 14587.64). The lower BIC value of model 3 suggests a modest advantage for predicting performance using a similarity measure computed with two c values over similarity computed with a single c value. When fit with separate c values, the best fitting c parameters for the model consistently optimized such that the c value for the varied group (c=.00008) was smaller in magnitude than the c value for the constant group(c= .00011). Recall that similarity decreases as a Gaussian function of distance (equation 1 above), and a smaller value of c will result in a more gradual drop-off in similarity as the distance between training throws and testing solutions increases.\nIn summary, our modeling suggests that an instance-based model which assumes equivalent generalization gradients between constant and varied trained participants is unable to account for the extent of benefits of varied over constant training observed at testing. The evidence for this in the comparative model fits is that when a varied/constant dummy-coded variable for condition is explicitly added to the model, the variable adds a significant contribution to the prediction of test performance, with the variable condition yielding better performance than the constant conditions. However, if the instance-based generalization model is modified to assume that the training groups can differ in the steepness of their generalization gradient, by incorporating a separate generalization parameter for each group, then the instance-based model can account for our experimental results without explicitly taking training group into account. Henceforth this model will be referred to as the Instance-based Generalization with Adaptive Similarity (IGAS) model.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#limitations",
    "href": "Sections/full.html#limitations",
    "title": "Full Dissertation",
    "section": "Limitations",
    "text": "Limitations\nA limitation of this study concerns the ordering of the testing/transfer trials at the conclusion of both experiments. Participants were tested from each separate position (4 in Experiment 1, 6 in Experiment 2) in a random, intermixed order. Because the varied group was trained from two positions that were also randomly ordered, they may have benefited from experience with this type of sequencing, whereas the constant groups had no experience with switching between positions trial to trial. This concern is somewhat ameliorated by the fact that the testing phase performance of the constant groups from their trained position was not significantly worse than their level of performance at the end of the training phase, suggesting that they were not harmed by random ordering of positions during testing. It should also be noted that the computerized task utilized in the present work is relatively simple compared to many of the real-world tasks utilized in prior research. It is thus conceivable that the effect of variability in more complex tasks is distinct from the process put forward in the present work. An important challenge for future work will be to assess the extent to which IGAS can account for generalization in relatively complex tasks with far more degrees of freedom.\nIt is common for psychological process models of categorization learning to use an approach such as multidimensional scaling so as to transform the stimuli from the physical dimensions used in the particular task into the psychological dimensions more reflective of the actual human representations (Nosofsky, 1992; Shepard, 1987). Such scaling typically entails having participants rate the similarity between individual items and using these similarity judgements to then compute the psychological distances between stimuli, which can then be fed into a subsequent model. In the present investigation, there was no such way to scale the x and y velocity components in terms of the psychological similarity, and thus our modelling does rely on the assumption that the psychological distances between the different throwing positions are proportional to absolute distances in the metric space of the task (e.g. the relative distance between positions 400 and 500 is equivalent to that between 800 and 900). However, an advantage of our approach is that we are measuring similarity in terms of how participants behave (applying a velocity to the ball), rather than the metric features of the task stimuli.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#conclusion",
    "href": "Sections/full.html#conclusion",
    "title": "Full Dissertation",
    "section": "Conclusion",
    "text": "Conclusion\nOur experiments demonstrate a reliable benefit of varied training in a simple projectile launching task. Such results were accounted for by an instance-based model that assumes that varied training results in the computation of a broader similarity-based generalization gradient. Instance-based models augmented with this assumption may be a valuable approach towards better understanding skill generalization and transfer.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#function-learning-and-extrapolation",
    "href": "Sections/full.html#function-learning-and-extrapolation",
    "title": "Full Dissertation",
    "section": "Function Learning and Extrapolation",
    "text": "Function Learning and Extrapolation\nThe study of human function learning investigates how people learn relationships between continuous input and output values. Function learning is studied both in tasks where individuals are exposed to a sequence of input/output pairs (DeLosh et al., 1997; McDaniel et al., 2013), or situations where observers are presented with a an incomplete scatterplot or line graph and make predictions about regions of the plot that don’t contain data (Ciccione & Dehaene, 2021; Courrieu, 2012; Said & Fischer, 2021; Schulz et al., 2020).\nCarroll (1963) conducted the earliest work on function learning. Input stimuli and output responses were both lines of varying length. The correct output response was related to the length of the input line by a linear, quadratic, or random function. Participants in the linear and quadratic performed above chance levels during extrapolation testing, with those in the linear condition performing the best overall. Carroll argued that these results were best explained by a ruled based model wherein learners form an abstract representation of the underlying function. Subsequent work by Brehmer (1974),testing a wider array of functional forms, provided further evidence for superior extrapolation in tasks with linear functions. Brehmer argued that individuals start out with an assumption of a linear function, but given sufficient error will progressively test alternative hypothesis with polynomials of greater degree. Koh & Meyer (1991) employed a visuomotor function learning task, wherein participants were trained on examples from an unknown function relating the length of an input line to the duration of a response (time between keystrokes). In this domain, participants performed best when the relation between line length and response duration was determined by a power, as opposed to linear function. Koh & Meyer developed the log-polynomial adaptive-regression model to account for their results.\nThe first significant challenge to the rule-based accounts of function learning was put forth by DeLosh et al. (1997) . In their task, participants learned to associate stimulus magnitudes with response magnitudes that were related via either linear, exponential, or quadratic function. Participants approached ceiling performance by the end of training in each function condition, and were able to correctly respond in interpolation testing trials. All three conditions demonstrated some capacity for extrapolation, however participants in the linear condition tended to underestimate the true function, while exponential and quadratic participants reliably overestimated the true function on extrapolation trials. Extrapolation and interpolation performance are depicted in Figure 10.\nThe authors evaluated both of the rule-based models introduced in earlier research (with some modifications enabling trial-by-trial learning). The polynomial hypothesis testing model (Brehmer, 1974; Carroll, 1963) tended to mimic the true function closely in extrapolation, and thus offered a poor account of the human data. The log-polynomial adaptive regression model (Koh & Meyer, 1991) was able to mimic some of the systematic deviations produced by human subjects, but also predicted overestimation in cases where underestimation occurred.\nThe authors also introduced two new function-learning models. The Associative Learning Model (ALM) and the extrapolation-association model (EXAM). ALM is a two layer connectionist model adapted from the ALCOVE model in the category learning literature (Kruschke, 1992). ALM belongs to the general class of radial-basis function neural networks, and can be considered a similarity-based model in the sense that the nodes in the input layer of the network are activated as a function of distance. The EXAM model retains the same similarity based activation and associative learning mechanisms as ALM, while being augmented with a linear rule response mechanism. When presented with novel stimuli, EXAM will retrieve the most similar input-output examples encountered during training, and from those examples compute a local slope. ALM was able to provide a good account of participant training and interpolation data in all three function conditions, however it was unable to extrapolate. EXAM, on the other hand, was able to reproduce both the extrapolation underestimation, as well as the quadratic and exponential overestimation patterns exhibited by the human participants. Subsequent research identified some limitations in EXAM’s ability to account for cases where human participants learn and extrapolate sinusoidal function Bott & Heit (2004) or to scenarios where different functions apply to different regions of the input space Kalish et al. (2004), though EXAM has been shown to provide a good account of human learning and extrapolation in tasks with bi-linear, V shaped input spaces Mcdaniel et al. (2009).\n\nVariability and Function Learning\nThe influence of variability on function learning tasks has received relatively little attention. The study by DeLosh et al. (1997) (described in detail above) did include a variability manipulation (referred to as density in their paper), wherein participants were trained with either either 8, 20, or 50 unique input-output pairs, with the total number of training trials held constant. They found a minimal influence of variability on training performance, and no difference between groups in interpolation or extrapolation, with all three variability conditions displaying accurate interpolation, and linearly biased extrapolation that was well accounted for by the EXAM model.\nIn the domain of visuomotor learning, van Dam & Ernst (2015) employed a task which required participants to learn a linear function between the spikiness of shape stimuli and the correct horizontal position to make a rapid pointing response. The shapes ranged from very spiky to completely circular at the extreme ends of the space. Participants trained with intermediate shapes from a lower variation (2 shapes) or higher variation (5 shapes) condition, with the 2 items of the lower varied condition matching the items used on the extreme ends of the higher variation training space. Learning was significantly slower in the higher variation group. However, the two conditions did not differ when tested with novel shapes, with both groups producing extrapolation responses of comparable magnitudes to the most similar training item, rather than in accordance with the true linear function. The authors accounted for both learning and extrapolation performance with a Bayesian learning model. Similar to ALM, the bayesian model assumes that generalization occurs as a Gaussian function of the distance between stimuli. However unlike ALM, the bayesian learning model utilizes more elaborate probabilistic stimulus representations, with a separate Kalman Filter for each shape stimulus.\n\n\n\n\n\n\n\n\nFigure 10: Generalization reproduced patterns from DeLosh et al. (1997) Figure 3. Stimulii that fall within the dashed lines are interpolations of the training examples.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#overview-of-present-study",
    "href": "Sections/full.html#overview-of-present-study",
    "title": "Full Dissertation",
    "section": "Overview Of Present Study",
    "text": "Overview Of Present Study\nThe present study investigates the influence of training variability on learning, generalization, and extrapolation in a uni-dimensional visuomotor function learning task. To the best of our knowledge, this research is the first to employ the classic constant vs. varied training manipulation, commonly used in the literature on the benefits of variability, in the context of a uni-dimensional function learning task. Across three experiments, we compare constant and varied training conditions in terms of learning performance, extrapolation accuracy, and the ability to reliably discriminate between stimuli.\nTo account for the empirical results, we will apply a series of computational models, including the Associative Learning Model (ALM) and the Extrapolation-Association Model (EXAM). Notably, this study is the first to employ approximate Bayesian computation (ABC) to fit these models to individual subject data, enabling us to thoroughly investigate the full range of posterior predictions of each model, and to examine the the ability of these influential models of function learning to account for both the group level and individual level data.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#methods-2",
    "href": "Sections/full.html#methods-2",
    "title": "Full Dissertation",
    "section": "Methods",
    "text": "Methods\nParticipants A total of 156 participants were recruited from the Indiana University Introductory Psychology Course. Participants were randomly assigned to one of two training conditions: varied training or constant training.\nTask. The “Hit The Wall” (HTW) visuomotor extrapolation task task was programmed in Javascript, making heavy use of the phaser.io game library. The HTW task involved launching a projectile such that it would strike the “wall” at target speed indicated at the top of the screen (see Figure 11). The target velocities were given as a range, or band, of acceptable velocity values (e.g. band 800-1000). During the training stage, participants received feedback indicating whether they had hit the wall within the target velocity band, or how many units their throw was above or below from the target band. Participants were instructed that only the x velocity component of the ball was relevant to the task. The y velocity, or the location at which the ball struck the wall, had no influence on the task feedback.\n/\n\n\n\n\n\n\n\n\nFigure 11: The Hit the wall task. Participants launch the blue ball to hit the red wall at the target velocity band indicated at the top of the screen. The ball must be released from within the orange square - but the location of release, and the location at which the ball strikes the wall are both irrelevant to the task feedback.\n\n\n\n\n\nProcedure. All participants completed the task online. Participants were provided with a description of the experiment and indicated informed consent. Figure 12 illustrates the general procedure. Participants completed a total of 90 trials during the training stage. In the varied training condition, participants encountered three velocity bands (800-1000, 1000-1200, and 1200-1400). Participants in the constant training condition trained on only one velocity band (800-1000) - the closest band to what would be the novel extrapolation bands in the testing stage.\nFollowing the training stage, participants proceeded immediately to the testing stage. Participants were tested from all six velocity bands, in two separate stages. In the novel extrapolation testing stage, participants completed “no-feedback” testing from three novel extrapolation bands (100-300, 350-550, and 600-800), with each band consisting of 15 trials. Participants were also tested from the three velocity bands that were trained by the varied condition (800-1000, 1000-1200, and 1200-1400). In the constant training condition, two of these bands were novel, while in the varied training condition, all three bands were encountered during training. The order in which participants completed the novel-extrapolation and testing-from-3-varied bands was counterbalanced across participants. A final training stage presented participants with “feedback” testing for each of the three extrapolation bands (100-300, 350-550, and 600-800).\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1\n\nTest  \nNovel Bands \n100-300\n350-550\n600-800\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n800-1000\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n100-300\n350-550\n600-800\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 12: Experiment 1 Design. Constant and Varied participants complete different training conditions.\n\n\n\n\n\n\n\nCode\n# pacman::p_load(dplyr,purrr,tidyr,tibble,ggplot2,\n#   brms,tidybayes, rstanarm,emmeans,broom,bayestestR,\n#   stringr, here,conflicted, patchwork, knitr)\n# #options(brms.backend=\"cmdstanr\",mc.cores=4)\n# options(digits=2, scipen=999, dplyr.summarise.inform=FALSE)\n# walk(c(\"brms\",\"dplyr\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\n# walk(c(\"Display_Functions\",\"org_functions\"), ~ source(here::here(paste0(\"Functions/\", .x, \".R\"))))\ne1 &lt;- readRDS(here(\"data/e1_08-21-23.rds\")) \ne1Sbjs &lt;- e1 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ntestE1 &lt;- e1 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE1 &lt;-  e1 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE1_max &lt;- trainE1 |&gt; filter(Trial_Bin == nbins, bandInt==800)\ntrainE1_avg &lt;- trainE1_max |&gt; group_by(id,condit) |&gt; summarise(avg = mean(dist))\n\n\n\nAnalyses Strategy\nAll data processing and statistical analyses were performed in R version 4.32 Team (2020). To assess differences between groups, we used Bayesian Mixed Effects Regression. Model fitting was performed with the brms package in R Bürkner (2017), and descriptive stats and tables were extracted with the BayestestR package Makowski et al. (2019). Mixed effects regression enables us to take advantage of partial pooling, simultaneously estimating parameters at the individual and group level. Our use of Bayesian, rather than frequentist methods allows us to directly quantify the uncertainty in our parameter estimates, as well as avoiding convergence issues common to the frequentist analogues of our mixed models.\nEach model was set to run with 4 chains, 5000 iterations per chain, with the first 2500 discarded as warmup chains. Rhat values were within an acceptable range, with values &lt;=1.02 (see appendix for diagnostic plots). We used uninformative priors for the fixed effects of the model (condition and velocity band), and weakly informative Student T distributions for for the random effects. For each model, we report 1) the mean values of the posterior distribution for the parameters of interest, 2) the lower and upper credible intervals (CrI), and the probability of direction value (pd).\n\n\n\n\n\n\n\n\nGroup Comparison\nCode\nData\n\n\n\n\nEnd of Training Accuracy\nbrm(dist ~ condit)\nFinal Training Block\n\n\nTest Accuracy\nbrm(dist ~ condit * bandType + (1|id) + (1|bandInt)\nAll Testing trials\n\n\nBand Discrimination\nbrm(vx ~ condit * band +(1 + bandInt|id)\nAll Testing Trials\n\n\n\n\n\nIn each experiment we compare varied and constant conditions in terms of 1) accuracy in the final training block; 2) testing accuracy as a function of band type (trained vs. extrapolation bands); 3) extent of discrimination between all six testing bands. We quantified accuracy as the absolute deviation between the response velocity and the nearest boundary of the target band. Thus, when the target band was velocity 600-800, throws of 400, 650, and 900 would result in deviation values of 200, 0, and 100, respectively. The degree of discrimination between bands was index by fitting a linear model predicting the response velocity as a function of the target velocity. Participants who reliably discriminated between velocity bands tended to haves slope values ~1, while participants who made throws irrespective of the current target band would have slopes ~0.\n\n\nResults\n\n\nCode\np1 &lt;- trainE1 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    facet_wrap(~vb)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e1_train_deviation.png\"), p1, width = 8, height = 4,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 13: Experiment 1 Training Stage. Deviations from target band across training blocks. Lower values represent greater accuracy.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e1-train-dist\n##| tbl-cap: \"Experiment 1 - Learning curves. \"\n##| output: asis\n\nbmm_e1_train&lt;- trainE1_max %&gt;% \n  brm(dist ~ condit, \n      file=here(\"data/model_cache/e1_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\nmtr1 &lt;- as.data.frame(describe_posterior(bmm_e1_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\ncolnames(mtr1) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\n# mtr1 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#    kable(booktabs = TRUE)\n\ncdtr1 &lt;- get_coef_details(bmm_e1_train, \"conditVaried\")\n\n\n\n\n\nTable 4: Experiment 1 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive estimates indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n106.34\n95.46\n117.25\n1\n\n\nconditVaried\n79.64\n57.92\n101.63\n1\n\n\n\n\n\n\n\n\nTraining. Figure 13 displays the average deviations across training blocks for the varied group, which trained on three velocity bands, and the constant group, which trained on one velocity band. To compare the training conditions at the end of training, we analyzed performance on the 800-1000 velocity band, which both groups trained on. The full model results are shown in Table 1. The varied group had a significantly greater deviation than the constant group in the final training block, (\\(\\beta\\) = 79.64, 95% CrI [57.92, 101.63]; pd = 100%).\n\n\nCode\n##| label: tbl-e1-bmm-dist\n##| tbl-cap: \"E1. Training vs. Extrapolation\"\n#| \nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e1_dist_Cond_Type_RF_2\")\nbmtd &lt;- brm(dist ~ condit * bandType + (1|bandInt) + (1|id), \n    data=testE1, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted1 &lt;- as.data.frame(describe_posterior(bmtd, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted1) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\n# r_bandInt_params &lt;- get_variables(bmtd)[grepl(\"r_bandInt\", get_variables(bmtd))]\n# posterior_summary(bmtd,variable=r_bandInt_params)\n# \n# r_bandInt_params &lt;- get_variables(bmtd)[grepl(\"r_id:bandInt\", get_variables(bmtd))]\n# posterior_summary(bmtd,variable=r_bandInt_params)\n\n# mted1 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt; kable(booktabs = TRUE)\ncdted1 &lt;- get_coef_details(bmtd, \"conditVaried\")\ncdted2 &lt;-get_coef_details(bmtd, \"bandTypeExtrapolation\")\ncdted3 &lt;-get_coef_details(bmtd, \"conditVaried:bandTypeExtrapolation\")\n\n\n\n\n\nTable 5: Experiment 1 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficients indicate larger deviations from the baselines (Condition=constant & bandType=Trained) - and a positive interaction coefficient indicates disproporionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n152.55\n70.63\n229.85\n1.0\n\n\nconditVaried\n39.00\n-21.10\n100.81\n0.9\n\n\nbandTypeExtrapolation\n71.51\n33.24\n109.60\n1.0\n\n\nconditVaried:bandTypeExtrapolation\n66.46\n32.76\n99.36\n1.0\n\n\n\n\n\n\nTesting. To compare accuracy between groups in the testing stage, we fit a Bayesian mixed effects model predicting deviation from the target band as a function of training condition (varied vs. constant) and band type (trained vs. extrapolation), with random intercepts for participants and bands. The model results are shown in Table 5. The main effect of training condition was not significant (\\(\\beta\\) = 39, 95% CrI [-21.1, 100.81]; pd = 89.93%). The extrapolation testing items had a significantly greater deviation than the training bands (\\(\\beta\\) = 71.51, 95% CrI [33.24, 109.6]; pd = 99.99%). Most importantly, the interaction between training condition and band type was significant (\\(\\beta\\) = 66.46, 95% CrI [32.76, 99.36]; pd = 99.99%), As shown in Figure 14, the varied group had disproportionately larger deviations compared to the constant group in the extrapolation bands.\n\n\nCode\npe1td &lt;- testE1 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe1ce &lt;- bmtd |&gt; emmeans( ~condit + bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\")\n\np2 &lt;- (pe1td + pe1ce) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e1_test-dev.png\"), p2, width=8, height=4, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 14: A) Deviations from target band during testing without feedback stage. B) Conditional effect of condition (Constant vs. Varied) and testing band type (training vs. extrapolation) on testing accuracy. Error bars represent 95% credible intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e1-bmm-vx\n##| tbl-cap: \"Experiment 1. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\ne1_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e1_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n#GetModelStats(e1_vxBMM) |&gt; kable(booktabs = TRUE)\n\ncd1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e1_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e1_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\n\n\n\nTable 6: Experiment 1. Bayesian Mixed Model Predicting velocity as a function of condition (Constant vs. Varied) and Velocity Band. Larger coefficients on Band represent greater sensitivity/discrimination.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n408.55\n327.00\n490.61\n1.00\n\n\nconditVaried\n164.05\n45.50\n278.85\n1.00\n\n\nBand\n0.71\n0.62\n0.80\n1.00\n\n\ncondit*Band\n-0.14\n-0.26\n-0.01\n0.98\n\n\n\n\n\n\nFinally, to assess the ability of both conditions to discriminate between velocity bands, we fit a model predicting velocity as a function of training condition and velocity band, with random intercepts and random slopes for each participant. See Table 7 for the full model results. The estimated coefficient for training condition (\\(\\beta\\) = 164.05, 95% CrI [45.5, 278.85], pd = 99.61%) suggests that the varied group tends to produce harder throws than the constant group, but is not in and of itself useful for assessing discrimination. Most relevant to the issue of discrimination is the coefficient on the Band predictor (\\(\\beta\\) = 0.71 95% CrI [0.62, 0.8], pd = 100%). Although the median slope does fall underneath the ideal of value of 1, the fact that the 95% credible interval does not contain 0 provides strong evidence that participants exhibited some discrimination between bands. The estimate for the interaction between slope and condition (\\(\\beta\\) = -0.14, 95% CrI [-0.26, -0.01], pd = 98.39%), suggests that the discrimination was somewhat modulated by training condition, with the varied participants showing less sensitivity between bands than the constant condition. This difference is depicted visually in Figure 15.\n\n\nCode\ntestE1 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 15: Empirical distribution of velocities producing in testing stage. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\npe1vce &lt;- e1_vxBMM |&gt; emmeans( ~condit + bandInt,re_formula=NA, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE1$vb), \n                     limits = c(0, 1400)) + \n  scale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e1_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e1_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction &lt;- fixef(e1_vxBMM)[,1][\"conditVaried:bandInt\"]\n\nre &lt;- data.frame(ranef(e1_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e1Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction*(condit==\"Varied\"),slope = Estimate + adjust )\n\n\npid_den1 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\")\n\npid_slopes1 &lt;- re |&gt;  mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n     theme(legend.title=element_blank(), \n           axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_wrap2(~condit,axes=\"all\",scales=\"free_y\")\n\n\np3 &lt;- (pe1vce + pid_den1 + pid_slopes1) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e1_test-vx.png\"), p3,width=9,height=11, bg=\"white\",dpi=600)\np3\n\n\n\n\nTable 7\n\n\n\n\n\n\nExperiment 1. Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#e1-summary",
    "href": "Sections/full.html#e1-summary",
    "title": "Full Dissertation",
    "section": "E1 Summary",
    "text": "E1 Summary\nIn Experiment 1, we investigated how variability in training influenced participants’ ability learn and extrapolate in a visuomotor task. Our findings that training with variable conditions rresulted in lower final training performance is consistent with much of the prior researchon the influence of training variability (Raviv et al., 2022; Soderstrom & Bjork, 2015), and is particularly unsurprising in the present work, given that the constant group received three times the amount of training on the velocity band common to the two conditions.\nMore importantly, the varied training group exhibited significantly larger deviations from the target velocity bands during the testing phase, particularly for the extrapolation bands that were not encountered by either condition during training.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#experiment-2-1",
    "href": "Sections/full.html#experiment-2-1",
    "title": "Full Dissertation",
    "section": "Experiment 2",
    "text": "Experiment 2\n\n\nCode\n# walk(c(\"brms\",\"dplyr\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\n# walk(c(\"Display_Functions\",\"org_functions\"), ~ source(here::here(paste0(\"Functions/\", .x, \".R\"))))\ne2 &lt;- readRDS(here(\"data/e2_08-04-23.rds\")) \ne2Sbjs &lt;- e2 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ntestE2 &lt;- e2 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE2 &lt;-  e2 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE2_max &lt;- trainE2 |&gt; filter(Trial_Bin == nbins, bandInt==600)\n\n# e2 |&gt; group_by(condit, bandOrder) |&gt; summarise(n_distinct(id))\n\n\n\nMethods & Procedure\nThe task and procedure of Experiment 2 was identical to Experiment 1, with the exception that the training and testing bands were reversed (see Figure 16). The Varied group trained on bands 100-300, 350-550, 600-800, and the constant group trained on band 600-800. Both groups were tested from all six bands. A total of 110 participants completed the experiment (Varied: 55, Constant: 55).\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n100-300\n350-550\n600-800\n\n\n\nTest1\n\nTest  \nNovel Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n600-800\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n100-300\n350-550\n600-800\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 16: Experiment 2 Design. Constant and Varied participants complete different training conditions. The training and testing bands are the reverse of Experiment 1.\n\n\n\n\n\n\n\nResults\n\n\nCode\np1 &lt;- trainE2 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    facet_wrap(~vb)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e2_train_deviation.png\"), p1, width = 8, height = 4,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 17: Experiment 2 Training Stage. Deviations from target band across training blocks. Lower values represent greater accuracy.\n\n\n\n\n\n\n\nCode\nbmm_e2_train &lt;- trainE2_max %&gt;% \n  brm(dist ~ condit, \n      file=here(\"data/model_cache/e2_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\nmtr2 &lt;- as.data.frame(describe_posterior(bmm_e2_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\ncolnames(mtr2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\ncdtr2 &lt;- get_coef_details(bmm_e2_train, \"conditVaried\")\n# mtr2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\n\n\n\n\nTable 8: Experiment 2 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n91.01\n80.67\n101.26\n1\n\n\nconditVaried\n36.15\n16.35\n55.67\n1\n\n\n\n\n\n\n\n\nTraining. Figure 17 presents the deviations across training blocks for both constant and varied training groups. We again compared training performance on the band common to both groups (600-800). The full model results are shown in Table 1. The varied group had a significantly greater deviation than the constant group in the final training block, ( \\(\\beta\\) = 36.15, 95% CrI [16.35, 55.67]; pd = 99.95%).\n\n\nCode\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e2_dist_Cond_Type_RF_2\")\nbmtd2 &lt;- brm(dist ~ condit * bandType + (1|bandInt) + (1|id), \n    data=testE2, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted2 &lt;- as.data.frame(describe_posterior(bmtd2, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\ncd2ted1 &lt;- get_coef_details(bmtd2, \"conditVaried\")\ncd2ted2 &lt;-get_coef_details(bmtd2, \"bandTypeExtrapolation\")\ncd2ted3 &lt;-get_coef_details(bmtd2, \"conditVaried:bandTypeExtrapolation\")\n\n\n\n\n\nTable 9: Experiment 2 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant & trained bands) - and a positive interaction coefficient indicates disproporionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n190.91\n125.03\n259.31\n1.00\n\n\nconditVaried\n-20.58\n-72.94\n33.08\n0.78\n\n\nbandTypeExtrapolation\n38.09\n-6.94\n83.63\n0.95\n\n\nconditVaried:bandTypeExtrapolation\n82.00\n41.89\n121.31\n1.00\n\n\n\n\n\n\n \n\nTesting Accuracy. The analysis of testing accuracy examined deviations from the target band as influenced by training condition (Varied vs. Constant) and band type (training vs. extrapolation bands). The results, summarized in Table 9, reveal no significant main effect of training condition (\\(\\beta\\) = -20.58, 95% CrI [-72.94, 33.08]; pd = 77.81%). However, the interaction between training condition and band type was significant (\\(\\beta\\) = 82, 95% CrI [41.89, 121.31]; pd = 100%), with the varied group showing disproportionately larger deviations compared to the constant group on the extrapolation bands (see Figure 18).\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\npe2td &lt;- testE2 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\n\npe2ce &lt;- bmtd2 |&gt; emmeans( ~condit + bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\")\n\np2 &lt;- (pe2td + pe2ce) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-dev.png\"), p2, width=8, height=4, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 18: A) Deviations from target band during testing without feedback stage. B) Estimated marginal means for the interaction between training condition and band type. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e2-bmm-vx\n##| tbl-cap: \"Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne2_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e2_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n#GetModelStats(e2_vxBMM ) |&gt; kable(escape=F,booktabs=T, caption=\"Fit to all 6 bands\")\n\ncd2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried\")\nsc2 &lt;- get_coef_details(e2_vxBMM, \"bandInt\")\nintCoef2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\n\nTable 10: Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n362.64\n274.85\n450.02\n1.00\n\n\nconditVaried\n-8.56\n-133.97\n113.98\n0.55\n\n\nBand\n0.71\n0.58\n0.84\n1.00\n\n\ncondit*Band\n-0.06\n-0.24\n0.13\n0.73\n\n\n\n\n\n\nTesting Discrimination. Finally, to assess the ability of both conditions to discriminate between velocity bands, we fit a model predicting velocity as a function of training condition and velocity band, with random intercepts and random slopes for each participant. The full model results are shown in Table 11. The overall slope on target velocity band predictor was significantly positive, (\\(\\beta\\) = 0.71, 95% CrI [0.58, 0.84]; pd= 100%), indicating that participants exhibited discrimination between bands. The interaction between slope and condition was not significant, (\\(\\beta\\) = -0.06, 95% CrI [-0.24, 0.13]; pd= 72.67%), suggesting that the two conditions did not differ in their ability to discriminate between bands (see Figure 19).\n\n\nCode\ntestE2 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 19: E2 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n}\n\npe2vce &lt;- e2_vxBMM |&gt; emmeans( ~condit + bandInt,re_formula=NA, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE2$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e2_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e2_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction &lt;- fixef(e2_vxBMM)[,1][\"conditVaried:bandInt\"]\n\nre &lt;- data.frame(ranef(e2_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e2Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction*(condit==\"Varied\"),slope = Estimate + adjust )\n\npid_den2 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\")\n\npid_slopes2 &lt;- re |&gt;  mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n      theme(legend.title=element_blank(), \n        axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_wrap2(~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe2vce + pid_den2 + pid_slopes2) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-vx.png\"), p3,width=9,height=11, bg=\"white\",dpi=600)\np3\n\n\n\n\nTable 11\n\n\n\n\n\n\nConditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\n\n\nExperiment 2 Summary\nExperiment 2 extended the findings of Experiment 1 by examining the effects of training variability on extrapolation performance in a visuomotor function learning task, but with reversed training and testing bands. Similar to Experiment 1, the Varied group exhibited poorer performance during training and testing. However unlike experiment 1, the Varied group did not show a significant difference in discrimination between bands.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#experiment-3",
    "href": "Sections/full.html#experiment-3",
    "title": "Full Dissertation",
    "section": "Experiment 3",
    "text": "Experiment 3\n\n\nCode\ne3 &lt;- readRDS(here(\"data/e3_08-04-23.rds\")) |&gt; \n    mutate(trainCon=case_when(\n    bandOrder==\"Original\" ~ \"800\",\n    bandOrder==\"Reverse\" ~ \"600\",\n    TRUE ~ NA_character_\n    ), trainCon=as.numeric(trainCon)) \ne3Sbjs &lt;- e3 |&gt; group_by(id,condit,bandOrder) |&gt; summarise(n=n())\ntestE3 &lt;- e3 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE3 &lt;-  e3 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit,bandOrder, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE3_max &lt;- trainE3 |&gt; filter(Trial_Bin == nbins, bandInt==trainCon)\n\n\n\nMethods & Procedure\nThe major adjustment of Experiment 3 is for participants to receive ordinal feedback during training, in contrast to the continuous feedback of the prior experiments. After each training throw, participants are informed whether a throw was too soft, too hard, or correct (i.e. within the target velocity range). All other aspects of the task and design are identical to Experiments 1 and 2. We utilized the order of training and testing bands from both of the prior experiments, thus assigning participants to both an order condition (Original or Reverse) and a training condition (Constant or Varied). Participants were once again recruited from the online Indiana University Introductory Psychology Course pool. Following exclusions, 195 participants were included in the final analysis, n=51 in the Constant-Original condition, n=59 in the Constant-Reverse condition, n=39 in the Varied-Original condition, and n=46 in the Varied-Reverse condition.\n\n\nResults\n\n\nCode\nbmm_e3_train &lt;- trainE3_max %&gt;% \n  brm(dist ~ condit*bandOrder, \n      file=here(\"data/model_cache/e3_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\n# mtr3 &lt;- as.data.frame(describe_posterior(bmm_e3_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mtr3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mtr3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\ncd3tr1 &lt;- get_coef_details(bmm_e3_train, \"conditVaried\")\ncd3tr2 &lt;-get_coef_details(bmm_e3_train, \"bandOrderReverse\")\ncd3tr3 &lt;-get_coef_details(bmm_e3_train, \"conditVaried:bandOrderReverse\")\n\n\n\n\n\nTable 12: Experiment 3 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n121.86\n109.24\n134.60\n1.00\n\n\nconditVaried\n64.93\n36.99\n90.80\n1.00\n\n\nbandOrderReverse\n1.11\n-16.02\n18.16\n0.55\n\n\nconditVaried:bandOrderReverse\n-77.02\n-114.16\n-39.61\n1.00\n\n\n\n\n\n\nTraining. Figure 20 displays the average deviations from the target band across training blocks, and Table 12 shows the results of the Bayesian regression model predicting the deviation from the common band at the end of training (600-800 for reversed order, and 800-1000 for original order conditions). The main effect of training condition is significant, with the varied condition showing larger deviations ( \\(\\beta\\) = 64.93, 95% CrI [36.99, 90.8]; pd = 100%). The main effect of band order is not significant \\(\\beta\\) = 1.11, 95% CrI [-16.02, 18.16]; pd = 55.4%, however the interaction between training condition and band order is significant, with the varied condition showing greater accuracy in the reverse order condition ( \\(\\beta\\) = -77.02, 95% CrI [-114.16, -39.61]; pd = 100%).\n\n\nCode\np1 &lt;- trainE3 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    ggh4x::facet_nested_wrap(~bandOrder*vb,ncol=3)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e3_train_deviation.png\"), p1, width = 9, height = 8,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 20: E3. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e3_dist_Cond_Type_RF_2\")\nbmtd3 &lt;- brm(dist ~ condit * bandType*bandOrder + (1|bandInt) + (1|id), \n    data=testE3, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted3 &lt;- as.data.frame(describe_posterior(bmtd3, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\n#ce_bmtd3 &lt;- plot(conditional_effects(bmtd3),points=FALSE,plot=FALSE)\n#wrap_plots(ce_bmtd3)\n\n#ggsave(here::here(\"Assets/figs\", \"e3_cond_effects_dist.png\"), wrap_plots(ce_bmtd3), width=11, height=11, bg=\"white\")\n\ncd3ted1 &lt;- get_coef_details(bmtd3, \"conditVaried\")\ncd3ted2 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation\")\ncd3ted3 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation\")\ncd3ted4 &lt;-get_coef_details(bmtd3, \"bandOrderReverse\")\ncd3ted5 &lt;-get_coef_details(bmtd3, \"conditVaried:bandOrderReverse\")\ncd3ted6 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation:bandOrderReverse\")\ncd3ted7 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation:bandOrderReverse\")\n\n\n\n\n\nTable 13: Experiment 3 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant training; trained bands & original order) - and a positive interaction coefficient indicates disproportionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n288.65\n199.45\n374.07\n1.00\n\n\nconditVaried\n-40.19\n-104.68\n23.13\n0.89\n\n\nbandTypeExtrapolation\n-23.35\n-57.28\n10.35\n0.92\n\n\nbandOrderReverse\n-73.72\n-136.69\n-11.07\n0.99\n\n\nconditVaried:bandTypeExtrapolation\n52.66\n14.16\n90.23\n1.00\n\n\nconditVaried:bandOrderReverse\n-37.48\n-123.28\n49.37\n0.80\n\n\nbandTypeExtrapolation:bandOrderReverse\n80.69\n30.01\n130.93\n1.00\n\n\nconditVaried:bandTypeExtrapolation:bandOrderReverse\n30.42\n-21.00\n81.65\n0.87\n\n\n\n\n\n\nTesting Accuracy. Table 13 presents the results of the Bayesian mixed efects model predicting absolute deviation from the target band during the testing stage. There was no significant main effect of training condition,\\(\\beta\\) = -40.19, 95% CrI [-104.68, 23.13]; pd = 89.31%, or band type,\\(\\beta\\) = -23.35, 95% CrI [-57.28, 10.35]; pd = 91.52%. However the effect of band order was significant, with the reverse order condition showing lower deviations, \\(\\beta\\) = -73.72, 95% CrI [-136.69, -11.07]; pd = 98.89%. The interaction between training condition and band type was also significant \\(\\beta\\) = 52.66, 95% CrI [14.16, 90.23]; pd = 99.59%, with the varied condition showing disproprionately large deviations on the extrapolation bands compared to the constant group. There was also a significant interaction between band type and band order, \\(\\beta\\) = 80.69, 95% CrI [30.01, 130.93]; pd = 99.89%, such that the reverse order condition showed larger deviations on the extrapolation bands. No other interactions were significant.\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3td &lt;- testE3 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n    facet_wrap(~bandOrder,ncol=1) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\npe3ce &lt;- bmtd3 |&gt; emmeans( ~condit *bandOrder*bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\") + \n facet_wrap(~bandOrder,ncol=1)\n\np2 &lt;- pe3td + pe3ce + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e3_test-dev.png\"), p2, width=9, height=8, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 21: Experiment 3 Testing Accuracy. A) Deviations from target band during testing without feedback stage. B) Conditional effect of condition (Constant vs. Varied) and testing band type (training vs. extrapolation) on testing accuracy. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e3-bmm-vx\n##| tbl-cap: \"Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne3_vxBMM &lt;- brm(vx ~ condit * bandOrder * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e3_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n# m1 &lt;- as.data.frame(describe_posterior(e3_vxBMM, centrality = \"Mean\"))\n# m2 &lt;- fixef(e3_vxBMM)\n# mp3 &lt;- m1[, c(1,2,4,5,6)]\n# colnames(mp3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")                       \n# mp3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_replace_all(Term, \"b_bandInt\", \"Band\")) |&gt;\n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T)\n\n#wrap_plots(plot(conditional_effects(e3_vxBMM),points=FALSE,plot=FALSE))\n\ncd1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e3_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried:bandInt\")\nintCoef2 &lt;- get_coef_details(e3_vxBMM, \"bandOrderReverse:bandInt\")\ncoef3 &lt;- get_coef_details(e3_vxBMM,\"conditVaried:bandOrderReverse:bandInt\")\n\n\n\n\n\nTable 14: Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n601.83\n504.75\n699.42\n1.00\n\n\nconditVaried\n12.18\n-134.94\n162.78\n0.56\n\n\nbandOrderReverse\n13.03\n-123.89\n144.67\n0.58\n\n\nBand\n0.49\n0.36\n0.62\n1.00\n\n\nconditVaried:bandOrderReverse\n-338.15\n-541.44\n-132.58\n1.00\n\n\nconditVaried:Band\n-0.04\n-0.23\n0.15\n0.67\n\n\nbandOrderReverse:bandInt\n-0.10\n-0.27\n0.08\n0.86\n\n\nconditVaried:bandOrderReverse:bandInt\n0.42\n0.17\n0.70\n1.00\n\n\n\n\n\n\nTesting Discrimination. The full results of the discrimination model are presented in Table 13. For the purposes of assessing group differences in discrimination, only the coefficients including the band variable are of interest. The baseline effect of band represents the slope cofficient for the constant training - original order condition, this effect was significant \\(\\beta\\) = 0.49, 95% CrI [0.36, 0.62]; pd = 100%. Neither of the two way interactions reached significance, \\(\\beta\\) = -0.04, 95% CrI [-0.23, 0.15]; pd = 66.63%, \\(\\beta\\) = -0.1, 95% CrI [-0.27, 0.08]; pd = 86.35%. However, the three way interaction between training condition, band order, and target band was significant, \\(\\beta\\) = 0.42, 95% CrI [0.17, 0.7]; pd = 99.96% - indicating that the varied condition showed a greater slope coefficient on the reverse order bands, compared to the constant condition - this is clearly shown in Figure 22, where the steepness of the best fitting line for the varied-reversed condition is noticably steeper than the other conditions.\n\n\nCode\n##| column: screen-inset-right\n# testE3 |&gt; filter(bandOrder==\"Original\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit()\n# testE3 |&gt; filter(bandOrder==\"Reverse\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit() +ggtitle(\"test\")\n\ntestE3 |&gt; group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + \n   ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\n\n\n\n\n\n\nFigure 22: e3 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\n##| eval: FALSE\n# pe3tv &lt;- testE3 %&gt;% group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3vce &lt;- e3_vxBMM |&gt; emmeans( ~condit* bandOrder* bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  facet_wrap(~bandOrder,ncol=1) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE3$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e3_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e3_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction1 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandInt\"]\nfixed_effect_interaction2 &lt;- fixef(e3_vxBMM)[,1][\"bandOrderReverse:bandInt\"]\nfixed_effect_interaction3 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandOrderReverse:bandInt\"]\n\nre &lt;- data.frame(ranef(e3_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e3Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction1*(condit==\"Varied\") + \n           fixed_effect_interaction2*(bandOrder==\"Reverse\") + \n           fixed_effect_interaction3*(condit==\"Varied\" & bandOrder==\"Reverse\"),\n  slope = Estimate + adjust )\n\npid_den3 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\") +\n  facet_wrap(~bandOrder,ncol=1)\n\npid_slopes3 &lt;- re |&gt;  \n    mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n    geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n    theme(legend.title=element_blank(), \n      axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_nested_wrap(bandOrder~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe3vce + pid_den3 + pid_slopes3) + plot_annotation(tag_levels= 'A')\n\n#ggsave(here::here(\"Assets/figs\", \"e3_test-vx.png\"), p3,width=11,height=13, bg=\"white\",dpi=800)\np3\n\n\n\n\n\n\n\n\nFigure 23: Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\nExperiment 3 Summary",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#computational-model-1",
    "href": "Sections/full.html#computational-model-1",
    "title": "Full Dissertation",
    "section": "Computational Model",
    "text": "Computational Model\n\n\nCode\n####| cache: false\n# pacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, \n#                stringr,future,furrr, knitr, reactable,ggstance, htmltools,\n#                ggdist,ggh4x,brms,tidybayes,emmeans,bayestestR, gt)\n# #walk(c(\"dplyr\"), conflict_prefer_all, quiet = TRUE)\n# #options(brms.backend=\"cmdstanr\",mc.cores=4)\n# options(digits=3, scipen=999, dplyr.summarise.inform=FALSE)\n# walk(c(\"Display_Functions\",\"fun_alm\",\"fun_indv_fit\",\"fun_model\", \"prep_model_data\",\"org_functions\"), ~source(here::here(paste0(\"Functions/\", .x, \".R\"))))\n\n\n\n\nCode\n###| cache: true\ninvisible(list2env(load_sbj_data(), envir = .GlobalEnv))\ninvisible(list2env(load_e1(), envir = .GlobalEnv))\ne1Sbjs &lt;- e1 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ne2_model &lt;- load_e2()\ne3_model &lt;- load_e3()\noptions(contrasts = initial_contrasts)\n\n\n\n\nCode\nalm_plot()\n\n\n\n\n\n\n\n\nFigure 24: The Associative Learning Model (ALM). The diagram illustrates the basic structure of the ALM model as used in the present work. Input nodes are activated as a function of their similarity to the lower-boundary of the target band. The generalization parameter, \\(c\\), determines the degree to which nearby input nodes are activated. The output nodes are activated as a function of the weighted sum of the input nodes - weights are updated via the delta rule.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#alm-exam-description",
    "href": "Sections/full.html#alm-exam-description",
    "title": "Full Dissertation",
    "section": "ALM & Exam Description",
    "text": "ALM & Exam Description\nALM is a localist neural network model (Page, 2000), with each input node corresponding to a particular stimulus, and each output node corresponding to a particular response value. The units in the input layer activate as a function of their Gaussian similarity to the input stimulus. So, for example, an input stimulus of value 55 would induce maximal activation of the input unit tuned to 55. Depending on the value of the generalization parameter, the nearby units (e.g. 54 and 56; 53 and 57) may also activate to some degree. ALM is structured with input and output nodes that correspond to regions of the stimulus space, and response space, respectively. The units in the input layer activate as a function of their similarity to a presented stimulus. As was the case with the exemplar-based models, similarity in ALM is exponentially decaying function of distance. The input layer is fully connected to the output layer, and the activation for any particular output node is simply the weighted sum of the connection weights between that node and the input activations. The network then produces a response by taking the weighted average of the output units (recall that each output unit has a value corresponding to a particular response). During training, the network receives feedback which activates each output unit as a function of its distance from the ideal level of activation necessary to produce the correct response. The connection weights between input and output units are then updated via the standard delta learning rule, where the magnitude of weight changes are controlled by a learning rate parameter. The EXAM model is an extension of ALM, with the same learning rule and representational scheme for input and output units. EXAM differs from ALM only in its response rule, as it includes a linear extrapolation mechanism for generating novel responses. Although this extrapolation rule departs from a strictly similarity-based generalization mechanism, EXAM is distinct from pure rule-based models in that it remains constrained by the weights learned during training. EXAM retrieves the two nearest training inputs, and the ALM responses associated with those inputs, and computes the slope between these two points. The slope is then used to extrapolate the response to the novel test stimulus. Because EXAM requires at least two input-output pairs to generate a response, additional assumptions were required in order for it to generate resposnes for the constant group. We assumed that participants come to the task with prior knowledge of the origin point (0,0), which can serve as a reference point necessary for the model to generate responses for the constant group. This assumption is motivated by previous function learning research (Brown & Lacroix (2017)), which through a series of manipulations of the y intercept of the underlying function, found that participants consistently demonstrated knowledge of, or a bias towards, the origin point (see Kwantes & Neal (2006) for additional evidence of such a bias in function learning tasks).\nSee Table 15 for a full specification of the equations that define ALM and EXAM, and Figure 24 for a visual representation of the ALM model.\n\n\n\n\nTable 15: ALM & EXAM Equations\n\n\n\n\n\n\n\n\n\n\n\nALM Response Generation\n\n\n\n\n\nInput Activation\n\\(a_i(X) = \\frac{e^{-c(X-X_i)^2}}{\\sum_{k=1}^M e^{-c(X-X_k)^2}}\\)\nInput nodes activate as a function of Gaussian similarity to stimulus\n\n\nOutput Activation\n\\(O_j(X) = \\sum_{k=1}^M w_{ji} \\cdot a_i(X)\\)\nOutput unit \\(O_j\\) activation is the weighted sum of input activations and association weights\n\n\nOutput Probability\n\\(P[Y_j|X] = \\frac{O_j(X)}{\\sum_{k=1}^M O_k(X)}\\)\nThe response, \\(Y_j\\) probabilites computed via Luce’s choice rule\n\n\nMean Output\n\\(m(X) = \\sum_{j=1}^L Y_j \\cdot \\frac{O_j(x)}{\\sum_{k=1}^M O_k(X)}\\)\nWeighted average of probabilities determines response to X\n\n\n\nALM Learning\n\n\n\nFeedback\n\\(f_j(Z) = e^{-c(Z-Y_j)^2}\\)\nfeedback signal Z computed as similarity between ideal response and observed response\n\n\nmagnitude of error\n\\(\\Delta_{ji}=(f_{j}(Z)-o_{j}(X))a_{i}(X)\\)\nDelta rule to update weights.\n\n\nUpdate Weights\n\\(w_{ji}^{new}=w_{ji}+\\eta\\Delta_{ji}\\)\nUpdates scaled by learning rate parameter \\(\\eta\\).\n\n\n\nEXAM Extrapolation\n\n\n\nInstance Retrieval\n\\(P[X_i|X] = \\frac{a_i(X)}{\\sum_{k=1}^M a_k(X)}\\)\nNovel test stimulus \\(X\\) activates input nodes \\(X_i\\)\n\n\nSlope Computation\n\\(S =\\) \\(\\frac{m(X_{1})-m(X_{2})}{X_{1}-X_{2}}\\)\nSlope value, \\(S\\) computed from nearest training instances\n\n\nResponse\n\\(E[Y|X_i] = m(X_i) + S \\cdot [X - X_i]\\)\nALM response \\(m(X_i)\\) adjusted by slope.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#model-fitting",
    "href": "Sections/full.html#model-fitting",
    "title": "Full Dissertation",
    "section": "Model Fitting",
    "text": "Model Fitting\nTo fit ALM and EXAM to our participant data, we employ a similar method to Mcdaniel et al. (2009), wherein we examine the performance of each model after being fit to various subsets of the data. Each model was fit to the data in with separate procedures: 1) fit to maximize predictions of the testing data, 2) fit to maximize predictions of both the training and testing data, 3) fit to maximize predictions of the just the training data. We refer to this fitting manipulations as “Fit Method” in the tables and figures below. It should be emphasized that for all three fit methods, the ALM and EXAM models behave identically - with weights updating only during the training phase.Models to were fit separately to the data of each individual participant. The free parameters for both models are the generalization (\\(c\\)) and learning rate (\\(lr\\)) parameters. Parameter estimation was performed using approximate bayesian computation (ABC), which we describe in detail below.\n\n\n\n\n\n\n Approximate Bayesian Computation\nTo estimate the parameters of ALM and EXAM, we used approximate bayesian computation (ABC), enabling us to obtain an estimate of the posterior distribution of the generalization and learning rate parameters for each individual. ABC belongs to the class of simulation-based inference methods (Cranmer et al., 2020), which have begun being used for parameter estimation in cognitive modeling relatively recently (Kangasrääsiö et al., 2019; Turner et al., 2016; Turner & Van Zandt, 2012). Although they can be applied to any model from which data can be simulated, ABC methods are most useful for complex models that lack an explicit likelihood function (e.g. many neural network models).\nThe general ABC procedure is to 1) define a prior distribution over model parameters. 2) sample candidate parameter values, \\(\\theta^*\\), from the prior. 3) Use \\(\\theta^*\\) to generate a simulated dataset, \\(Data_{sim}\\). 4) Compute a measure of discrepancy between the simulated and observed datasets, \\(discrep\\)(\\(Data_{sim}\\), \\(Data_{obs}\\)). 5) Accept \\(\\theta^*\\) if the discrepancy is less than the tolerance threshold, \\(\\epsilon\\), otherwise reject \\(\\theta^*\\). 6) Repeat until desired number of posterior samples are obtained.\nAlthough simple in the abstract, implementations of ABC require researchers to make a number of non-trivial decisions as to i) the discrepancy function between observed and simulated data, ii) whether to compute the discrepancy between trial level data, or a summary statistic of the datasets, iii) the value of the minimum tolerance \\(\\epsilon\\) between simulated and observed data. For the present work, we follow the guidelines from previously published ABC tutorials (Farrell & Lewandowsky, 2018; Turner & Van Zandt, 2012). For the test stage, we summarized datasets with mean velocity of each band in the observed dataset as \\(V_{obs}^{(k)}\\) and in the simulated dataset as \\(V_{sim}^{(k)}\\), where \\(k\\) represents each of the six velocity bands. For computing the discrepancy between datasets in the training stage, we aggregated training trials into three equally sized blocks (separately for each velocity band in the case of the varied group). After obtaining the summary statistics of the simulated and observed datasets, the discrepancy was computed as the mean of the absolute difference between simulated and observed datasets (Equation 1 and Equation 2). For the models fit to both training and testing data, discrepancies were computed for both stages, and then averaged together.\n\n\\[\ndiscrep_{Test}(Data_{sim}, Data_{obs}) = \\frac{1}{6} \\sum_{k=1}^{6} |V_{obs}^{(k)} - V_{sim}^{(k)}|\n\\tag{1}\\]\n\\[\n\\begin{aligned} \\\\\ndiscrep_{Train,constant}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks}} \\sum_{j=1}^{N_{blocks}} |V_{obs,constant}^{(j)} - V_{sim,constant}^{(j)}| \\\\ \\\\\ndiscrep_{Train,varied}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks} \\times 3} \\sum_{j=1}^{N_{blocks}} \\sum_{k=1}^{3} |V_{obs,varied}^{(j,k)} - V_{sim,varied}^{(j,k)}|\n\\end{aligned}\n\\tag{2}\\]\n\nThe final component of our ABC implementation is the determination of an appropriate value of \\(\\epsilon\\). The setting of \\(\\epsilon\\) exerts strong influence on the approximated posterior distribution. Smaller values of \\(\\epsilon\\) increase the rejection rate, and improve the fidelity of the approximated posterior, while larger values result in an ABC sampler that simply reproduces the prior distribution. Because the individual participants in our dataset differed substantially in terms of the noisiness of their data, we employed an adaptive tolerance setting strategy to tailor \\(\\epsilon\\) to each individual. The initial value of \\(\\epsilon\\) was set to the overall standard deviation of each individuals velocity values. Thus, sampled parameter values that generated simulated data within a standard deviation of the observed data were accepted, while worse performing parameters were rejected. After every 300 samples the tolerance was allowed to increase only if the current acceptance rate of the algorithm was less than 1%. In such cases, the tolerance was shifted towards the average discrepancy of the 5 best samples obtained thus far. To ensure the acceptance rate did not become overly permissive, \\(\\epsilon\\) was also allowed to decrease every time a sample was accepted into the posterior.\n\n\n\nFor each of the 156 participants from Experiment 1, the ABC algorithm was run until 200 samples of parameters were accepted into the posterior distribution. Obtaining this number of posterior samples required an average of 205,000 simulation runs per participant. Fitting each combination of participant, Model (EXAM & ALM), and fitting method (Test only, Train only, Test & Train) required a total of 192 million simulation runs. To facilitate these intensive computational demands, we used the Future Package in R (Bengtsson, 2021), allowing us to parallelize computations across a cluster of ten M1 iMacs, each with 8 cores.\n\nModelling Results\n\nGroup level Patterns\n\n\nCode\npost_tabs &lt;- abc_tables(post_dat,post_dat_l)\ntrain_tab &lt;- abc_train_tables(pd_train,pd_train_l)\n\ne1_tab &lt;- rbind(post_tabs$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Test\"), train_tab$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne1_tab %&gt;%\n  group_by(`Task Stage`, Fit_Method, Model, condit) %&gt;%\n  summarize(ME = mean(mean_error), .groups = \"drop\") %&gt;%\n  pivot_wider(\n    names_from = c(Model, condit),\n    values_from = ME,\n    names_sep = \"_\"  # Add this line to specify the separator for column names\n  ) %&gt;%\n  rename(\"Fit Method\" = Fit_Method) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = c(`Task Stage`)) %&gt;%\n  cols_label(\n    `Task Stage` = \"Task Stage\"\n  ) %&gt;%\n  fmt_number(\n    columns = starts_with(\"ALM\") | starts_with(\"EXAM\"),\n    decimals = 2\n  ) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = cell_fill(color = \"white\"),\n     locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_style(\n    style = cell_borders(sides = \"top\", color = \"black\", weight = px(1)),\n    locations = cells_column_labels()\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10, \n    quarto.disable_processing = TRUE\n  ) \n\n\n\n\nTable 16: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      Task Stage\n      Fit Method\n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    Test\nFit to Test Data\n199.93\n103.36\n104.01\n85.68\n    Test\nFit to Test & Training Data\n216.97\n170.28\n127.94\n144.86\n    Test\nFit to Training Data\n467.73\n291.38\n273.30\n297.91\n    Train\nFit to Test Data\n297.82\n2,016.01\n53.90\n184.00\n    Train\nFit to Test & Training Data\n57.40\n132.32\n42.92\n127.90\n    Train\nFit to Training Data\n51.77\n103.48\n51.43\n107.03\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nc_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=log(c), x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.2)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"c parameter\") +\n  theme(legend.title = element_blank(), legend.position=\"right\",plot.title=element_text(hjust=.4))\n\nlr_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=lr, x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.4)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"learning rate parameter\") +\n  theme(legend.title = element_blank(), legend.position = \"none\",plot.title=element_text(hjust=.5))\nc_post + lr_post\n\n\n\n\n\n\n\n\nFigure 25: Posterior Distributions of \\(c\\) and \\(lr\\) parameters. Points represent median values, thicker intervals represent 66% credible intervals and thin intervals represent 95% credible intervals around the median. Note that the y axes of the plots for the c parameter are scaled logarithmically.\n\n\n\n\n\n\n\nCode\ntrain_resid &lt;- pd_train |&gt; group_by(id,condit,Model,Fit_Method, Block,x) |&gt; \n  summarise(y=mean(y), pred=mean(pred), mean_error=abs(y-pred)) |&gt;\n  group_by(id,condit,Model,Fit_Method,Block) |&gt;\n  summarise(mean_error=mean(mean_error)) |&gt;\n  ggplot(aes(x=interaction(Block,Model), y = mean_error, fill=factor(Block))) + \n  stat_bar + \n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, scales=\"free\",ncol=2) +\n   scale_x_discrete(guide = \"axis_nested\") +\n  scale_fill_manual(values=c(\"gray10\",\"gray50\",\"gray92\"))+\n  labs(title=\"Model Residual Errors - Training Stage\", y=\"RMSE\", x= \"Model\",fill=\"Training Block\") +\n  theme(legend.position=\"top\")\n\ntest_resid &lt;-  post_dat |&gt; \n   group_by(id,condit,x,Model,Fit_Method,bandType) |&gt;\n    summarise(y=mean(y), pred=mean(pred), error=abs(y-pred)) |&gt; \n  mutate(vbLab = factor(paste0(x,\"-\",x+200))) |&gt;\n  ggplot(aes(x = Model, y = abs(error), fill=vbLab,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n  #scale_fill_manual(values=wes_palette(\"AsteroidCity2\"))+\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, axes = \"all\",ncol=2,scale=\"free\") +\n  labs(title=\"Model Residual Errors - Testing Stage\",y=\"RMSE\", x=\"Velocity Band\") \n\n(train_resid / test_resid) +\n  #plot_layout(heights=c(1,1.5)) & \n  plot_annotation(tag_levels = list(c('A','B')),tag_suffix = ') ') \n\n\n\n\n\n\n\n\nFigure 26: Model residuals for each combination of training condition, fit method, and model. Residuals reflect the difference between observed and predicted values. Lower values indicate better model fit. Note that y axes are scaled differently between facets. A) Residuals predicting each block of the training data. B) Residuals predicting each band during the testing stage. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\nThe posterior distributions of the \\(c\\) and \\(lr\\) parameters are shown Figure 25, and model predictions are shown alongside the empirical data in Figure 27. There were substantial individual differences in the posteriors of both parameters, with the within-group individual differences generally swamped any between-group or between-model differences. The magnitude of these individual differences remains even if we consider only the single best parameter set for each subject.\nWe used the posterior distribution of \\(c\\) and \\(lr\\) parameters to generate a posterior predictive distribution of the observed data for each participant, which then allows us to compare the empirical data to the full range of predictions from each model. Aggregated residuals are displayed in Figure 26. The pattern of training stage residual errors are unsurprising across the combinations of models and fitting method . Differences in training performance between ALM and EXAM are generally minor (the two models have identical learning mechanisms). The differences in the magnitude of residuals across the three fitting methods are also straightforward, with massive errors for the ‘fit to Test Only’ model, and the smallest errors for the ‘fit to train only’ models. It is also noteworthy that the residual errors are generally larger for the first block of training, which is likely due to the initial values of the ALM weights being unconstrained by whatever initial biases participants tend to bring to the task. Future work may explore the ability of the models to capture more fine grained aspects of the learning trajectories. However for the present purposes, our primary interest is in the ability of ALM and EXAM to account for the testing patterns while being constrained, or not constrained, by the training data. All subsequent analyses and discussion will thus focus on the testing stage.\nThe residuals of the model predictions for the testing stage (Figure 26) also show an unsurprising pattern across fitting methods - with models fit only to the test data showing the best performance, followed by models fit to both training and test data, and with models fit only to the training data showing the worst performance (note that y axes are scaled different between plots). Although EXAM tends to perform better for both Constant and Varied participants (see also Figure 28), the relative advantage of EXAM is generally larger for the Constant group - a pattern consistent across all three fitting methods. The primary predictive difference between ALM and EXAM is made clear in Figure 27, which directly compares the observed data against the posterior predictive distributions for both models. Regardless of how the models are fit, only EXAM can capture the pattern where participants are able to discriminate all 6 target bands.\n\n\nCode\npost_dat_l |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; \n #left_join(testAvgE1, by=join_by(id,condit,x==bandInt)) |&gt;\n ggplot(aes(x=Resp,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n    facet_wrap(~rename_fm(Fit_Method)+condit, ncol=2,strip.position = \"top\", scales = \"free_x\") +\n        scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n         strip.background = element_blank(),\n         strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(10,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions - Experiment 1 Data\", y=\"Vx\")\n\n\n\n\n\n\n\n\nFigure 27: Empirical data and Model predictions for mean velocity across target bands. Fitting methods (Test Only, Test & Train, Train Only) - are separated across rows, and Training Condition (Constant vs. Varied) are separated by columns. Each facet contains the predictions of ALM and EXAM, alongside the observed data.\n\n\n\n\n\n\n\nCode\n###| eval: false\n\npacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, \n               stringr,future,furrr, knitr, reactable,ggstance, htmltools,\n               ggdist,ggh4x,brms,tidybayes,emmeans,bayestestR, gt)\n\npdl &lt;- post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; left_join(testAvgE1,by=c(\"id\",\"condit\",\"bandInt\")) |&gt; \n  filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\n# aerror is model error, which is predicted by Model(ALM vs. EXAM) & condit (Constant vs. Varied)\ne1_ee_brm_ae &lt;- brm(data=pdl,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e1_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbct_e1 &lt;- as.data.frame(bayestestR::describe_posterior(e1_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n\np1 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\np2 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \np_ce_1 &lt;- (p1 + p2+ p3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\n# plot_custom_effects &lt;- function(model) {\n#   # Extract posterior samples for fixed effects\n#   post_samples &lt;- posterior_samples(model, pars = c(\"b_Intercept\", \"b_ModelEXAM\", \"b_conditVaried\", \"b_ModelEXAM:conditVaried\"))\n  \n#   # Calculate conditional effects\n#   post_samples &lt;- post_samples %&gt;%\n#     mutate(\n#       ALM_Constant = b_Intercept,\n#       EXAM_Constant = b_Intercept + b_ModelEXAM,\n#       ALM_Varied = b_Intercept + b_conditVaried,\n#       EXAM_Varied = b_Intercept + b_ModelEXAM + b_conditVaried + `b_ModelEXAM:conditVaried`\n#     )\n  \n#   # Reshape data for plotting\n#   plot_data &lt;- post_samples %&gt;%\n#     select(ALM_Constant, EXAM_Constant, ALM_Varied, EXAM_Varied) %&gt;%\n#     pivot_longer(everything(), names_to = \"Condition\", values_to = \"Estimate\") %&gt;%\n#     separate(Condition, into = c(\"Model\", \"Condit\"), sep = \"_\")\n  \n#   # Plot conditional effects\n#   ggplot(plot_data, aes(x = Model, y = Estimate, color = Condit)) +\n#     geom_boxplot() +\n#     theme_minimal() +\n#     labs(x = \"Model\", y = \"Estimate\", color = \"Condition\")\n# }\n# p_ce_1 &lt;- plot_custom_effects(e1_ee_brm_ae)\n\n\n\n\nbm1 &lt;- get_coef_details(e1_ee_brm_ae, \"conditVaried\")\nbm2 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM\")\nbm3 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nposterior_estimates &lt;- as.data.frame(e1_ee_brm_ae) %&gt;%\n  select(starts_with(\"b_\")) %&gt;%\n  setNames(c(\"Intercept\", \"ModelEXAM\", \"conditVaried\", \"ModelEXAM_conditVaried\"))\n\nconstant_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM\nvaried_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM + posterior_estimates$conditVaried + posterior_estimates$ModelEXAM_conditVaried\ncomparison_EXAM &lt;- constant_EXAM - varied_EXAM\nsummary_EXAM &lt;- bayestestR::describe_posterior(comparison_EXAM, centrality = \"Mean\")\n\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NULL)\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NA)\n\n# full set of Model x condit contrasts\n# ALM - EXAM\n# btw_model &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model | condit, re_formula=NULL)  |&gt; \n#   pluck(\"contrasts\") |&gt; \n#   gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw,condit) |&gt; summarise(value=mean(.value), n=n()) \n\n# btw_model |&gt; ggplot(aes(x=value,y=contrast,fill=condit)) +stat_halfeye()\n\n# Constant - Varied\n# emm_condit &lt;- e1_ee_brm_ae |&gt; emmeans(~ condit | Model, re_formula = NULL)\n# btw_con &lt;- emm_condit |&gt;  pairs() |&gt; gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw, Model) |&gt; summarise(value=mean(.value), n=n()) \n# # btw_con |&gt; ggplot(aes(x=value,y=Model,fill=Model)) +stat_halfeye()                              \n\np_em_1 &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model*condit, re_formula=NA)  |&gt; \n  pluck(\"contrasts\") |&gt;\n  gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw) |&gt; summarise(value=mean(.value), n=n()) |&gt; \n  filter(!(contrast %in% c(\"ALM Constant - EXAM Constant\",\"ALM Constant - EXAM Varied\",\"ALM Varied - EXAM Varied \", \"EXAM Constant - ALM Varied\" ))) |&gt; \n  ggplot(aes(x=value,y=contrast,fill=contrast)) +stat_halfeye() + labs(x=\"Model Error Difference\",y=\"Contrast\") + theme(legend.position=\"none\") \n\np_ce_1 / p_em_1\n\n\n\n\n\n\n\n\nFigure 28\n\n\n\n\n\nTo quantitatively assess whether the differences in performance between models, we fit a bayesian regressions predicting the errors of the posterior predictions of each models as a function of the Model (ALM vs. EXAM) and training condition (Constant vs. Varied).\nModel errors were significantly lower for EXAM (\\(\\beta\\) = -37.54, 95% CrI [-60.4, -14.17], pd = 99.85%) than ALM. There was also a significant interaction between Model and Condition (\\(\\beta\\) = 60.42, 95% CrI [36.17, 83.85], pd = 100%), indicating that the advantage of EXAM over ALM was significantly greater for the constant group. To assess whether EXAM predicts constant performance significantly better for Constant than for Varied subjects, we calculated the difference in model error between the Constant and Varied conditions specifically for EXAM. The results indicated that the model error for EXAM was significantly lower in the Constant condition compared to the Varied condition, with a mean difference of -22.88 (95% CrI [-46.02, -0.97], pd = 0.98).\n\n\nCode\npost_tabs2 &lt;- abc_tables(e2_model$post_dat,e2_model$post_dat_l)\ntrain_tab2 &lt;- abc_train_tables(e2_model$pd_train,e2_model$pd_train_l)\n\npdl2 &lt;- e2_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne2_tab &lt;- rbind(post_tabs2$agg_pred_full |&gt;\n mutate(\"Task Stage\"=\"Test\"), train_tab2$agg_pred_full |&gt; \n mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\npost_tabs3 &lt;- abc_tables(e3_model$post_dat,e3_model$post_dat_l)\ntrain_tab3 &lt;- abc_train_tables(e3_model$pd_train,e3_model$pd_train_l)\n\npdl3 &lt;- e3_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne3_tab &lt;- rbind(post_tabs3$agg_pred_full |&gt; \n  mutate(\"Task Stage\"=\"Test\"), train_tab3$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne23_tab &lt;- rbind(e2_tab |&gt; mutate(Exp=\"E2\"), e3_tab |&gt; mutate(Exp=\"E3\")) \ngt_table &lt;- e23_tab %&gt;%\n  pivot_wider(\n    names_from = c(Exp, Model, condit),\n    values_from = mean_error,\n    names_glue = \"{Exp}_{Model}_{condit}\"\n  ) %&gt;%\n  arrange(Fit_Method, `Task Stage`) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = `Task Stage`) %&gt;%\n  cols_label(`Task Stage` = \"Task Stage\") %&gt;%\n  fmt_number(columns = matches(\"E2|E3\"), decimals = 1) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = list(\n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10,\n    quarto.disable_processing = TRUE\n  ) \ngt_table\n\n\n\n\nTable 17: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      \n      \n        E2\n      \n      \n        E3\n      \n    \n    \n      Task Stage\n      \n        ALM\n      \n      \n        EXAM\n      \n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    \n      Fit to Test Data\n    \n    Test\n239.7\n129.8\n99.7\n88.2\n170.1\n106.1\n92.3\n72.8\n    Train\n53.1\n527.1\n108.1\n169.3\n70.9\n543.5\n157.8\n212.7\n    \n      Fit to Test & Training Data\n    \n    Test\n266.0\n208.2\n125.1\n126.4\n197.7\n189.5\n130.0\n128.5\n    Train\n40.0\n35.4\n30.4\n23.6\n49.1\n85.6\n49.2\n78.4\n    \n      Fit to Training Data\n    \n    Test\n357.4\n295.9\n305.1\n234.5\n415.0\n298.8\n295.5\n243.7\n    Train\n42.5\n23.0\n43.2\n22.6\n51.4\n63.8\n51.8\n65.3\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nrbind(e2_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\"), \n e3_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb,bandOrder) |&gt;\n  summarize(vx=median(val)) |&gt; mutate(Exp=\"E3\")) |&gt;\n  ggplot( aes(x=condit,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) +\n  stat_bar + \n    facet_nested_wrap(~Exp+bandOrder+Resp, strip.position = \"top\", scales = \"free_x\") +\n    scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .7), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n        #  strip.background = element_blank(),\n        #  strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(20,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions Experiment 2 & 3\", y=\"vx\")\n\n\n\n\n\n\n\n\nFigure 29: Empirical data and Model predictions from Experiment 2 and 3 for the testing stage. Observed data is shown on the right. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\n\n\nCode\ne2_ee_brm_ae &lt;- brm(data=pdl2,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e2_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"conditVaried\")\nbm2_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM\")\nbm3_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nbct_e2 &lt;- as.data.frame(bayestestR::describe_posterior(e2_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) # %&gt;% kable(booktabs = TRUE)\n\ne3_ee_brm_ae &lt;- brm(data=pdl3,\n  aerror ~  Model * condit*bandOrder + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e3_ae_modelCondBo_RFint2.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e3 &lt;- get_coef_details(e3_ee_brm_ae, \"conditVaried\")\nbm2_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM\")\nbm3_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried\")\nbm4_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried:bandOrderReverse\")\n\n\nbct_e3  &lt;- as.data.frame(bayestestR::describe_posterior(e3_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\nbct &lt;- rbind(bct_e1 |&gt; mutate(exp=\"Exp 1\"),bct_e2 |&gt; \n               mutate(exp= \"Exp 2\"),bct_e3 |&gt; mutate(exp=\"Exp 3\")) |&gt; \n  relocate(exp, .before=Term)\n\nbct_table &lt;- bct %&gt;%\n  mutate(\n    across(c(Estimate, `95% CrI Lower`, `95% CrI Upper`), ~ round(., 2)),\n    pd = round(pd, 2)\n  ) %&gt;%\n  gt() %&gt;%\n  # tab_header(\n  #   title = \"Bayesian Model Results\",\n  #   subtitle = \"Estimates and Credible Intervals for Each Term Across Experiments\"\n  # ) %&gt;%\n  cols_label(\n    exp = \"Experiment\",\n    Term = \"Term\",\n    Estimate = \"Estimate\",\n    `95% CrI Lower` = \"95% CrI Lower\",\n    `95% CrI Upper` = \"95% CrI Upper\",\n    pd = \"pd\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(Estimate, `95% CrI Lower`, `95% CrI Upper`),\n    decimals = 2\n  ) %&gt;%\n  fmt_number(\n    columns = pd,\n    decimals = 2\n  ) %&gt;%\n  tab_spanner(\n    label = \"Credible Interval\",\n    columns = c(`95% CrI Lower`, `95% CrI Upper`)\n  ) %&gt;%\n  tab_style(\n    style = list(\n      #cell_fill(color = \"lightgray\"),\n      cell_text(weight = \"bold\"), \n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(\n      columns = c(Estimate, pd),\n      rows = Term==\"ModelEXAM:conditVaried\"\n    )\n  ) %&gt;%\n   tab_row_group(\n    label = \"Experiment 3\",\n    rows = exp == \"Exp 3\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 2\",\n    rows = exp == \"Exp 2\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 1\",\n    rows = exp == \"Exp 1\"\n  ) %&gt;%\n  tab_options(\n    table.font.size = 10,\n    heading.title.font.size = 16,\n    heading.subtitle.font.size = 14,\n    quarto.disable_processing = TRUE\n    #row_group.background.color = \"gray95\"\n  )\nbct_table\n\n\n\n\nTable 18: Results of Bayesian Regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and the interaction between Model and Condition. The values represent the estimate coefficient for each term, with 95% credible intervals in brackets. The intercept reflects the baseline of ALM and Constant. The other estimates indicate deviations from the baseline for the EXAM mode and varied condition. Lower values indicate better model fit.\n\n\n\n\n\n\n  \n    \n      Experiment\n      Term\n      Estimate\n      \n        Credible Interval\n      \n      pd\n    \n    \n      95% CrI Lower\n      95% CrI Upper\n    \n  \n  \n    \n      Experiment 1\n    \n    Exp 1\nIntercept\n176.30\n156.86\n194.59\n1.00\n    Exp 1\nModelEXAM\n−88.44\n−104.51\n−71.81\n1.00\n    Exp 1\nconditVaried\n−37.54\n−60.40\n−14.17\n1.00\n    Exp 1\nModelEXAM:conditVaried\n60.42\n36.17\n83.85\n1.00\n    \n      Experiment 2\n    \n    Exp 2\nIntercept\n245.87\n226.18\n264.52\n1.00\n    Exp 2\nModelEXAM\n−137.73\n−160.20\n−115.48\n1.00\n    Exp 2\nconditVaried\n−86.39\n−113.52\n−59.31\n1.00\n    Exp 2\nModelEXAM:conditVaried\n56.87\n25.26\n88.04\n1.00\n    \n      Experiment 3\n    \n    Exp 3\nIntercept\n164.83\n140.05\n189.44\n1.00\n    Exp 3\nModelEXAM\n−65.66\n−85.97\n−46.02\n1.00\n    Exp 3\nconditVaried\n−40.61\n−75.90\n−3.02\n0.98\n    Exp 3\nbandOrderReverse\n25.47\n−9.34\n58.68\n0.93\n    Exp 3\nModelEXAM:conditVaried\n41.90\n11.20\n72.54\n0.99\n    Exp 3\nModelEXAM:bandOrderReverse\n−7.32\n−34.53\n21.05\n0.70\n    Exp 3\nconditVaried:bandOrderReverse\n30.82\n−19.57\n83.56\n0.88\n    Exp 3\nModelEXAM:conditVaried:bandOrderReverse\n−60.60\n−101.80\n−18.66\n1.00\n  \n  \n  \n\n\n\n\n\n\n\nModel Fits to Experiment 2 and 3. Data from Experiments 2 and 3 were fit to ALM and EXAM in the same manner as Experiment1 . For brevity, we only plot and discuss the results of the “fit to training and testing data” models - results from the other fitting methods can be found in the appendix. The model fitting results for Experiments 2 and 3 closely mirrored those observed in Experiment 1. The Bayesian regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and their interaction (see Table 18) revealed a consistent main effect of Model across all three experiments. The negative coefficients for the ModelEXAM term (Exp 2: \\(\\beta\\) = -86.39, 95% CrI -113.52, -59.31, pd = 100%; Exp 3: \\(\\beta\\) = -40.61, 95% CrI -75.9, -3.02, pd = 98.17%) indicate that EXAM outperformed ALM in both experiments. Furthermore, the interaction between Model and Condition was significant in both Experiment 2 (\\(\\beta\\) = 56.87, 95% CrI 25.26, 88.04, pd = 99.98%) and Experiment 3 (\\(\\beta\\) = 41.9, 95% CrI 11.2, 72.54, pd = 99.35%), suggesting that the superiority of EXAM over ALM was more pronounced for the Constant group compared to the Varied group, as was the case in Experiment 1. Recall that Experiment 3 included participants in both the original and reverse order conditions - and that this manipulation interacted with the effect of training condition. We thus also controleld for band order in our Bayesian Regression assessing the relative performance of EXAM and ALM in Experiment 3. There was a significant three way interaction between Model, Training Condition, and Band Order (\\(\\beta\\) = -60.6, 95% CrI -101.8, -18.66, pd = 99.83%), indicating that the relative advantage of EXAM over ALM was only more pronounced in the original order condition, and not the reverse order condition (see Figure 30).\n\n\nCode\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\np1 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\") + labs(title=\"E2. Model Error\")\np2 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n  p_e2 &lt;- (p1 + p2+ p3) \n# #wrap_plots(plot(conditional_effects(e3_ee_brm_ae),points=FALSE,plot=FALSE))\n\np_e3 &lt;- plot(conditional_effects(e3_ee_brm_ae, \n                         effects = \"Model:condit\", \n                         conditions=make_conditions(e3_ee_brm_ae,vars=c(\"bandOrder\"))),\n     points=FALSE,plot=FALSE)$`Model:condit` + \n     labs(x=\"Model\",y=\"Model Error\", title=\"E3. Model Error\", fill=NULL, col=NULL) + \n     theme(legend.position=\"right\") + \n     scale_color_manual(values=wes_palette(\"Darjeeling1\")) \n\np1 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\np2 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n p2 &lt;- (p1 + p2+ p3)\n (p_e2 / p_e3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\n\n\n\n\n\n\nFigure 30: Conditional effects of Model (ALM vs EXAM) and Condition (Constant vs. Varied) on Model Error for Experiment 2 and 3 data. Experiment 3 also includes a control for the order of training vs. testing bands (original order vs. reverse order).\n\n\n\n\n\nComputational Model Summary. Across the model fits to all three experiments, we found greater support for EXAM over ALM (negative coefficients on the ModelEXAM term in Table 18), and moreover that the constant participants were disproportionately well described by EXAM in comparison to ALM (positive coefficients on ModelEXAM:conditVaried terms in Table 18). This pattern is also clearly depicted in Figure 31, which plots the difference in model errors between ALM and EXAM for each individual participant. Both varied and constant conditions have a greater proportion of subjects better fit by EXAM (positive error differences), with the magnitude of EXAM’s advantage visibly greater for the constant group. It also bears mention that numerous participants were better fit by ALM, or did not show a clear preference for either model. A subset of these participants are shown in Figure 32.\n\n\nCode\ntid1 &lt;- post_dat  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-pred_dist, -dist) |&gt;\n  rbind(e2_model$post_dat |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat |&gt; mutate(Exp=\"E3\")) |&gt;\n  filter(Fit_Method==\"Test_Train\") |&gt;\n  group_by(id,condit,Model,Fit_Method,x, Exp) |&gt; \n    mutate(e2=abs(y-pred)) |&gt; \n    summarise(y1=median(y), pred1=median(pred),mean_error=abs(y1-pred1)) |&gt;\n    group_by(id,condit,Model,Fit_Method,Exp) |&gt; \n    summarise(mean_error=mean(mean_error)) |&gt; \n    arrange(id,condit,Fit_Method) |&gt;\n    round_tibble(1) \n\nbest_id &lt;- tid1 |&gt; \n  group_by(id,condit,Fit_Method) |&gt; \n  mutate(best=ifelse(mean_error==min(mean_error),1,0)) \n\nlowest_error_model &lt;- best_id %&gt;%\n  group_by(id, condit,Fit_Method, Exp) %&gt;%\n  summarise(Best_Model = Model[which.min(mean_error)],\n            Lowest_error = min(mean_error),\n            differential = min(mean_error) - max(mean_error)) %&gt;%\n  ungroup()\n\nerror_difference&lt;- best_id %&gt;%\n  select(id, condit, Model,Fit_Method, mean_error) %&gt;%\n  pivot_wider(names_from = Model, values_from = c(mean_error)) %&gt;%\n  mutate(Error_difference = (ALM - EXAM))\n\nfull_comparison &lt;- lowest_error_model |&gt; \n  left_join(error_difference, by=c(\"id\",\"condit\",\"Fit_Method\"))  |&gt; \n  group_by(condit,Fit_Method,Best_Model) |&gt; \n  mutate(nGrp=n(), model_rank = nGrp - rank(Error_difference) ) |&gt; \n  arrange(Fit_Method,-Error_difference)\n\nfull_comparison |&gt; \n  filter(Fit_Method==\"Test_Train\") |&gt; \n  ungroup() |&gt;\n  mutate(id = reorder(id, Error_difference)) %&gt;%\n  ggplot(aes(y=id,x=Error_difference,fill=Best_Model))+\n  geom_col() +\n  #ggh4x::facet_grid2(~condit,axes=\"all\",scales=\"free_y\", independent = \"y\")+\n  ggh4x::facet_nested_wrap(~condit+Exp,scales=\"free\") + \n  theme(axis.text.y = element_text(size=8)) +\n  labs(fill=\"Best Model\",\n  x=\"Mean Model Error Difference (ALM - EXAM)\",\n  y=\"Participant\")\n\n\n\n\n\n\n\n\nFigure 31: Difference in model errors for each participant, with models fit to both train and test data. Positive values favor EXAM, while negative values favor ALM.\n\n\n\n\n\n\n\nCode\ncId_tr &lt;- c(137, 181, 11)\nvId_tr &lt;- c(14, 193, 47)\ncId_tt &lt;- c(11, 93, 35)\nvId_tt &lt;- c(1,14,74)\ncId_new &lt;- c(175, 68, 93, 74)\n# filter(id %in% (filter(bestTestEXAM,group_rank&lt;=9, Fit_Method==\"Test\")\n\ne1_sbjs &lt;- c(49,68,155, 175,74)\ne3_sbjs &lt;-  c(245, 280, 249)\ne2_sbjs &lt;- c(197, 157, 312, 334)\ncFinal &lt;- c(49, 128,202 )\nvFinal &lt;- c(68,70,245)\n\n\nindv_post_l &lt;- post_dat_l  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-signed_dist) |&gt;\n  rbind(e2_model$post_dat_l |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat_l |&gt; mutate(Exp=\"E3\") |&gt; select(-fb)) |&gt;\n  filter(Fit_Method==\"Test_Train\", id %in% c(cFinal,vFinal))\n\ntestIndv &lt;- indv_post_l |&gt; \n#filter(id %in% c(cId_tt,vId_tt,cId_new), Fit_Method==\"Test_Train\") |&gt; \n   mutate(x=as.factor(x), Resp=as.factor(Resp)) |&gt;\n  group_by(id,condit,Fit_Method,Model,Resp) |&gt;\n   mutate(flab=paste0(\"Subject: \",id)) |&gt;\n  ggplot(aes(x = Resp, y = val, fill=vb, col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar_sd + \n  ggh4x::facet_nested_wrap(condit~flab, axes = \"all\",ncol=3) +\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = FALSE) +\n  scale_size_manual(values = c(\"black\" = .5), guide = FALSE) + \n  labs(title=\"Individual Participant fits from Test & Train Fitting Method\",\n       y=\"X Velocity\",fill=\"Target Velocity\") +\n   guides(fill = guide_legend(nrow = 1)) + \n  theme(legend.position = \"bottom\",axis.title.x = element_blank())\n\ntestIndv \n\n\n\n\n\n\n\n\nFigure 32: Model predictions alongside observed data for a subset of individual participants. A) 3 constant and 3 varied participants fit to both the test and training data. B) 3 constant and 3 varied subjects fit to only the trainign data. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full.html#comparison-to-project-1",
    "href": "Sections/full.html#comparison-to-project-1",
    "title": "Full Dissertation",
    "section": "Comparison to Project 1",
    "text": "Comparison to Project 1\n\nDifferences between the tasks\nThere are a number of differences between Project 1’s Hit The Target (HTT), and Project 2’s Hit The Wall (HTW) tasks.\n\nTask Space Complexity: In HTW, the task space is also almost perfectly smooth, at least for the continuous feedback subjects, if they throw 100 units too hard, they’ll be told that they were 100 units too hard. Whereas in HTT,  it was possible to produce xy velocity combinations that were technically closer to the empirical solution space than other throws, but which resulted in worse feedback due to striking the barrier.\nPerceptual Distinctiveness: HTT offers perceptually distinct varied conditions that directly relate to the task’s demands, which may increase the sallience between training positions encounted by the varied group. In contrast, HTW’s varied conditions differ only in the numerical values displayed, lacking the same level of perceptual differentiation. Conversely in HTW, the only difference between conditions for the varied group are the numbers displayed at the top of the screen which indicate the current target band(e.g. 800-1000, or 1000-1200)\nIn HTW, our primary testing stage of interest has no feedback, whereas in HTT testing always included feedback (the intermittent testing in HTT expt 1 being the only exception). Of course, we do collect testing with feedback data at the end of HTW, but we haven’t focused on that data at all in our modelling work thus far. It’s also interesting to recall that the gap between varied and constant in HTW does seem to close substantially in the testing-with-feedback stage. The difference between no-feedback and feedback testing might be relevant if the benefits of variation have anything to do with improving subsequent learning (as opposed to subsequent immediate performance), OR if the benefits of constant training rely on having the most useful anchor, having the most useful anchor might be a lot less helpful if you’re getting feedback from novel positions and can thus immediately begin to form position-specific anchors for the novelties, rather than relying on a training anchor. \nHTW and HTT both have a similar amount of training trials (~200), and thus the constant groups acquire a similar amount of experience with their single position/velocity in both experiments. However, the varied conditions in both HTT experiments train on 2 positions, whereas the varied group in HTW trains on 3 velocity bands. This means that in HTT the varied group gets half as much experience on any one position as the constant group, and in HTW they only get 1/3 as much experience in any one position. There are likely myriad ways in which this might impact the success of the varied group regardless of how you think the benefits of variation might be occurring, e.g. maybe they also need to develop a coherent anchor, maybe they need more experience in order to extract a function, or more experience in order to properly learn to tune their c parameter.",
    "crumbs": [
      "Full Dissertation"
    ]
  },
  {
    "objectID": "Sections/full2.html",
    "href": "Sections/full2.html",
    "title": "Full Dissertation",
    "section": "",
    "text": "Code\npacman::p_load(dplyr,purrr,tidyr,tibble,ggplot2,\n  brms,rstanarm,emmeans,broom,bayestestR,\n  stringr, here,conflicted, patchwork, knitr, cowplot, RColorBrewer,data.table,\n  gt,ggh4x,ggdist,htmltools,future,furrr)\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\n#options(digits=2, scipen=999, dplyr.summarise.inform=FALSE, kableExtra.auto_format=FALSE)\n#walk(c(\"brms\",\"dplyr\",\"bayestestR\",\"here\"), conflict_prefer_all, quiet = TRUE)\nconflicts_prefer(tidybayes::rstudent_t)\nwalk(c(\"dplyr\",\"here\",\"brms\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\n\n\nwalk(c(\"Display_Functions\",\"fun_alm\",\"fun_indv_fit\",\"fun_model\", \"prep_model_data\",\"org_functions\"), ~source(here::here(paste0(\"Functions/\", .x, \".R\"))))\n\n\n# pacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, \n#                stringr,future,furrr, knitr, reactable,ggstance, htmltools,\n#                ggdist,ggh4x,brms,tidybayes,emmeans,bayestestR, gt)\n\n\n#pacman::p_load(papaja, tinytex, RColorBrewer, kableExtra, cowplot)\n#source(here::here('Functions/IGAS_ProcessFunctions.R'))\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\ninitial_contrasts &lt;- options(\"contrasts\")$contrasts\noptions(digits=2, scipen=999, dplyr.summarise.inform=FALSE, contrasts = c(\"contr.sum\", \"contr.poly\"))\ndefaultContrasts = options()$contrasts\n\ntheme_set(theme_classic())\n\nlibrary(tidybayes)\n\n\n# load the processed data from experiment 1 and 2\ne1 &lt;- readRDS(here::here(\"data/igas_e1_cleanedData-final.rds\")) %&gt;% mutate(initialVelocityX=X_Velocity,initialVelocityY=Y_Velocity,stageInt=as.numeric(as.character(experimentStage)))\ne2&lt;- readRDS(here::here('data/igas_e2_cleanedData-final.rds')) %&gt;% mutate(initialVelocityX=X_Velocity,initialVelocityY=Y_Velocity)\n# load subject similarity data - computed with the IGAS model in 'IGAS-SimModel.R'\ne2_sim &lt;- readRDS(here::here('data/IGAS_Similarity-Performance.rds'))\n\n# options(contrasts = c(\"contr.sum\", \"contr.poly\"), kableExtra.auto_format=FALSE)\n# defaultContrasts = options()$contrasts\n# theme_set(theme_classic())\n\ndodge &lt;- position_dodge(width = 0.9)\ne2GrpPos &lt;- c(\"400\",\"500\",\"625\",\"675\",\"800\",\"900\")\ne2Grp &lt;- paste(\"Constant\",\"Constant\", \"Constant\",\"Constant\",\"Constant\",\"Constant\", \"Varied\")\ne2Labels &lt;- paste(c(\"400\\n Constant\",\"500\\n Constant\",\"625\\n Constant\",\"675\\n Constant\",\n                   \"800\\n Constant\",\"900\\n Constant\",\"500-800\\n Varied\"),sep=\"\")\n\ne1Pos &lt;- c(\"610\",\"760\",\"835\",\"910\")\ne1Var &lt;- paste(\"Varied Train Position\",\"Constant Train Position\", \"Novel Position\", \"Varied Training Position\")\ne1Labels&lt;- paste(c(\"610\\n Varied Trained\",\"760\\n Constant Trained\",\"835\\n Novel Location\",\"910\\n Varied Trained\"),sep=\"\")"
  },
  {
    "objectID": "Sections/full2.html#experiment-2",
    "href": "Sections/full2.html#experiment-2",
    "title": "Full Dissertation",
    "section": "Experiment 2",
    "text": "Experiment 2\n\n\nCode\n# walk(c(\"brms\",\"dplyr\",\"bayestestR\"), conflict_prefer_all, quiet = TRUE)\n# walk(c(\"Display_Functions\",\"org_functions\"), ~ source(here::here(paste0(\"Functions/\", .x, \".R\"))))\ne2 &lt;- readRDS(here(\"data/e2_08-04-23.rds\")) \ne2Sbjs &lt;- e2 |&gt; group_by(id,condit) |&gt; summarise(n=n())\ntestE2 &lt;- e2 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE2 &lt;-  e2 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE2_max &lt;- trainE2 |&gt; filter(Trial_Bin == nbins, bandInt==600)\n\n# e2 |&gt; group_by(condit, bandOrder) |&gt; summarise(n_distinct(id))\n\n\n\nMethods & Procedure\nThe task and procedure of Experiment 2 was identical to Experiment 1, with the exception that the training and testing bands were reversed (see Figure 2). The Varied group trained on bands 100-300, 350-550, 600-800, and the constant group trained on band 600-800. Both groups were tested from all six bands. A total of 110 participants completed the experiment (Varied: 55, Constant: 55).\n\n\n\n\n\n\n\n\n\n\ncluster\n\nTest Phase \n(Counterbalanced Order)\n\n\n\ndata1\n\n Varied Training \n100-300\n350-550\n600-800\n\n\n\nTest1\n\nTest  \nNovel Bands  \n800-1000\n1000-1200\n1200-1400\n\n\n\ndata1-&gt;Test1\n\n\n\n\n\ndata2\n\n Constant Training \n600-800\n\n\n\ndata2-&gt;Test1\n\n\n\n\n\nTest3\n\n    Final Test \n  Novel With Feedback  \n800-1000\n1000-1200\n1200-1400\n\n\n\nTest2\n\n  Test \n  Varied Training Bands  \n100-300\n350-550\n600-800\n\n\n\nTest1-&gt;Test2\n\n\n\n\n\nTest2-&gt;Test3\n\n\n\n\n\n\n\n\nFigure 2: Experiment 2 Design. Constant and Varied participants complete different training conditions. The training and testing bands are the reverse of Experiment 1.\n\n\n\n\n\n\n\nResults\n\n\nCode\np1 &lt;- trainE2 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    facet_wrap(~vb)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e2_train_deviation.png\"), p1, width = 8, height = 4,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 3: Experiment 2 Training Stage. Deviations from target band across training blocks. Lower values represent greater accuracy.\n\n\n\n\n\n\n\nCode\nbmm_e2_train &lt;- trainE2_max %&gt;% \n  brm(dist ~ condit, \n      file=here(\"data/model_cache/e2_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\nmtr2 &lt;- as.data.frame(describe_posterior(bmm_e2_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\ncolnames(mtr2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n\ncdtr2 &lt;- get_coef_details(bmm_e2_train, \"conditVaried\")\n# mtr2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\n\n\n\n\nTable 1: Experiment 2 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n91.01\n80.67\n101.26\n1\n\n\nconditVaried\n36.15\n16.35\n55.67\n1\n\n\n\n\n\n\n\n\nTraining. Figure 3 presents the deviations across training blocks for both constant and varied training groups. We again compared training performance on the band common to both groups (600-800). The full model results are shown in Table 1. The varied group had a significantly greater deviation than the constant group in the final training block, ( \\(\\beta\\) = 36.15, 95% CrI [16.35, 55.67]; pd = 99.95%).\n\n\nCode\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e2_dist_Cond_Type_RF_2\")\nbmtd2 &lt;- brm(dist ~ condit * bandType + (1|bandInt) + (1|id), \n    data=testE2, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted2 &lt;- as.data.frame(describe_posterior(bmtd2, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted2) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted2 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\ncd2ted1 &lt;- get_coef_details(bmtd2, \"conditVaried\")\ncd2ted2 &lt;-get_coef_details(bmtd2, \"bandTypeExtrapolation\")\ncd2ted3 &lt;-get_coef_details(bmtd2, \"conditVaried:bandTypeExtrapolation\")\n\n\n\n\n\nTable 2: Experiment 2 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant & trained bands) - and a positive interaction coefficient indicates disproporionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n190.91\n125.03\n259.31\n1.00\n\n\nconditVaried\n-20.58\n-72.94\n33.08\n0.78\n\n\nbandTypeExtrapolation\n38.09\n-6.94\n83.63\n0.95\n\n\nconditVaried:bandTypeExtrapolation\n82.00\n41.89\n121.31\n1.00\n\n\n\n\n\n\n \n\nTesting Accuracy. The analysis of testing accuracy examined deviations from the target band as influenced by training condition (Varied vs. Constant) and band type (training vs. extrapolation bands). The results, summarized in Table 2, reveal no significant main effect of training condition (\\(\\beta\\) = -20.58, 95% CrI [-72.94, 33.08]; pd = 77.81%). However, the interaction between training condition and band type was significant (\\(\\beta\\) = 82, 95% CrI [41.89, 121.31]; pd = 100%), with the varied group showing disproportionately larger deviations compared to the constant group on the extrapolation bands (see Figure 4).\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\npe2td &lt;- testE2 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\n\npe2ce &lt;- bmtd2 |&gt; emmeans( ~condit + bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\")\n\np2 &lt;- (pe2td + pe2ce) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-dev.png\"), p2, width=8, height=4, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 4: A) Deviations from target band during testing without feedback stage. B) Estimated marginal means for the interaction between training condition and band type. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e2-bmm-vx\n##| tbl-cap: \"Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne2_vxBMM &lt;- brm(vx ~ condit * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e2_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n#GetModelStats(e2_vxBMM ) |&gt; kable(escape=F,booktabs=T, caption=\"Fit to all 6 bands\")\n\ncd2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried\")\nsc2 &lt;- get_coef_details(e2_vxBMM, \"bandInt\")\nintCoef2 &lt;- get_coef_details(e2_vxBMM, \"conditVaried:bandInt\")\n\n\n\n\n\nTable 3: Experiment 2. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n362.64\n274.85\n450.02\n1.00\n\n\nconditVaried\n-8.56\n-133.97\n113.98\n0.55\n\n\nBand\n0.71\n0.58\n0.84\n1.00\n\n\ncondit*Band\n-0.06\n-0.24\n0.13\n0.73\n\n\n\n\n\n\nTesting Discrimination. Finally, to assess the ability of both conditions to discriminate between velocity bands, we fit a model predicting velocity as a function of training condition and velocity band, with random intercepts and random slopes for each participant. The full model results are shown in Table 4. The overall slope on target velocity band predictor was significantly positive, (\\(\\beta\\) = 0.71, 95% CrI [0.58, 0.84]; pd= 100%), indicating that participants exhibited discrimination between bands. The interaction between slope and condition was not significant, (\\(\\beta\\) = -0.06, 95% CrI [-0.24, 0.13]; pd= 72.67%), suggesting that the two conditions did not differ in their ability to discriminate between bands (see Figure 5).\n\n\nCode\ntestE2 %&gt;% group_by(id,vb,condit) |&gt; plot_distByCondit()\n\n\n\n\n\n\n\n\nFigure 5: E2 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n}\n\npe2vce &lt;- e2_vxBMM |&gt; emmeans( ~condit + bandInt,re_formula=NA, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE2$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e2_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e2_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction &lt;- fixef(e2_vxBMM)[,1][\"conditVaried:bandInt\"]\n\nre &lt;- data.frame(ranef(e2_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e2Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction*(condit==\"Varied\"),slope = Estimate + adjust )\n\npid_den2 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\")\n\npid_slopes2 &lt;- re |&gt;  mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n      theme(legend.title=element_blank(), \n        axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_wrap2(~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe2vce + pid_den2 + pid_slopes2) + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e2_test-vx.png\"), p3,width=9,height=11, bg=\"white\",dpi=600)\np3\n\n\n\n\nTable 4\n\n\n\n\n\n\nConditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\n\n\nExperiment 2 Summary\nExperiment 2 extended the findings of Experiment 1 by examining the effects of training variability on extrapolation performance in a visuomotor function learning task, but with reversed training and testing bands. Similar to Experiment 1, the Varied group exhibited poorer performance during training and testing. However unlike experiment 1, the Varied group did not show a significant difference in discrimination between bands."
  },
  {
    "objectID": "Sections/full2.html#experiment-3",
    "href": "Sections/full2.html#experiment-3",
    "title": "Full Dissertation",
    "section": "Experiment 3",
    "text": "Experiment 3\n\n\nCode\ne3 &lt;- readRDS(here(\"data/e3_08-04-23.rds\")) |&gt; \n    mutate(trainCon=case_when(\n    bandOrder==\"Original\" ~ \"800\",\n    bandOrder==\"Reverse\" ~ \"600\",\n    TRUE ~ NA_character_\n    ), trainCon=as.numeric(trainCon)) \ne3Sbjs &lt;- e3 |&gt; group_by(id,condit,bandOrder) |&gt; summarise(n=n())\ntestE3 &lt;- e3 |&gt; filter(expMode2 == \"Test\")\nnbins=5\ntrainE3 &lt;-  e3 |&gt; filter(expMode2==\"Train\") |&gt; group_by(id,condit,bandOrder, vb) |&gt; \n    mutate(Trial_Bin = cut( gt.train, breaks = seq(1, max(gt.train),length.out=nbins+1),include.lowest = TRUE, labels=FALSE)) \ntrainE3_max &lt;- trainE3 |&gt; filter(Trial_Bin == nbins, bandInt==trainCon)\n\n\n\nMethods & Procedure\nThe major adjustment of Experiment 3 is for participants to receive ordinal feedback during training, in contrast to the continuous feedback of the prior experiments. After each training throw, participants are informed whether a throw was too soft, too hard, or correct (i.e. within the target velocity range). All other aspects of the task and design are identical to Experiments 1 and 2. We utilized the order of training and testing bands from both of the prior experiments, thus assigning participants to both an order condition (Original or Reverse) and a training condition (Constant or Varied). Participants were once again recruited from the online Indiana University Introductory Psychology Course pool. Following exclusions, 195 participants were included in the final analysis, n=51 in the Constant-Original condition, n=59 in the Constant-Reverse condition, n=39 in the Varied-Original condition, and n=46 in the Varied-Reverse condition.\n\n\nResults\n\n\nCode\nbmm_e3_train &lt;- trainE3_max %&gt;% \n  brm(dist ~ condit*bandOrder, \n      file=here(\"data/model_cache/e3_train_deviation\"),\n      data = .,\n      iter = 2000,\n      chains = 4,\n      control = list(adapt_delta = .94, max_treedepth = 13))\n\n# mtr3 &lt;- as.data.frame(describe_posterior(bmm_e3_train, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mtr3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mtr3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T) \n\ncd3tr1 &lt;- get_coef_details(bmm_e3_train, \"conditVaried\")\ncd3tr2 &lt;-get_coef_details(bmm_e3_train, \"bandOrderReverse\")\ncd3tr3 &lt;-get_coef_details(bmm_e3_train, \"conditVaried:bandOrderReverse\")\n\n\n\n\n\nTable 5: Experiment 3 - End of training performance. The Intercept represents the average of the baseline (constant condition), and the conditVaried coefficient reflects the difference between the constant and varied groups. A larger positive coefficient indicates a greater deviation (lower accuracy) for the varied group.\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n121.86\n109.24\n134.60\n1.00\n\n\nconditVaried\n64.93\n36.99\n90.80\n1.00\n\n\nbandOrderReverse\n1.11\n-16.02\n18.16\n0.55\n\n\nconditVaried:bandOrderReverse\n-77.02\n-114.16\n-39.61\n1.00\n\n\n\n\n\n\nTraining. Figure 6 displays the average deviations from the target band across training blocks, and Table 5 shows the results of the Bayesian regression model predicting the deviation from the common band at the end of training (600-800 for reversed order, and 800-1000 for original order conditions). The main effect of training condition is significant, with the varied condition showing larger deviations ( \\(\\beta\\) = 64.93, 95% CrI [36.99, 90.8]; pd = 100%). The main effect of band order is not significant \\(\\beta\\) = 1.11, 95% CrI [-16.02, 18.16]; pd = 55.4%, however the interaction between training condition and band order is significant, with the varied condition showing greater accuracy in the reverse order condition ( \\(\\beta\\) = -77.02, 95% CrI [-114.16, -39.61]; pd = 100%).\n\n\nCode\np1 &lt;- trainE3 |&gt; ggplot(aes(x = Trial_Bin, y = dist, color = condit)) +\n    stat_summary(geom = \"line\", fun = mean) +\n    stat_summary(geom = \"errorbar\", fun.data = mean_se, width = .4, alpha = .7) +\n    ggh4x::facet_nested_wrap(~bandOrder*vb,ncol=3)+\n    scale_x_continuous(breaks = seq(1, nbins + 1)) +\n    theme(legend.title=element_blank()) + \n    labs(y = \"Deviation\", x=\"Training Block\") \n#ggsave(here(\"Assets/figs/e3_train_deviation.png\"), p1, width = 9, height = 8,bg=\"white\")\np1\n\n\n\n\n\n\n\n\nFigure 6: E3. Deviations from target band during testing without feedback stage.\n\n\n\n\n\n\n\nCode\n#options(brms.backend=\"cmdstanr\",mc.cores=4)\nmodelFile &lt;- paste0(here::here(\"data/model_cache/\"), \"e3_dist_Cond_Type_RF_2\")\nbmtd3 &lt;- brm(dist ~ condit * bandType*bandOrder + (1|bandInt) + (1|id), \n    data=testE3, file=modelFile,\n    iter=5000,chains=4, control = list(adapt_delta = .94, max_treedepth = 13))\n                        \n# mted3 &lt;- as.data.frame(describe_posterior(bmtd3, centrality = \"Mean\"))[, c(1,2,4,5,6)]\n# colnames(mted3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")\n# mted3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(booktabs=TRUE) \n\n#ce_bmtd3 &lt;- plot(conditional_effects(bmtd3),points=FALSE,plot=FALSE)\n#wrap_plots(ce_bmtd3)\n\n#ggsave(here::here(\"Assets/figs\", \"e3_cond_effects_dist.png\"), wrap_plots(ce_bmtd3), width=11, height=11, bg=\"white\")\n\ncd3ted1 &lt;- get_coef_details(bmtd3, \"conditVaried\")\ncd3ted2 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation\")\ncd3ted3 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation\")\ncd3ted4 &lt;-get_coef_details(bmtd3, \"bandOrderReverse\")\ncd3ted5 &lt;-get_coef_details(bmtd3, \"conditVaried:bandOrderReverse\")\ncd3ted6 &lt;-get_coef_details(bmtd3, \"bandTypeExtrapolation:bandOrderReverse\")\ncd3ted7 &lt;-get_coef_details(bmtd3, \"conditVaried:bandTypeExtrapolation:bandOrderReverse\")\n\n\n\n\n\nTable 6: Experiment 3 testing accuracy. Main effects of condition and band type (training vs. extrapolation), and the interaction between the two factors. Larger coefficient estimates indicate larger deviations from the baselines (constant training; trained bands & original order) - and a positive interaction coefficient indicates disproportionate deviation for the varied condition on the extrapolation bands\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n288.65\n199.45\n374.07\n1.00\n\n\nconditVaried\n-40.19\n-104.68\n23.13\n0.89\n\n\nbandTypeExtrapolation\n-23.35\n-57.28\n10.35\n0.92\n\n\nbandOrderReverse\n-73.72\n-136.69\n-11.07\n0.99\n\n\nconditVaried:bandTypeExtrapolation\n52.66\n14.16\n90.23\n1.00\n\n\nconditVaried:bandOrderReverse\n-37.48\n-123.28\n49.37\n0.80\n\n\nbandTypeExtrapolation:bandOrderReverse\n80.69\n30.01\n130.93\n1.00\n\n\nconditVaried:bandTypeExtrapolation:bandOrderReverse\n30.42\n-21.00\n81.65\n0.87\n\n\n\n\n\n\nTesting Accuracy. Table 6 presents the results of the Bayesian mixed efects model predicting absolute deviation from the target band during the testing stage. There was no significant main effect of training condition,\\(\\beta\\) = -40.19, 95% CrI [-104.68, 23.13]; pd = 89.31%, or band type,\\(\\beta\\) = -23.35, 95% CrI [-57.28, 10.35]; pd = 91.52%. However the effect of band order was significant, with the reverse order condition showing lower deviations, \\(\\beta\\) = -73.72, 95% CrI [-136.69, -11.07]; pd = 98.89%. The interaction between training condition and band type was also significant \\(\\beta\\) = 52.66, 95% CrI [14.16, 90.23]; pd = 99.59%, with the varied condition showing disproprionately large deviations on the extrapolation bands compared to the constant group. There was also a significant interaction between band type and band order, \\(\\beta\\) = 80.69, 95% CrI [30.01, 130.93]; pd = 99.89%, such that the reverse order condition showed larger deviations on the extrapolation bands. No other interactions were significant.\n\n\n\nCode\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3td &lt;- testE3 |&gt;  ggplot(aes(x = vb, y = dist,fill=condit)) +\n    stat_summary(geom = \"bar\", position=position_dodge(), fun = mean) +\n    stat_summary(geom = \"errorbar\", position=position_dodge(.9), fun.data = mean_se, width = .4, alpha = .7) + \n    facet_wrap(~bandOrder,ncol=1) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) +\n  labs(x=\"Band\", y=\"Deviation From Target\")\n\n\npe3ce &lt;- bmtd3 |&gt; emmeans( ~condit *bandOrder*bandType) |&gt;\n  gather_emmeans_draws() |&gt;\n condEffects(bandType) + labs(y=\"Absolute Deviation From Band\", x=\"Band Type\") + \n facet_wrap(~bandOrder,ncol=1)\n\np2 &lt;- pe3td + pe3ce + plot_annotation(tag_levels= 'A')\n#ggsave(here::here(\"Assets/figs\", \"e3_test-dev.png\"), p2, width=9, height=8, bg=\"white\")\np2\n\n\n\n\n\n\n\n\nFigure 7: Experiment 3 Testing Accuracy. A) Deviations from target band during testing without feedback stage. B) Conditional effect of condition (Constant vs. Varied) and testing band type (training vs. extrapolation) on testing accuracy. Error bars represent 95% confidence intervals.\n\n\n\n\n\n\n\nCode\n##| label: tbl-e3-bmm-vx\n##| tbl-cap: \"Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\"\n\ne3_vxBMM &lt;- brm(vx ~ condit * bandOrder * bandInt + (1 + bandInt|id),\n                        data=test,file=paste0(here::here(\"data/model_cache\", \"e3_testVxBand_RF_5k\")),\n                        iter=5000,chains=4,silent=0,\n                        control=list(adapt_delta=0.94, max_treedepth=13))\n\n# m1 &lt;- as.data.frame(describe_posterior(e3_vxBMM, centrality = \"Mean\"))\n# m2 &lt;- fixef(e3_vxBMM)\n# mp3 &lt;- m1[, c(1,2,4,5,6)]\n# colnames(mp3) &lt;- c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")                       \n# mp3 |&gt; mutate(across(where(is.numeric), \\(x) round(x, 2))) |&gt;\n#   tibble::remove_rownames() |&gt; \n#   mutate(Term = stringr::str_replace_all(Term, \"b_bandInt\", \"Band\")) |&gt;\n#   mutate(Term = stringr::str_remove(Term, \"b_\")) |&gt;\n#   kable(escape=F,booktabs=T)\n\n#wrap_plots(plot(conditional_effects(e3_vxBMM),points=FALSE,plot=FALSE))\n\ncd1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried\")\nsc1 &lt;- get_coef_details(e3_vxBMM, \"bandInt\")\nintCoef1 &lt;- get_coef_details(e3_vxBMM, \"conditVaried:bandInt\")\nintCoef2 &lt;- get_coef_details(e3_vxBMM, \"bandOrderReverse:bandInt\")\ncoef3 &lt;- get_coef_details(e3_vxBMM,\"conditVaried:bandOrderReverse:bandInt\")\n\n\n\n\n\nTable 7: Experiment 3. Bayesian Mixed Model Predicting Vx as a function of condition (Constant vs. Varied) and Velocity Band\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nEstimate\n95% CrI Lower\n95% CrI Upper\npd\n\n\n\n\nIntercept\n601.83\n504.75\n699.42\n1.00\n\n\nconditVaried\n12.18\n-134.94\n162.78\n0.56\n\n\nbandOrderReverse\n13.03\n-123.89\n144.67\n0.58\n\n\nBand\n0.49\n0.36\n0.62\n1.00\n\n\nconditVaried:bandOrderReverse\n-338.15\n-541.44\n-132.58\n1.00\n\n\nconditVaried:Band\n-0.04\n-0.23\n0.15\n0.67\n\n\nbandOrderReverse:bandInt\n-0.10\n-0.27\n0.08\n0.86\n\n\nconditVaried:bandOrderReverse:bandInt\n0.42\n0.17\n0.70\n1.00\n\n\n\n\n\n\nTesting Discrimination. The full results of the discrimination model are presented in Table 6. For the purposes of assessing group differences in discrimination, only the coefficients including the band variable are of interest. The baseline effect of band represents the slope cofficient for the constant training - original order condition, this effect was significant \\(\\beta\\) = 0.49, 95% CrI [0.36, 0.62]; pd = 100%. Neither of the two way interactions reached significance, \\(\\beta\\) = -0.04, 95% CrI [-0.23, 0.15]; pd = 66.63%, \\(\\beta\\) = -0.1, 95% CrI [-0.27, 0.08]; pd = 86.35%. However, the three way interaction between training condition, band order, and target band was significant, \\(\\beta\\) = 0.42, 95% CrI [0.17, 0.7]; pd = 99.96% - indicating that the varied condition showed a greater slope coefficient on the reverse order bands, compared to the constant condition - this is clearly shown in Figure 8, where the steepness of the best fitting line for the varied-reversed condition is noticably steeper than the other conditions.\n\n\nCode\n##| column: screen-inset-right\n# testE3 |&gt; filter(bandOrder==\"Original\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit()\n# testE3 |&gt; filter(bandOrder==\"Reverse\")|&gt; group_by(id,vb,condit) |&gt; plot_distByCondit() +ggtitle(\"test\")\n\ntestE3 |&gt; group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + \n   ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\n\n\n\n\n\n\nFigure 8: e3 testing x velocities. Translucent bands with dash lines indicate the correct range for each velocity band.\n\n\n\n\n\n\n\nCode\n##| eval: FALSE\n# pe3tv &lt;- testE3 %&gt;% group_by(id,vb,condit,bandOrder) |&gt; plot_distByCondit() + ggh4x::facet_nested_wrap(bandOrder~condit,scale=\"free_x\")\n\n\ncondEffects &lt;- function(m,xvar){\n  m |&gt; ggplot(aes(x = {{xvar}}, y = .value, color = condit, fill = condit)) + \n  stat_dist_pointinterval() + \n  stat_halfeye(alpha=.1, height=.5) +\n  theme(legend.title=element_blank(),axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5)) \n  \n}\n\npe3vce &lt;- e3_vxBMM |&gt; emmeans( ~condit* bandOrder* bandInt, \n                       at = list(bandInt = c(100, 350, 600, 800, 1000, 1200))) |&gt;\n  gather_emmeans_draws() |&gt; \n  condEffects(bandInt) +\n  facet_wrap(~bandOrder,ncol=1) +\n  stat_lineribbon(alpha = .25, size = 1, .width = c(.95)) +\n  scale_x_continuous(breaks = c(100, 350, 600, 800, 1000, 1200), \n                     labels = levels(testE3$vb), \n                     limits = c(0, 1400)) + \nscale_y_continuous(expand=expansion(add=100),breaks=round(seq(0,2000,by=200),2)) +\n  theme(legend.title=element_blank()) + \n  labs(y=\"Velcoity\", x=\"Band\")\n\nfe &lt;- fixef(e3_vxBMM)[,1]\nfixed_effect_bandInt &lt;- fixef(e3_vxBMM)[,1][\"bandInt\"]\nfixed_effect_interaction1 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandInt\"]\nfixed_effect_interaction2 &lt;- fixef(e3_vxBMM)[,1][\"bandOrderReverse:bandInt\"]\nfixed_effect_interaction3 &lt;- fixef(e3_vxBMM)[,1][\"conditVaried:bandOrderReverse:bandInt\"]\n\nre &lt;- data.frame(ranef(e3_vxBMM, pars = \"bandInt\")$id[, ,'bandInt']) |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(e3Sbjs,by=\"id\") |&gt;\n  mutate(adjust= fixed_effect_bandInt + fixed_effect_interaction1*(condit==\"Varied\") + \n           fixed_effect_interaction2*(bandOrder==\"Reverse\") + \n           fixed_effect_interaction3*(condit==\"Varied\" & bandOrder==\"Reverse\"),\n  slope = Estimate + adjust )\n\npid_den3 &lt;- ggplot(re, aes(x = slope, fill = condit)) + \n  geom_density(alpha=.5) + \n  xlim(c(min(re$slope)-.3, max(re$slope)+.3))+\n  geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n   theme(legend.title=element_blank()) + \n  labs(x=\"Slope Coefficient\",y=\"Density\") +\n  facet_wrap(~bandOrder,ncol=1)\n\npid_slopes3 &lt;- re |&gt;  \n    mutate(id=reorder(id,slope)) |&gt;\n  ggplot(aes(y=id, x=slope,fill=condit,color=condit)) + \n    geom_pointrange(aes(xmin=Q2.5+adjust, xmax=Q97.5+adjust)) + \n    geom_vline(xintercept = 1, linetype=\"dashed\",alpha=.5) +\n    theme(legend.title=element_blank(), \n      axis.text.y = element_text(size=6) ) + \n    labs(x=\"Estimated Slope\", y=\"Participant\")  + \n    ggh4x::facet_nested_wrap(bandOrder~condit,axes=\"all\",scales=\"free_y\")\n\np3 &lt;- (pe3vce + pid_den3 + pid_slopes3) + plot_annotation(tag_levels= 'A')\n\n#ggsave(here::here(\"Assets/figs\", \"e3_test-vx.png\"), p3,width=11,height=13, bg=\"white\",dpi=800)\np3\n\n\n\n\n\n\n\n\nFigure 9: Conditional effect of training condition and Band. Ribbons indicate 95% HDI. The steepness of the lines serves as an indicator of how well participants discriminated between velocity bands.\n\n\n\n\n\n\n\nExperiment 3 Summary"
  },
  {
    "objectID": "Sections/full2.html#computational-model",
    "href": "Sections/full2.html#computational-model",
    "title": "Full Dissertation",
    "section": "Computational Model",
    "text": "Computational Model\n\n\nCode\n####| cache: false\n# pacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, \n#                stringr,future,furrr, knitr, reactable,ggstance, htmltools,\n#                ggdist,ggh4x,brms,tidybayes,emmeans,bayestestR, gt)\n# #walk(c(\"dplyr\"), conflict_prefer_all, quiet = TRUE)\n# #options(brms.backend=\"cmdstanr\",mc.cores=4)\n# options(digits=3, scipen=999, dplyr.summarise.inform=FALSE)\n# walk(c(\"Display_Functions\",\"fun_alm\",\"fun_indv_fit\",\"fun_model\", \"prep_model_data\",\"org_functions\"), ~source(here::here(paste0(\"Functions/\", .x, \".R\"))))\n\n\n\n\nCode\n###| cache: true\ninvisible(list2env(load_sbj_data(), envir = .GlobalEnv))\ninvisible(list2env(load_e1(), envir = .GlobalEnv))\ne1Sbjs &lt;- e1 |&gt; group_by(id,condit) |&gt; summarise(n=n())\noptions(contrasts = initial_contrasts)\n# e2_model &lt;- load_e2()\n# e3_model &lt;- load_e3()\n\n\n\n\\[\ndiscrep_{Test}(Data_{sim}, Data_{obs}) = \\frac{1}{6} \\sum_{k=1}^{6} |V_{obs}^{(k)} - V_{sim}^{(k)}|\n\\tag{1}\\]\n\\[\n\\begin{aligned} \\\\\ndiscrep_{Train,constant}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks}} \\sum_{j=1}^{N_{blocks}} |V_{obs,constant}^{(j)} - V_{sim,constant}^{(j)}| \\\\ \\\\\ndiscrep_{Train,varied}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks} \\times 3} \\sum_{j=1}^{N_{blocks}} \\sum_{k=1}^{3} |V_{obs,varied}^{(j,k)} - V_{sim,varied}^{(j,k)}|\n\\end{aligned}\n\\tag{2}\\]\n\nThe final component of our ABC implementation is the determination of an appropriate value of \\(\\epsilon\\). The setting of \\(\\epsilon\\) exerts strong influence on the approximated posterior distribution. Smaller values of \\(\\epsilon\\) increase the rejection rate, and improve the fidelity of the approximated posterior, while larger values result in an ABC sampler that simply reproduces the prior distribution. Because the individual participants in our dataset differed substantially in terms of the noisiness of their data, we employed an adaptive tolerance setting strategy to tailor \\(\\epsilon\\) to each individual. The initial value of \\(\\epsilon\\) was set to the overall standard deviation of each individuals velocity values. Thus, sampled parameter values that generated simulated data within a standard deviation of the observed data were accepted, while worse performing parameters were rejected. After every 300 samples the tolerance was allowed to increase only if the current acceptance rate of the algorithm was less than 1%. In such cases, the tolerance was shifted towards the average discrepancy of the 5 best samples obtained thus far. To ensure the acceptance rate did not become overly permissive, \\(\\epsilon\\) was also allowed to decrease every time a sample was accepted into the posterior. :::\nFor each of the 156 participants from Experiment 1, the ABC algorithm was run until 200 samples of parameters were accepted into the posterior distribution. Obtaining this number of posterior samples required an average of 205,000 simulation runs per participant. Fitting each combination of participant, Model (EXAM & ALM), and fitting method (Test only, Train only, Test & Train) required a total of 192 million simulation runs. To facilitate these intensive computational demands, we used the Future Package in R (Bengtsson, 2021), allowing us to parallelize computations across a cluster of ten M1 iMacs, each with 8 cores.\n\nModelling Results\n\n\nCode\npost_dat_l |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; \n #left_join(testAvgE1, by=join_by(id,condit,x==bandInt)) |&gt;\n ggplot(aes(x=Resp,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n    facet_wrap(~rename_fm(Fit_Method)+condit, ncol=2,strip.position = \"top\", scales = \"free_x\") +\n        scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n         strip.background = element_blank(),\n         strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(10,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions - Experiment 1 Data\", y=\"Vx\")\n\n\n\n\n\n\n\n\nFigure 1: Empirical data and Model predictions for mean velocity across target bands. Fitting methods (Test Only, Test & Train, Train Only) - are separated across rows, and Training Condition (Constant vs. Varied) are separated by columns. Each facet contains the predictions of ALM and EXAM, alongside the observed data.\n\n\n\n\n\n\n\nCode\npdl &lt;- post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; left_join(testAvgE1,by=c(\"id\",\"condit\",\"bandInt\")) |&gt; \n  filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\n# aerror is model error, which is predicted by Model(ALM vs. EXAM) & condit (Constant vs. Varied)\ne1_ee_brm_ae &lt;- brm(data=pdl,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e1_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbct_e1 &lt;- as.data.frame(bayestestR::describe_posterior(e1_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n\np1 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\np2 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n\n\n\n\nCode\np_ce_1 &lt;- (p1 + p2+ p3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\nbm1 &lt;- get_coef_details(e1_ee_brm_ae, \"conditVaried\")\nbm2 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM\")\nbm3 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nposterior_estimates &lt;- as.data.frame(e1_ee_brm_ae) %&gt;%\n  select(starts_with(\"b_\")) %&gt;%\n  setNames(c(\"Intercept\", \"ModelEXAM\", \"conditVaried\", \"ModelEXAM_conditVaried\"))\n\nconstant_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM\nvaried_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM + posterior_estimates$conditVaried + posterior_estimates$ModelEXAM_conditVaried\ncomparison_EXAM &lt;- constant_EXAM - varied_EXAM\nsummary_EXAM &lt;- bayestestR::describe_posterior(comparison_EXAM, centrality = \"Mean\")\n\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NULL)\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NA)\n\n# full set of Model x condit contrasts\n# ALM - EXAM\nbtw_model &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model | condit, re_formula=NULL)  |&gt; \n  pluck(\"contrasts\") |&gt; \n  gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw,condit) |&gt; summarise(value=mean(.value), n=n()) \n\n# btw_model |&gt; ggplot(aes(x=value,y=contrast,fill=condit)) +stat_halfeye()\n\n# Constant - Varied\nemm_condit &lt;- e1_ee_brm_ae |&gt; emmeans(~ condit | Model, re_formula = NULL)\nbtw_con &lt;- emm_condit |&gt;  pairs() |&gt; gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw, Model) |&gt; summarise(value=mean(.value), n=n()) \n# btw_con |&gt; ggplot(aes(x=value,y=Model,fill=Model)) +stat_halfeye()                              \n\np_em_1&lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model*condit, re_formula=NA)  |&gt; \n  pluck(\"contrasts\") |&gt;\n  gather_emmeans_draws() |&gt; \n  group_by(contrast,.draw) |&gt; summarise(value=mean(.value), n=n()) |&gt; \n  filter(!(contrast %in% c(\"ALM Constant - EXAM Constant\",\"ALM Constant - EXAM Varied\",\"ALM Varied - EXAM Varied \", \"EXAM Constant - ALM Varied\" ))) |&gt; \n  ggplot(aes(x=value,y=contrast,fill=contrast)) +stat_halfeye() + labs(x=\"Model Error Difference\",y=\"Contrast\") + theme(legend.position=\"none\") \n\np_ce_1 / p_em_1\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\nCode\n###| eval: false\npdl &lt;- post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; left_join(testAvgE1,by=c(\"id\",\"condit\",\"bandInt\")) |&gt; \n  filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\n# aerror is model error, which is predicted by Model(ALM vs. EXAM) & condit (Constant vs. Varied)\ne1_ee_brm_ae &lt;- brm(data=pdl,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e1_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbct_e1 &lt;- as.data.frame(bayestestR::describe_posterior(e1_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n\np1 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n  ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\np2 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n  labs(x=\"Model\",y=NULL)\np3 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n  scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n  labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \np_ce_1 &lt;- (p1 + p2+ p3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\n# plot_custom_effects &lt;- function(model) {\n#   # Extract posterior samples for fixed effects\n#   post_samples &lt;- posterior_samples(model, pars = c(\"b_Intercept\", \"b_ModelEXAM\", \"b_conditVaried\", \"b_ModelEXAM:conditVaried\"))\n  \n#   # Calculate conditional effects\n#   post_samples &lt;- post_samples %&gt;%\n#     mutate(\n#       ALM_Constant = b_Intercept,\n#       EXAM_Constant = b_Intercept + b_ModelEXAM,\n#       ALM_Varied = b_Intercept + b_conditVaried,\n#       EXAM_Varied = b_Intercept + b_ModelEXAM + b_conditVaried + `b_ModelEXAM:conditVaried`\n#     )\n  \n#   # Reshape data for plotting\n#   plot_data &lt;- post_samples %&gt;%\n#     select(ALM_Constant, EXAM_Constant, ALM_Varied, EXAM_Varied) %&gt;%\n#     pivot_longer(everything(), names_to = \"Condition\", values_to = \"Estimate\") %&gt;%\n#     separate(Condition, into = c(\"Model\", \"Condit\"), sep = \"_\")\n  \n#   # Plot conditional effects\n#   ggplot(plot_data, aes(x = Model, y = Estimate, color = Condit)) +\n#     geom_boxplot() +\n#     theme_minimal() +\n#     labs(x = \"Model\", y = \"Estimate\", color = \"Condition\")\n# }\n# p_ce_1 &lt;- plot_custom_effects(e1_ee_brm_ae)\n\n\n\n\nbm1 &lt;- get_coef_details(e1_ee_brm_ae, \"conditVaried\")\nbm2 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM\")\nbm3 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nposterior_estimates &lt;- as.data.frame(e1_ee_brm_ae) %&gt;%\n  select(starts_with(\"b_\")) %&gt;%\n  setNames(c(\"Intercept\", \"ModelEXAM\", \"conditVaried\", \"ModelEXAM_conditVaried\"))\n\nconstant_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM\nvaried_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM + posterior_estimates$conditVaried + posterior_estimates$ModelEXAM_conditVaried\ncomparison_EXAM &lt;- constant_EXAM - varied_EXAM\nsummary_EXAM &lt;- bayestestR::describe_posterior(comparison_EXAM, centrality = \"Mean\")\n\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NULL)\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NA)\n\n# full set of Model x condit contrasts\n# ALM - EXAM\n# btw_model &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model | condit, re_formula=NULL)  |&gt; \n#   pluck(\"contrasts\") |&gt; \n#   gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw,condit) |&gt; summarise(value=mean(.value), n=n()) \n\n# btw_model |&gt; ggplot(aes(x=value,y=contrast,fill=condit)) +stat_halfeye()\n\n# Constant - Varied\n# emm_condit &lt;- e1_ee_brm_ae |&gt; emmeans(~ condit | Model, re_formula = NULL)\n# btw_con &lt;- emm_condit |&gt;  pairs() |&gt; gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw, Model) |&gt; summarise(value=mean(.value), n=n()) \n# # btw_con |&gt; ggplot(aes(x=value,y=Model,fill=Model)) +stat_halfeye()                              \n\n# p_em_1&lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model*condit, re_formula=NA)  |&gt; \n#   pluck(\"contrasts\") |&gt;\n#   gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw) |&gt; summarise(value=mean(.value), n=n()) |&gt; \n#   filter(!(contrast %in% c(\"ALM Constant - EXAM Constant\",\"ALM Constant - EXAM Varied\",\"ALM Varied - EXAM Varied \", \"EXAM Constant - ALM Varied\" ))) |&gt; \n#   ggplot(aes(x=value,y=contrast,fill=contrast)) +stat_halfeye() + labs(x=\"Model Error Difference\",y=\"Contrast\") + theme(legend.position=\"none\") \n\n# p_ce_1 / p_em_1\n\n\nTo quantitatively assess whether the differences in performance between models, we fit a bayesian regressions predicting the errors of the posterior predictions of each models as a function of the Model (ALM vs. EXAM) and training condition (Constant vs. Varied).\nModel errors were significantly lower for EXAM (\\(\\beta\\) = -37.54, 95% CrI [-60.4, -14.17], pd = 99.85%) than ALM. There was also a significant interaction between Model and Condition (\\(\\beta\\) = 60.42, 95% CrI [36.17, 83.85], pd = 100%), indicating that the advantage of EXAM over ALM was significantly greater for the constant group. To assess whether EXAM predicts constant performance significantly better for Constant than for Varied subjects, we calculated the difference in model error between the Constant and Varied conditions specifically for EXAM. The results indicated that the model error for EXAM was significantly lower in the Constant condition compared to the Varied condition, with a mean difference of -22.88 (95% CrI [-46.02, -0.97], pd = 0.98)."
  },
  {
    "objectID": "Sections/full2.html#alm-exam-description",
    "href": "Sections/full2.html#alm-exam-description",
    "title": "Full Dissertation",
    "section": "ALM & Exam Description",
    "text": "ALM & Exam Description\nALM is a localist neural network model (Page, 2000), with each input node corresponding to a particular stimulus, and each output node corresponding to a particular response value. The units in the input layer activate as a function of their Gaussian similarity to the input stimulus. So, for example, an input stimulus of value 55 would induce maximal activation of the input unit tuned to 55. Depending on the value of the generalization parameter, the nearby units (e.g. 54 and 56; 53 and 57) may also activate to some degree. ALM is structured with input and output nodes that correspond to regions of the stimulus space, and response space, respectively. The units in the input layer activate as a function of their similarity to a presented stimulus. As was the case with the exemplar-based models, similarity in ALM is exponentially decaying function of distance. The input layer is fully connected to the output layer, and the activation for any particular output node is simply the weighted sum of the connection weights between that node and the input activations. The network then produces a response by taking the weighted average of the output units (recall that each output unit has a value corresponding to a particular response). During training, the network receives feedback which activates each output unit as a function of its distance from the ideal level of activation necessary to produce the correct response. The connection weights between input and output units are then updated via the standard delta learning rule, where the magnitude of weight changes are controlled by a learning rate parameter. The EXAM model is an extension of ALM, with the same learning rule and representational scheme for input and output units. EXAM differs from ALM only in its response rule, as it includes a linear extrapolation mechanism for generating novel responses. Although this extrapolation rule departs from a strictly similarity-based generalization mechanism, EXAM is distinct from pure rule-based models in that it remains constrained by the weights learned during training. EXAM retrieves the two nearest training inputs, and the ALM responses associated with those inputs, and computes the slope between these two points. The slope is then used to extrapolate the response to the novel test stimulus. Because EXAM requires at least two input-output pairs to generate a response, additional assumptions were required in order for it to generate resposnes for the constant group. We assumed that participants come to the task with prior knowledge of the origin point (0,0), which can serve as a reference point necessary for the model to generate responses for the constant group. This assumption is motivated by previous function learning research (Brown & Lacroix (2017)), which through a series of manipulations of the y intercept of the underlying function, found that participants consistently demonstrated knowledge of, or a bias towards, the origin point (see Kwantes & Neal (2006) for additional evidence of such a bias in function learning tasks).\nSee Table 8 for a full specification of the equations that define ALM and EXAM, and Figure 10 for a visual representation of the ALM model.\n\n\n\n\nTable 8: ALM & EXAM Equations\n\n\n\n\n\n\n\n\n\n\n\nALM Response Generation\n\n\n\n\n\nInput Activation\n\\(a_i(X) = \\frac{e^{-c(X-X_i)^2}}{\\sum_{k=1}^M e^{-c(X-X_k)^2}}\\)\nInput nodes activate as a function of Gaussian similarity to stimulus\n\n\nOutput Activation\n\\(O_j(X) = \\sum_{k=1}^M w_{ji} \\cdot a_i(X)\\)\nOutput unit \\(O_j\\) activation is the weighted sum of input activations and association weights\n\n\nOutput Probability\n\\(P[Y_j|X] = \\frac{O_j(X)}{\\sum_{k=1}^M O_k(X)}\\)\nThe response, \\(Y_j\\) probabilites computed via Luce’s choice rule\n\n\nMean Output\n\\(m(X) = \\sum_{j=1}^L Y_j \\cdot \\frac{O_j(x)}{\\sum_{k=1}^M O_k(X)}\\)\nWeighted average of probabilities determines response to X\n\n\n\nALM Learning\n\n\n\nFeedback\n\\(f_j(Z) = e^{-c(Z-Y_j)^2}\\)\nfeedback signal Z computed as similarity between ideal response and observed response\n\n\nmagnitude of error\n\\(\\Delta_{ji}=(f_{j}(Z)-o_{j}(X))a_{i}(X)\\)\nDelta rule to update weights.\n\n\nUpdate Weights\n\\(w_{ji}^{new}=w_{ji}+\\eta\\Delta_{ji}\\)\nUpdates scaled by learning rate parameter \\(\\eta\\).\n\n\n\nEXAM Extrapolation\n\n\n\nInstance Retrieval\n\\(P[X_i|X] = \\frac{a_i(X)}{\\sum_{k=1}^M a_k(X)}\\)\nNovel test stimulus \\(X\\) activates input nodes \\(X_i\\)\n\n\nSlope Computation\n\\(S =\\) \\(\\frac{m(X_{1})-m(X_{2})}{X_{1}-X_{2}}\\)\nSlope value, \\(S\\) computed from nearest training instances\n\n\nResponse\n\\(E[Y|X_i] = m(X_i) + S \\cdot [X - X_i]\\)\nALM response \\(m(X_i)\\) adjusted by slope."
  },
  {
    "objectID": "Sections/full2.html#model-fitting",
    "href": "Sections/full2.html#model-fitting",
    "title": "Full Dissertation",
    "section": "Model Fitting",
    "text": "Model Fitting\nTo fit ALM and EXAM to our participant data, we employ a similar method to Mcdaniel et al. (2009), wherein we examine the performance of each model after being fit to various subsets of the data. Each model was fit to the data in with separate procedures: 1) fit to maximize predictions of the testing data, 2) fit to maximize predictions of both the training and testing data, 3) fit to maximize predictions of the just the training data. We refer to this fitting manipulations as “Fit Method” in the tables and figures below. It should be emphasized that for all three fit methods, the ALM and EXAM models behave identically - with weights updating only during the training phase.Models to were fit separately to the data of each individual participant. The free parameters for both models are the generalization (\\(c\\)) and learning rate (\\(lr\\)) parameters. Parameter estimation was performed using approximate bayesian computation (ABC), which we describe in detail below.\n\n\n\n\n\n\n Approximate Bayesian Computation\nTo estimate the parameters of ALM and EXAM, we used approximate bayesian computation (ABC), enabling us to obtain an estimate of the posterior distribution of the generalization and learning rate parameters for each individual. ABC belongs to the class of simulation-based inference methods (Cranmer et al., 2020), which have begun being used for parameter estimation in cognitive modeling relatively recently (Kangasrääsiö et al., 2019; Turner et al., 2016; Turner & Van Zandt, 2012). Although they can be applied to any model from which data can be simulated, ABC methods are most useful for complex models that lack an explicit likelihood function (e.g. many neural network models).\nThe general ABC procedure is to 1) define a prior distribution over model parameters. 2) sample candidate parameter values, \\(\\theta^*\\), from the prior. 3) Use \\(\\theta^*\\) to generate a simulated dataset, \\(Data_{sim}\\). 4) Compute a measure of discrepancy between the simulated and observed datasets, \\(discrep\\)(\\(Data_{sim}\\), \\(Data_{obs}\\)). 5) Accept \\(\\theta^*\\) if the discrepancy is less than the tolerance threshold, \\(\\epsilon\\), otherwise reject \\(\\theta^*\\). 6) Repeat until desired number of posterior samples are obtained.\nAlthough simple in the abstract, implementations of ABC require researchers to make a number of non-trivial decisions as to i) the discrepancy function between observed and simulated data, ii) whether to compute the discrepancy between trial level data, or a summary statistic of the datasets, iii) the value of the minimum tolerance \\(\\epsilon\\) between simulated and observed data. For the present work, we follow the guidelines from previously published ABC tutorials (Farrell & Lewandowsky, 2018; Turner & Van Zandt, 2012). For the test stage, we summarized datasets with mean velocity of each band in the observed dataset as \\(V_{obs}^{(k)}\\) and in the simulated dataset as \\(V_{sim}^{(k)}\\), where \\(k\\) represents each of the six velocity bands. For computing the discrepancy between datasets in the training stage, we aggregated training trials into three equally sized blocks (separately for each velocity band in the case of the varied group). After obtaining the summary statistics of the simulated and observed datasets, the discrepancy was computed as the mean of the absolute difference between simulated and observed datasets (Equation 1 and Equation 2). For the models fit to both training and testing data, discrepancies were computed for both stages, and then averaged together.\n\n\\[\ndiscrep_{Test}(Data_{sim}, Data_{obs}) = \\frac{1}{6} \\sum_{k=1}^{6} |V_{obs}^{(k)} - V_{sim}^{(k)}|\n\\tag{1}\\]\n\\[\n\\begin{aligned} \\\\\ndiscrep_{Train,constant}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks}} \\sum_{j=1}^{N_{blocks}} |V_{obs,constant}^{(j)} - V_{sim,constant}^{(j)}| \\\\ \\\\\ndiscrep_{Train,varied}(Data_{sim}, Data_{obs}) = \\frac{1}{N_{blocks} \\times 3} \\sum_{j=1}^{N_{blocks}} \\sum_{k=1}^{3} |V_{obs,varied}^{(j,k)} - V_{sim,varied}^{(j,k)}|\n\\end{aligned}\n\\tag{2}\\]\n\nThe final component of our ABC implementation is the determination of an appropriate value of \\(\\epsilon\\). The setting of \\(\\epsilon\\) exerts strong influence on the approximated posterior distribution. Smaller values of \\(\\epsilon\\) increase the rejection rate, and improve the fidelity of the approximated posterior, while larger values result in an ABC sampler that simply reproduces the prior distribution. Because the individual participants in our dataset differed substantially in terms of the noisiness of their data, we employed an adaptive tolerance setting strategy to tailor \\(\\epsilon\\) to each individual. The initial value of \\(\\epsilon\\) was set to the overall standard deviation of each individuals velocity values. Thus, sampled parameter values that generated simulated data within a standard deviation of the observed data were accepted, while worse performing parameters were rejected. After every 300 samples the tolerance was allowed to increase only if the current acceptance rate of the algorithm was less than 1%. In such cases, the tolerance was shifted towards the average discrepancy of the 5 best samples obtained thus far. To ensure the acceptance rate did not become overly permissive, \\(\\epsilon\\) was also allowed to decrease every time a sample was accepted into the posterior.\n\n\n\nFor each of the 156 participants from Experiment 1, the ABC algorithm was run until 200 samples of parameters were accepted into the posterior distribution. Obtaining this number of posterior samples required an average of 205,000 simulation runs per participant. Fitting each combination of participant, Model (EXAM & ALM), and fitting method (Test only, Train only, Test & Train) required a total of 192 million simulation runs. To facilitate these intensive computational demands, we used the Future Package in R (Bengtsson, 2021), allowing us to parallelize computations across a cluster of ten M1 iMacs, each with 8 cores.\n\nModelling Results\n\nGroup level Patterns\n\n\nCode\npost_tabs &lt;- abc_tables(post_dat,post_dat_l)\ntrain_tab &lt;- abc_train_tables(pd_train,pd_train_l)\n\ne1_tab &lt;- rbind(post_tabs$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Test\"), train_tab$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne1_tab %&gt;%\n  group_by(`Task Stage`, Fit_Method, Model, condit) %&gt;%\n  summarize(ME = mean(mean_error), .groups = \"drop\") %&gt;%\n  pivot_wider(\n    names_from = c(Model, condit),\n    values_from = ME,\n    names_sep = \"_\"  # Add this line to specify the separator for column names\n  ) %&gt;%\n  rename(\"Fit Method\" = Fit_Method) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = c(`Task Stage`)) %&gt;%\n  cols_label(\n    `Task Stage` = \"Task Stage\"\n  ) %&gt;%\n  fmt_number(\n    columns = starts_with(\"ALM\") | starts_with(\"EXAM\"),\n    decimals = 2\n  ) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = cell_fill(color = \"white\"),\n     locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_style(\n    style = cell_borders(sides = \"top\", color = \"black\", weight = px(1)),\n    locations = cells_column_labels()\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10, \n    quarto.disable_processing = TRUE\n  ) \n\n\n\n\nTable 9: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      Task Stage\n      Fit Method\n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    Test\nFit to Test Data\n199.93\n103.36\n104.01\n85.68\n    Test\nFit to Test & Training Data\n216.97\n170.28\n127.94\n144.86\n    Test\nFit to Training Data\n467.73\n291.38\n273.30\n297.91\n    Train\nFit to Test Data\n297.82\n2,016.01\n53.90\n184.00\n    Train\nFit to Test & Training Data\n57.40\n132.32\n42.92\n127.90\n    Train\nFit to Training Data\n51.77\n103.48\n51.43\n107.03\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nc_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=log(c), x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.2)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"c parameter\") +\n  theme(legend.title = element_blank(), legend.position=\"right\",plot.title=element_text(hjust=.4))\n\nlr_post &lt;- post_dat_avg %&gt;%\n    group_by(id, condit, Model, Fit_Method, rank) %&gt;%\n    slice_head(n = 1) |&gt;\n    ggplot(aes(y=lr, x = Fit_Method,col=condit)) + stat_pointinterval(position=position_dodge(.4)) +\n    ggh4x::facet_nested_wrap(~Model) + labs(title=\"learning rate parameter\") +\n  theme(legend.title = element_blank(), legend.position = \"none\",plot.title=element_text(hjust=.5))\nc_post + lr_post\n\n\n\n\n\n\n\n\nFigure 11: Posterior Distributions of \\(c\\) and \\(lr\\) parameters. Points represent median values, thicker intervals represent 66% credible intervals and thin intervals represent 95% credible intervals around the median. Note that the y axes of the plots for the c parameter are scaled logarithmically.\n\n\n\n\n\n\n\nCode\ntrain_resid &lt;- pd_train |&gt; group_by(id,condit,Model,Fit_Method, Block,x) |&gt; \n  summarise(y=mean(y), pred=mean(pred), mean_error=abs(y-pred)) |&gt;\n  group_by(id,condit,Model,Fit_Method,Block) |&gt;\n  summarise(mean_error=mean(mean_error)) |&gt;\n  ggplot(aes(x=interaction(Block,Model), y = mean_error, fill=factor(Block))) + \n  stat_bar + \n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, scales=\"free\",ncol=2) +\n   scale_x_discrete(guide = \"axis_nested\") +\n  scale_fill_manual(values=c(\"gray10\",\"gray50\",\"gray92\"))+\n  labs(title=\"Model Residual Errors - Training Stage\", y=\"RMSE\", x= \"Model\",fill=\"Training Block\") +\n  theme(legend.position=\"top\")\n\ntest_resid &lt;-  post_dat |&gt; \n   group_by(id,condit,x,Model,Fit_Method,bandType) |&gt;\n    summarise(y=mean(y), pred=mean(pred), error=abs(y-pred)) |&gt; \n  mutate(vbLab = factor(paste0(x,\"-\",x+200))) |&gt;\n  ggplot(aes(x = Model, y = abs(error), fill=vbLab,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n  #scale_fill_manual(values=wes_palette(\"AsteroidCity2\"))+\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n  ggh4x::facet_nested_wrap(rename_fm(Fit_Method)~condit, axes = \"all\",ncol=2,scale=\"free\") +\n  labs(title=\"Model Residual Errors - Testing Stage\",y=\"RMSE\", x=\"Velocity Band\") \n\n(train_resid / test_resid) +\n  #plot_layout(heights=c(1,1.5)) & \n  plot_annotation(tag_levels = list(c('A','B')),tag_suffix = ') ') \n\n\n\n\n\n\n\n\nFigure 12: Model residuals for each combination of training condition, fit method, and model. Residuals reflect the difference between observed and predicted values. Lower values indicate better model fit. Note that y axes are scaled differently between facets. A) Residuals predicting each block of the training data. B) Residuals predicting each band during the testing stage. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\nThe posterior distributions of the \\(c\\) and \\(lr\\) parameters are shown Figure 11, and model predictions are shown alongside the empirical data in Figure 13. There were substantial individual differences in the posteriors of both parameters, with the within-group individual differences generally swamped any between-group or between-model differences. The magnitude of these individual differences remains even if we consider only the single best parameter set for each subject.\nWe used the posterior distribution of \\(c\\) and \\(lr\\) parameters to generate a posterior predictive distribution of the observed data for each participant, which then allows us to compare the empirical data to the full range of predictions from each model. Aggregated residuals are displayed in Figure 12. The pattern of training stage residual errors are unsurprising across the combinations of models and fitting method . Differences in training performance between ALM and EXAM are generally minor (the two models have identical learning mechanisms). The differences in the magnitude of residuals across the three fitting methods are also straightforward, with massive errors for the ‘fit to Test Only’ model, and the smallest errors for the ‘fit to train only’ models. It is also noteworthy that the residual errors are generally larger for the first block of training, which is likely due to the initial values of the ALM weights being unconstrained by whatever initial biases participants tend to bring to the task. Future work may explore the ability of the models to capture more fine grained aspects of the learning trajectories. However for the present purposes, our primary interest is in the ability of ALM and EXAM to account for the testing patterns while being constrained, or not constrained, by the training data. All subsequent analyses and discussion will thus focus on the testing stage.\nThe residuals of the model predictions for the testing stage (Figure 12) also show an unsurprising pattern across fitting methods - with models fit only to the test data showing the best performance, followed by models fit to both training and test data, and with models fit only to the training data showing the worst performance (note that y axes are scaled different between plots). Although EXAM tends to perform better for both Constant and Varied participants (see also ?@fig-ee-e1), the relative advantage of EXAM is generally larger for the Constant group - a pattern consistent across all three fitting methods. The primary predictive difference between ALM and EXAM is made clear in Figure 13, which directly compares the observed data against the posterior predictive distributions for both models. Regardless of how the models are fit, only EXAM can capture the pattern where participants are able to discriminate all 6 target bands.\n\n\nCode\npost_dat_l |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; \n #left_join(testAvgE1, by=join_by(id,condit,x==bandInt)) |&gt;\n ggplot(aes(x=Resp,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar + \n    facet_wrap(~rename_fm(Fit_Method)+condit, ncol=2,strip.position = \"top\", scales = \"free_x\") +\n        scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .5), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n         strip.background = element_blank(),\n         strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(10,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions - Experiment 1 Data\", y=\"Vx\")\n\n\n\n\n\n\n\n\nFigure 13: Empirical data and Model predictions for mean velocity across target bands. Fitting methods (Test Only, Test & Train, Train Only) - are separated across rows, and Training Condition (Constant vs. Varied) are separated by columns. Each facet contains the predictions of ALM and EXAM, alongside the observed data.\n\n\n\n\n\n\n\nCode\n###| eval: false\npdl &lt;- post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; left_join(testAvgE1,by=c(\"id\",\"condit\",\"bandInt\")) |&gt; \n  filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\n# aerror is model error, which is predicted by Model(ALM vs. EXAM) & condit (Constant vs. Varied)\ne1_ee_brm_ae &lt;- brm(data=pdl,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e1_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbct_e1 &lt;- as.data.frame(bayestestR::describe_posterior(e1_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n\n# p1 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"conditVaried \"),points=FALSE, plot=FALSE)$condit + \n#   ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\n# p2 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n#   labs(x=\"Model\",y=NULL)\n# p3 &lt;- plot(conditional_effects(e1_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n#   scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n#   labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n# p_ce_1 &lt;- (p1 + p2+ p3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\nplot_custom_effects &lt;- function(model) {\n  # Extract posterior samples for fixed effects\n  post_samples &lt;- posterior_samples(model, pars = c(\"b_Intercept\", \"b_ModelEXAM\", \"b_conditVaried\", \"b_ModelEXAM:conditVaried\"))\n  \n  # Calculate conditional effects\n  post_samples &lt;- post_samples %&gt;%\n    mutate(\n      ALM_Constant = b_Intercept,\n      EXAM_Constant = b_Intercept + b_ModelEXAM,\n      ALM_Varied = b_Intercept + b_conditVaried,\n      EXAM_Varied = b_Intercept + b_ModelEXAM + b_conditVaried + `b_ModelEXAM:conditVaried`\n    )\n  \n  # Reshape data for plotting\n  plot_data &lt;- post_samples %&gt;%\n    select(ALM_Constant, EXAM_Constant, ALM_Varied, EXAM_Varied) %&gt;%\n    pivot_longer(everything(), names_to = \"Condition\", values_to = \"Estimate\") %&gt;%\n    separate(Condition, into = c(\"Model\", \"Condit\"), sep = \"_\")\n  \n  # Plot conditional effects\n  ggplot(plot_data, aes(x = Model, y = Estimate, color = Condit)) +\n    geom_boxplot() +\n    theme_minimal() +\n    labs(x = \"Model\", y = \"Estimate\", color = \"Condition\")\n}\np_ce_1 &lt;- plot_custom_effects(e1_ee_brm_ae)\n\n\n\n\nbm1 &lt;- get_coef_details(e1_ee_brm_ae, \"conditVaried\")\nbm2 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM\")\nbm3 &lt;- get_coef_details(e1_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nposterior_estimates &lt;- as.data.frame(e1_ee_brm_ae) %&gt;%\n  select(starts_with(\"b_\")) %&gt;%\n  setNames(c(\"Intercept\", \"ModelEXAM\", \"conditVaried\", \"ModelEXAM_conditVaried\"))\n\nconstant_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM\nvaried_EXAM &lt;- posterior_estimates$Intercept + posterior_estimates$ModelEXAM + posterior_estimates$conditVaried + posterior_estimates$ModelEXAM_conditVaried\ncomparison_EXAM &lt;- constant_EXAM - varied_EXAM\nsummary_EXAM &lt;- bayestestR::describe_posterior(comparison_EXAM, centrality = \"Mean\")\n\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NULL)\n# e1_ee_brm_ae |&gt; emmeans(pairwise ~ Model * condit, re_formula=NA)\n\n# full set of Model x condit contrasts\n# ALM - EXAM\n# btw_model &lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model | condit, re_formula=NULL)  |&gt; \n#   pluck(\"contrasts\") |&gt; \n#   gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw,condit) |&gt; summarise(value=mean(.value), n=n()) \n\n# btw_model |&gt; ggplot(aes(x=value,y=contrast,fill=condit)) +stat_halfeye()\n\n# Constant - Varied\n# emm_condit &lt;- e1_ee_brm_ae |&gt; emmeans(~ condit | Model, re_formula = NULL)\n# btw_con &lt;- emm_condit |&gt;  pairs() |&gt; gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw, Model) |&gt; summarise(value=mean(.value), n=n()) \n# # btw_con |&gt; ggplot(aes(x=value,y=Model,fill=Model)) +stat_halfeye()                              \n\n# p_em_1&lt;- e1_ee_brm_ae |&gt; emmeans(pairwise~ Model*condit, re_formula=NA)  |&gt; \n#   pluck(\"contrasts\") |&gt;\n#   gather_emmeans_draws() |&gt; \n#   group_by(contrast,.draw) |&gt; summarise(value=mean(.value), n=n()) |&gt; \n#   filter(!(contrast %in% c(\"ALM Constant - EXAM Constant\",\"ALM Constant - EXAM Varied\",\"ALM Varied - EXAM Varied \", \"EXAM Constant - ALM Varied\" ))) |&gt; \n#   ggplot(aes(x=value,y=contrast,fill=contrast)) +stat_halfeye() + labs(x=\"Model Error Difference\",y=\"Contrast\") + theme(legend.position=\"none\") \n\n# p_ce_1 / p_em_1\n\n\nTo quantitatively assess whether the differences in performance between models, we fit a bayesian regressions predicting the errors of the posterior predictions of each models as a function of the Model (ALM vs. EXAM) and training condition (Constant vs. Varied).\nModel errors were significantly lower for EXAM (\\(\\beta\\) = -37.54, 95% CrI [-60.4, -14.17], pd = 99.85%) than ALM. There was also a significant interaction between Model and Condition (\\(\\beta\\) = 60.42, 95% CrI [36.17, 83.85], pd = 100%), indicating that the advantage of EXAM over ALM was significantly greater for the constant group. To assess whether EXAM predicts constant performance significantly better for Constant than for Varied subjects, we calculated the difference in model error between the Constant and Varied conditions specifically for EXAM. The results indicated that the model error for EXAM was significantly lower in the Constant condition compared to the Varied condition, with a mean difference of -22.88 (95% CrI [-46.02, -0.97], pd = 0.98).\n\n\nCode\npost_tabs2 &lt;- abc_tables(e2_model$post_dat,e2_model$post_dat_l)\ntrain_tab2 &lt;- abc_train_tables(e2_model$pd_train,e2_model$pd_train_l)\n\npdl2 &lt;- e2_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne2_tab &lt;- rbind(post_tabs2$agg_pred_full |&gt;\n mutate(\"Task Stage\"=\"Test\"), train_tab2$agg_pred_full |&gt; \n mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\npost_tabs3 &lt;- abc_tables(e3_model$post_dat,e3_model$post_dat_l)\ntrain_tab3 &lt;- abc_train_tables(e3_model$pd_train,e3_model$pd_train_l)\n\npdl3 &lt;- e3_model$post_dat_l |&gt; rename(\"bandInt\"=x) |&gt; filter(rank&lt;=1,Fit_Method==\"Test_Train\", !(Resp==\"Observed\")) |&gt; mutate(aerror = abs(error))\n\ne3_tab &lt;- rbind(post_tabs3$agg_pred_full |&gt; \n  mutate(\"Task Stage\"=\"Test\"), train_tab3$agg_pred_full |&gt; mutate(\"Task Stage\"=\"Train\")) |&gt; \n  mutate(Fit_Method=rename_fm(Fit_Method)) \n\ne23_tab &lt;- rbind(e2_tab |&gt; mutate(Exp=\"E2\"), e3_tab |&gt; mutate(Exp=\"E3\")) \ngt_table &lt;- e23_tab %&gt;%\n  pivot_wider(\n    names_from = c(Exp, Model, condit),\n    values_from = mean_error,\n    names_glue = \"{Exp}_{Model}_{condit}\"\n  ) %&gt;%\n  arrange(Fit_Method, `Task Stage`) %&gt;%\n  gt() %&gt;%\n  cols_move_to_start(columns = `Task Stage`) %&gt;%\n  cols_label(`Task Stage` = \"Task Stage\") %&gt;%\n  fmt_number(columns = matches(\"E2|E3\"), decimals = 1) %&gt;%\n  tab_spanner_delim(delim = \"_\") %&gt;%\n  tab_style(\n    style = list(\n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(columns = everything(), rows = everything())\n  ) %&gt;%\n  tab_options(\n    column_labels.font.size = 10,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.font.size = 10,\n    quarto.disable_processing = TRUE\n  ) \ngt_table\n\n\n\n\nTable 10: Models errors predicting empirical data - aggregated over all participants, posterior parameter values, and velocity bands. Note that Fit Method refers to the subset of the data that the model was trained on, while Task Stage refers to the subset of the data that the model was evaluated on.\n\n\n\n\n\n\n  \n    \n      \n      \n        E2\n      \n      \n        E3\n      \n    \n    \n      Task Stage\n      \n        ALM\n      \n      \n        EXAM\n      \n      \n        ALM\n      \n      \n        EXAM\n      \n    \n    \n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n      Constant\n      Varied\n    \n  \n  \n    \n      Fit to Test Data\n    \n    Test\n239.7\n129.8\n99.7\n88.2\n170.1\n106.1\n92.3\n72.8\n    Train\n53.1\n527.1\n108.1\n169.3\n70.9\n543.5\n157.8\n212.7\n    \n      Fit to Test & Training Data\n    \n    Test\n266.0\n208.2\n125.1\n126.4\n197.7\n189.5\n130.0\n128.5\n    Train\n40.0\n35.4\n30.4\n23.6\n49.1\n85.6\n49.2\n78.4\n    \n      Fit to Training Data\n    \n    Test\n357.4\n295.9\n305.1\n234.5\n415.0\n298.8\n295.5\n243.7\n    Train\n42.5\n23.0\n43.2\n22.6\n51.4\n63.8\n51.8\n65.3\n  \n  \n  \n\n\n\n\n\n\n\n\n\nCode\nrbind(e2_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb) |&gt; \n summarize(vx=median(val)) |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\"), \n e3_model$post_dat_l |&gt; filter( Fit_Method==\"Test_Train\") |&gt; \n  group_by(id,condit, Fit_Method,Resp,bandType,x,vb,bandOrder) |&gt;\n  summarize(vx=median(val)) |&gt; mutate(Exp=\"E3\")) |&gt;\n  ggplot( aes(x=condit,y=vx, fill=vb,col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) +\n  stat_bar + \n    facet_nested_wrap(~Exp+bandOrder+Resp, strip.position = \"top\", scales = \"free_x\") +\n    scale_color_manual(values = c(\"black\" = \"black\"), guide = \"none\") +\n  scale_size_manual(values = c(\"black\" = .7), guide = \"none\") +\n    theme(panel.spacing = unit(0, \"lines\"), \n        #  strip.background = element_blank(),\n        #  strip.placement = \"outside\",\n         legend.position = \"none\",plot.title = element_text(hjust=.50),\n         axis.title.x = element_blank(),\n         plot.margin = unit(c(20,0,0,0), \"pt\")) + \n         labs(title=\"Model Predictions Experiment 2 & 3\", y=\"vx\")\n\n\n\n\n\n\n\n\nFigure 14: Empirical data and Model predictions from Experiment 2 and 3 for the testing stage. Observed data is shown on the right. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands.\n\n\n\n\n\n\n\nCode\ne2_ee_brm_ae &lt;- brm(data=pdl2,\n  aerror ~  Model * condit + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e2_ae_modelCond_RFint.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"conditVaried\")\nbm2_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM\")\nbm3_e2 &lt;- get_coef_details(e2_ee_brm_ae, \"ModelEXAM:conditVaried\")\n\nbct_e2 &lt;- as.data.frame(bayestestR::describe_posterior(e2_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) # %&gt;% kable(booktabs = TRUE)\n\ne3_ee_brm_ae &lt;- brm(data=pdl3,\n  aerror ~  Model * condit*bandOrder + (1+bandInt|id), \n  file = paste0(here(\"data/model_cache/e3_ae_modelCondBo_RFint2.rds\")),\n  chains=4,silent=1, iter=2000, control=list(adapt_delta=0.92, max_treedepth=11))\n\nbm1_e3 &lt;- get_coef_details(e3_ee_brm_ae, \"conditVaried\")\nbm2_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM\")\nbm3_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried\")\nbm4_e3  &lt;- get_coef_details(e3_ee_brm_ae, \"ModelEXAM:conditVaried:bandOrderReverse\")\n\n\nbct_e3  &lt;- as.data.frame(bayestestR::describe_posterior(e3_ee_brm_ae, centrality = \"Mean\")) %&gt;%\n  select(1,2,4,5,6) %&gt;%\n  setNames(c(\"Term\", \"Estimate\",\"95% CrI Lower\", \"95% CrI Upper\", \"pd\")) %&gt;%\n  mutate(across(where(is.numeric), \\(x) round(x, 2))) %&gt;%\n  tibble::remove_rownames() %&gt;%\n  mutate(Term = stringr::str_remove(Term, \"b_\")) #%&gt;% kable(booktabs = TRUE)\n\nbct &lt;- rbind(bct_e1 |&gt; mutate(exp=\"Exp 1\"),bct_e2 |&gt; \n               mutate(exp= \"Exp 2\"),bct_e3 |&gt; mutate(exp=\"Exp 3\")) |&gt; \n  relocate(exp, .before=Term)\n\nbct_table &lt;- bct %&gt;%\n  mutate(\n    across(c(Estimate, `95% CrI Lower`, `95% CrI Upper`), ~ round(., 2)),\n    pd = round(pd, 2)\n  ) %&gt;%\n  gt() %&gt;%\n  # tab_header(\n  #   title = \"Bayesian Model Results\",\n  #   subtitle = \"Estimates and Credible Intervals for Each Term Across Experiments\"\n  # ) %&gt;%\n  cols_label(\n    exp = \"Experiment\",\n    Term = \"Term\",\n    Estimate = \"Estimate\",\n    `95% CrI Lower` = \"95% CrI Lower\",\n    `95% CrI Upper` = \"95% CrI Upper\",\n    pd = \"pd\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(Estimate, `95% CrI Lower`, `95% CrI Upper`),\n    decimals = 2\n  ) %&gt;%\n  fmt_number(\n    columns = pd,\n    decimals = 2\n  ) %&gt;%\n  tab_spanner(\n    label = \"Credible Interval\",\n    columns = c(`95% CrI Lower`, `95% CrI Upper`)\n  ) %&gt;%\n  tab_style(\n    style = list(\n      #cell_fill(color = \"lightgray\"),\n      cell_text(weight = \"bold\"), \n      cell_fill(color = \"white\"),\n      cell_borders(sides = \"top\", color = \"black\", weight = px(1))\n    ),\n    locations = cells_body(\n      columns = c(Estimate, pd),\n      rows = Term==\"ModelEXAM:conditVaried\"\n    )\n  ) %&gt;%\n   tab_row_group(\n    label = \"Experiment 3\",\n    rows = exp == \"Exp 3\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 2\",\n    rows = exp == \"Exp 2\"\n  ) %&gt;%\n  tab_row_group(\n    label = \"Experiment 1\",\n    rows = exp == \"Exp 1\"\n  ) %&gt;%\n  tab_options(\n    table.font.size = 10,\n    heading.title.font.size = 16,\n    heading.subtitle.font.size = 14,\n    quarto.disable_processing = TRUE\n    #row_group.background.color = \"gray95\"\n  )\nbct_table\n\n\n\n\nTable 11: Results of Bayesian Regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and the interaction between Model and Condition. The values represent the estimate coefficient for each term, with 95% credible intervals in brackets. The intercept reflects the baseline of ALM and Constant. The other estimates indicate deviations from the baseline for the EXAM mode and varied condition. Lower values indicate better model fit.\n\n\n\n\n\n\n  \n    \n      Experiment\n      Term\n      Estimate\n      \n        Credible Interval\n      \n      pd\n    \n    \n      95% CrI Lower\n      95% CrI Upper\n    \n  \n  \n    \n      Experiment 1\n    \n    Exp 1\nIntercept\n176.30\n156.86\n194.59\n1.00\n    Exp 1\nModelEXAM\n−88.44\n−104.51\n−71.81\n1.00\n    Exp 1\nconditVaried\n−37.54\n−60.40\n−14.17\n1.00\n    Exp 1\nModelEXAM:conditVaried\n60.42\n36.17\n83.85\n1.00\n    \n      Experiment 2\n    \n    Exp 2\nIntercept\n245.87\n226.18\n264.52\n1.00\n    Exp 2\nModelEXAM\n−137.73\n−160.20\n−115.48\n1.00\n    Exp 2\nconditVaried\n−86.39\n−113.52\n−59.31\n1.00\n    Exp 2\nModelEXAM:conditVaried\n56.87\n25.26\n88.04\n1.00\n    \n      Experiment 3\n    \n    Exp 3\nIntercept\n164.83\n140.05\n189.44\n1.00\n    Exp 3\nModelEXAM\n−65.66\n−85.97\n−46.02\n1.00\n    Exp 3\nconditVaried\n−40.61\n−75.90\n−3.02\n0.98\n    Exp 3\nbandOrderReverse\n25.47\n−9.34\n58.68\n0.93\n    Exp 3\nModelEXAM:conditVaried\n41.90\n11.20\n72.54\n0.99\n    Exp 3\nModelEXAM:bandOrderReverse\n−7.32\n−34.53\n21.05\n0.70\n    Exp 3\nconditVaried:bandOrderReverse\n30.82\n−19.57\n83.56\n0.88\n    Exp 3\nModelEXAM:conditVaried:bandOrderReverse\n−60.60\n−101.80\n−18.66\n1.00\n  \n  \n  \n\n\n\n\n\n\n\nModel Fits to Experiment 2 and 3. Data from Experiments 2 and 3 were fit to ALM and EXAM in the same manner as Experiment1 . For brevity, we only plot and discuss the results of the “fit to training and testing data” models - results from the other fitting methods can be found in the appendix. The model fitting results for Experiments 2 and 3 closely mirrored those observed in Experiment 1. The Bayesian regression models predicting model error as a function of Model (ALM vs. EXAM), Condition (Constant vs. Varied), and their interaction (see Table 11) revealed a consistent main effect of Model across all three experiments. The negative coefficients for the ModelEXAM term (Exp 2: \\(\\beta\\) = -86.39, 95% CrI -113.52, -59.31, pd = 100%; Exp 3: \\(\\beta\\) = -40.61, 95% CrI -75.9, -3.02, pd = 98.17%) indicate that EXAM outperformed ALM in both experiments. Furthermore, the interaction between Model and Condition was significant in both Experiment 2 (\\(\\beta\\) = 56.87, 95% CrI 25.26, 88.04, pd = 99.98%) and Experiment 3 (\\(\\beta\\) = 41.9, 95% CrI 11.2, 72.54, pd = 99.35%), suggesting that the superiority of EXAM over ALM was more pronounced for the Constant group compared to the Varied group, as was the case in Experiment 1. Recall that Experiment 3 included participants in both the original and reverse order conditions - and that this manipulation interacted with the effect of training condition. We thus also controleld for band order in our Bayesian Regression assessing the relative performance of EXAM and ALM in Experiment 3. There was a significant three way interaction between Model, Training Condition, and Band Order (\\(\\beta\\) = -60.6, 95% CrI -101.8, -18.66, pd = 99.83%), indicating that the relative advantage of EXAM over ALM was only more pronounced in the original order condition, and not the reverse order condition (see ?@fig-e2_e3_ae).\n\n\nCode\n#wrap_plots(plot(conditional_effects(e1_ee_brm_ae),points=FALSE,plot=FALSE))\n# p1 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n#   ggplot2::xlab(\"Condition\") +ylab(\"Model Error\") + labs(title=\"E2. Model Error\")\n# p2 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n#   labs(x=\"Model\",y=NULL)\n# p3 &lt;- plot(conditional_effects(e2_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n#   scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n#   labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n#  p_e2 &lt;- (p1 + p2+ p3) \n# #wrap_plots(plot(conditional_effects(e3_ee_brm_ae),points=FALSE,plot=FALSE))\n\n# p_e3 &lt;- plot(conditional_effects(e3_ee_brm_ae, \n#                          effects = \"Model:condit\", \n#                          conditions=make_conditions(e3_ee_brm_ae,vars=c(\"bandOrder\"))),\n#      points=FALSE,plot=FALSE)$`Model:condit` + \n#      labs(x=\"Model\",y=\"Model Error\", title=\"E3. Model Error\", fill=NULL, col=NULL) + \n#      theme(legend.position=\"right\") + \n#      scale_color_manual(values=wes_palette(\"Darjeeling1\")) \n\n# p1 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"condit\"),points=FALSE, plot=FALSE)$condit + \n#   ggplot2::xlab(\"Condition\") +ylab(\"Model Error\")\n# p2 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model\"),points=FALSE, plot=FALSE)$Model + \n#   labs(x=\"Model\",y=NULL)\n# p3 &lt;- plot(conditional_effects(e3_ee_brm_ae, effects=\"Model:condit\"),points=FALSE, plot=FALSE)$`Model:condit` + \n#   scale_color_manual(values=wes_palette(\"Darjeeling1\")) +\n#   labs(x=\"Model\",y=NULL,fill=NULL,col=NULL) + theme(legend.position=\"right\") \n  \n #p2 &lt;- (p1 + p2+ p3)\n #(p_e2 / p_e3) + plot_annotation(tag_levels = c('A'), tag_suffix=\".\")\n\n\nComputational Model Summary. Across the model fits to all three experiments, we found greater support for EXAM over ALM (negative coefficients on the ModelEXAM term in Table 11), and moreover that the constant participants were disproportionately well described by EXAM in comparison to ALM (positive coefficients on ModelEXAM:conditVaried terms in Table 11). This pattern is also clearly depicted in Figure 15, which plots the difference in model errors between ALM and EXAM for each individual participant. Both varied and constant conditions have a greater proportion of subjects better fit by EXAM (positive error differences), with the magnitude of EXAM’s advantage visibly greater for the constant group. It also bears mention that numerous participants were better fit by ALM, or did not show a clear preference for either model. A subset of these participants are shown in Figure 16.\n\n\nCode\ntid1 &lt;- post_dat  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-pred_dist, -dist) |&gt;\n  rbind(e2_model$post_dat |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat |&gt; mutate(Exp=\"E3\")) |&gt;\n  filter(Fit_Method==\"Test_Train\") |&gt;\n  group_by(id,condit,Model,Fit_Method,x, Exp) |&gt; \n    mutate(e2=abs(y-pred)) |&gt; \n    summarise(y1=median(y), pred1=median(pred),mean_error=abs(y1-pred1)) |&gt;\n    group_by(id,condit,Model,Fit_Method,Exp) |&gt; \n    summarise(mean_error=mean(mean_error)) |&gt; \n    arrange(id,condit,Fit_Method) |&gt;\n    round_tibble(1) \n\nbest_id &lt;- tid1 |&gt; \n  group_by(id,condit,Fit_Method) |&gt; \n  mutate(best=ifelse(mean_error==min(mean_error),1,0)) \n\nlowest_error_model &lt;- best_id %&gt;%\n  group_by(id, condit,Fit_Method, Exp) %&gt;%\n  summarise(Best_Model = Model[which.min(mean_error)],\n            Lowest_error = min(mean_error),\n            differential = min(mean_error) - max(mean_error)) %&gt;%\n  ungroup()\n\nerror_difference&lt;- best_id %&gt;%\n  select(id, condit, Model,Fit_Method, mean_error) %&gt;%\n  pivot_wider(names_from = Model, values_from = c(mean_error)) %&gt;%\n  mutate(Error_difference = (ALM - EXAM))\n\nfull_comparison &lt;- lowest_error_model |&gt; \n  left_join(error_difference, by=c(\"id\",\"condit\",\"Fit_Method\"))  |&gt; \n  group_by(condit,Fit_Method,Best_Model) |&gt; \n  mutate(nGrp=n(), model_rank = nGrp - rank(Error_difference) ) |&gt; \n  arrange(Fit_Method,-Error_difference)\n\nfull_comparison |&gt; \n  filter(Fit_Method==\"Test_Train\") |&gt; \n  ungroup() |&gt;\n  mutate(id = reorder(id, Error_difference)) %&gt;%\n  ggplot(aes(y=id,x=Error_difference,fill=Best_Model))+\n  geom_col() +\n  #ggh4x::facet_grid2(~condit,axes=\"all\",scales=\"free_y\", independent = \"y\")+\n  ggh4x::facet_nested_wrap(~condit+Exp,scales=\"free\") + \n  theme(axis.text.y = element_text(size=8)) +\n  labs(fill=\"Best Model\",\n  x=\"Mean Model Error Difference (ALM - EXAM)\",\n  y=\"Participant\")\n\n\n\n\n\n\n\n\nFigure 15: Difference in model errors for each participant, with models fit to both train and test data. Positive values favor EXAM, while negative values favor ALM.\n\n\n\n\n\n\n\nCode\ncId_tr &lt;- c(137, 181, 11)\nvId_tr &lt;- c(14, 193, 47)\ncId_tt &lt;- c(11, 93, 35)\nvId_tt &lt;- c(1,14,74)\ncId_new &lt;- c(175, 68, 93, 74)\n# filter(id %in% (filter(bestTestEXAM,group_rank&lt;=9, Fit_Method==\"Test\")\n\ne1_sbjs &lt;- c(49,68,155, 175,74)\ne3_sbjs &lt;-  c(245, 280, 249)\ne2_sbjs &lt;- c(197, 157, 312, 334)\ncFinal &lt;- c(49, 128,202 )\nvFinal &lt;- c(68,70,245)\n\n\nindv_post_l &lt;- post_dat_l  |&gt; mutate(Exp=\"E1\",bandOrder=\"Original\") |&gt; select(-signed_dist) |&gt;\n  rbind(e2_model$post_dat_l |&gt; mutate(Exp=\"E2\",bandOrder=\"Reverse\")) |&gt;\n  rbind(e3_model$post_dat_l |&gt; mutate(Exp=\"E3\") |&gt; select(-fb)) |&gt;\n  filter(Fit_Method==\"Test_Train\", id %in% c(cFinal,vFinal))\n\ntestIndv &lt;- indv_post_l |&gt; \n#filter(id %in% c(cId_tt,vId_tt,cId_new), Fit_Method==\"Test_Train\") |&gt; \n   mutate(x=as.factor(x), Resp=as.factor(Resp)) |&gt;\n  group_by(id,condit,Fit_Method,Model,Resp) |&gt;\n   mutate(flab=paste0(\"Subject: \",id)) |&gt;\n  ggplot(aes(x = Resp, y = val, fill=vb, col=ifelse(bandType==\"Trained\",\"black\",NA),size=ifelse(bandType==\"Trained\",\"black\",NA))) + \n  stat_bar_sd + \n  ggh4x::facet_nested_wrap(condit~flab, axes = \"all\",ncol=3) +\n  scale_color_manual(values = c(\"black\" = \"black\"), guide = FALSE) +\n  scale_size_manual(values = c(\"black\" = .5), guide = FALSE) + \n  labs(title=\"Individual Participant fits from Test & Train Fitting Method\",\n       y=\"X Velocity\",fill=\"Target Velocity\") +\n   guides(fill = guide_legend(nrow = 1)) + \n  theme(legend.position = \"bottom\",axis.title.x = element_blank())\n\ntestIndv \n\n\n\n\n\n\n\n\nFigure 16: Model predictions alongside observed data for a subset of individual participants. A) 3 constant and 3 varied participants fit to both the test and training data. B) 3 constant and 3 varied subjects fit to only the trainign data. Bolded bars indicate bands that were trained, non-bold bars indicate extrapolation bands."
  },
  {
    "objectID": "Sections/full2.html#comparison-to-project-1",
    "href": "Sections/full2.html#comparison-to-project-1",
    "title": "Full Dissertation",
    "section": "Comparison to Project 1",
    "text": "Comparison to Project 1\n\nDifferences between the tasks\nThere are a number of differences between Project 1’s Hit The Target (HTT), and Project 2’s Hit The Wall (HTW) tasks.\n\nTask Space Complexity: In HTW, the task space is also almost perfectly smooth, at least for the continuous feedback subjects, if they throw 100 units too hard, they’ll be told that they were 100 units too hard. Whereas in HTT,  it was possible to produce xy velocity combinations that were technically closer to the empirical solution space than other throws, but which resulted in worse feedback due to striking the barrier.\nPerceptual Distinctiveness: HTT offers perceptually distinct varied conditions that directly relate to the task’s demands, which may increase the sallience between training positions encounted by the varied group. In contrast, HTW’s varied conditions differ only in the numerical values displayed, lacking the same level of perceptual differentiation. Conversely in HTW, the only difference between conditions for the varied group are the numbers displayed at the top of the screen which indicate the current target band(e.g. 800-1000, or 1000-1200)\nIn HTW, our primary testing stage of interest has no feedback, whereas in HTT testing always included feedback (the intermittent testing in HTT expt 1 being the only exception). Of course, we do collect testing with feedback data at the end of HTW, but we haven’t focused on that data at all in our modelling work thus far. It’s also interesting to recall that the gap between varied and constant in HTW does seem to close substantially in the testing-with-feedback stage. The difference between no-feedback and feedback testing might be relevant if the benefits of variation have anything to do with improving subsequent learning (as opposed to subsequent immediate performance), OR if the benefits of constant training rely on having the most useful anchor, having the most useful anchor might be a lot less helpful if you’re getting feedback from novel positions and can thus immediately begin to form position-specific anchors for the novelties, rather than relying on a training anchor. \nHTW and HTT both have a similar amount of training trials (~200), and thus the constant groups acquire a similar amount of experience with their single position/velocity in both experiments. However, the varied conditions in both HTT experiments train on 2 positions, whereas the varied group in HTW trains on 3 velocity bands. This means that in HTT the varied group gets half as much experience on any one position as the constant group, and in HTW they only get 1/3 as much experience in any one position. There are likely myriad ways in which this might impact the success of the varied group regardless of how you think the benefits of variation might be occurring, e.g. maybe they also need to develop a coherent anchor, maybe they need more experience in order to extract a function, or more experience in order to properly learn to tune their c parameter."
  },
  {
    "objectID": "Sections/Discussion.html#comparison-to-project-1",
    "href": "Sections/Discussion.html#comparison-to-project-1",
    "title": "General Discussion",
    "section": "",
    "text": "There are a number of differences between Project 1’s Hit The Target (HTT), and Project 2’s Hit The Wall (HTW) tasks.\n\nTask Space Complexity: In HTW, the task space is also almost perfectly smooth, at least for the continuous feedback subjects, if they throw 100 units too hard, they’ll be told that they were 100 units too hard. Whereas in HTT,  it was possible to produce xy velocity combinations that were technically closer to the empirical solution space than other throws, but which resulted in worse feedback due to striking the barrier.\nPerceptual Distinctiveness: HTT offers perceptually distinct varied conditions that directly relate to the task’s demands, which may increase the sallience between training positions encounted by the varied group. In contrast, HTW’s varied conditions differ only in the numerical values displayed, lacking the same level of perceptual differentiation. Conversely in HTW, the only difference between conditions for the varied group are the numbers displayed at the top of the screen which indicate the current target band(e.g. 800-1000, or 1000-1200)\nIn HTW, our primary testing stage of interest has no feedback, whereas in HTT testing always included feedback (the intermittent testing in HTT expt 1 being the only exception). Of course, we do collect testing with feedback data at the end of HTW, but we haven’t focused on that data at all in our modelling work thus far. It’s also interesting to recall that the gap between varied and constant in HTW does seem to close substantially in the testing-with-feedback stage. The difference between no-feedback and feedback testing might be relevant if the benefits of variation have anything to do with improving subsequent learning (as opposed to subsequent immediate performance), OR if the benefits of constant training rely on having the most useful anchor, having the most useful anchor might be a lot less helpful if you’re getting feedback from novel positions and can thus immediately begin to form position-specific anchors for the novelties, rather than relying on a training anchor. \nHTW and HTT both have a similar amount of training trials (~200), and thus the constant groups acquire a similar amount of experience with their single position/velocity in both experiments. However, the varied conditions in both HTT experiments train on 2 positions, whereas the varied group in HTW trains on 3 velocity bands. This means that in HTT the varied group gets half as much experience on any one position as the constant group, and in HTW they only get 1/3 as much experience in any one position. There are likely myriad ways in which this might impact the success of the varied group regardless of how you think the benefits of variation might be occurring, e.g. maybe they also need to develop a coherent anchor, maybe they need more experience in order to extract a function, or more experience in order to properly learn to tune their c parameter.",
    "crumbs": [
      "General Discussion"
    ]
  },
  {
    "objectID": "Sections/Discussion.html#project-comparison",
    "href": "Sections/Discussion.html#project-comparison",
    "title": "General Discussion",
    "section": "Project comparison",
    "text": "Project comparison\nTo facilitate ease of comparison between the two projects and their respective tasks, we’ll now refer to project 1 as Hit The Target (HTT) and project 2 as Hit The Wall (HTW).\nTask Structure - hitting target vs. hitting wall with correct force\nFeedback - relation between feedback and correction - usefulness of feedback was part of what makes HTW different from HTT. And in general in visuomotor learning tasks, feedback usually is not quite as precise as it is in HTW. - consistency of HTW finding across continuous vs. ordinal makes it seem like this wasn’t the sole determinative factor.\nForm of Variation - varied vs. constant in both Projects. - varied group in HTT trained on 2 positions, whereas the varied group in HTW trained on 3 velocity bands. - In HTT - distinct positions, in HTW - distinct numbers.\n\nDifferences between the tasks\nThere are a number of differences between Project 1’s Hit The Target (HTT), and Project 2’s Hit The Wall (HTW) tasks.\n\nTask Space Complexity: In HTW, the task space is also almost perfectly smooth, at least for the continuous feedback subjects, if they throw 100 units too hard, they’ll be told that they were 100 units too hard. Whereas in HTT,  it was possible to produce xy velocity combinations that were technically closer to the empirical solution space than other throws, but which resulted in worse feedback due to striking the barrier.\nPerceptual Distinctiveness: HTT offers perceptually distinct varied conditions that directly relate to the task’s demands, which may increase the sallience between training positions encounted by the varied group. In contrast, HTW’s varied conditions differ only in the numerical values displayed, lacking the same level of perceptual differentiation. Conversely in HTW, the only difference between conditions for the varied group are the numbers displayed at the top of the screen which indicate the current target band(e.g. 800-1000, or 1000-1200)\nIn HTW, our primary testing stage of interest has no feedback, whereas in HTT testing always included feedback (the intermittent testing in HTT expt 1 being the only exception). Of course, we do collect testing with feedback data at the end of HTW, but we haven’t focused on that data at all in our modelling work thus far. It’s also interesting to recall that the gap between varied and constant in HTW does seem to close substantially in the testing-with-feedback stage. The difference between no-feedback and feedback testing might be relevant if the benefits of variation have anything to do with improving subsequent learning (as opposed to subsequent immediate performance), OR if the benefits of constant training rely on having the most useful anchor, having the most useful anchor might be a lot less helpful if you’re getting feedback from novel positions and can thus immediately begin to form position-specific anchors for the novelties, rather than relying on a training anchor. \nHTW and HTT both have a similar amount of training trials (~200), and thus the constant groups acquire a similar amount of experience with their single position/velocity in both experiments. However, the varied conditions in both HTT experiments train on 2 positions, whereas the varied group in HTW trains on 3 velocity bands. This means that in HTT the varied group gets half as much experience on any one position as the constant group, and in HTW they only get 1/3 as much experience in any one position. There are likely myriad ways in which this might impact the success of the varied group regardless of how you think the benefits of variation might be occurring, e.g. maybe they also need to develop a coherent anchor, maybe they need more experience in order to extract a function, or more experience in order to properly learn to tune their c parameter.",
    "crumbs": [
      "General Discussion"
    ]
  },
  {
    "objectID": "Sections/Discussion.html#tables",
    "href": "Sections/Discussion.html#tables",
    "title": "General Discussion",
    "section": "Tables",
    "text": "Tables\n1h-mis\n\n\n\n\n\n\n\n\n\nDimension\nHTT (IGAS)\nHTW (ALM & EXAM)\n\n\n\n\nTask Complexity\nIn HTT, both x and y velocity dimensions are relevant to the outcome, requiring a parabolic trajectory. The task space is more complex, with the possibility of producing xy velocity combinations that are technically closer to the empirical solution space but result in worse feedback due to striking the barrier.\nIn HTW, only the x velocity dimension is relevant to the outcome, with the trajectory not mattering. The task space is simpler and smoother, with feedback directly related to the force applied.\n\n\nDimensionality of Instance-Based Mechanisms\nIn HTT, the instance-based mechanisms might work well due to the task’s multi-dimensional nature, making it easier to retain separate traces.\nIn HTW, instance-based mechanisms might not work as well due to the task’s simple, 1-dimensional nature, making it more difficult to retain separate traces.\n\n\nPerceptual Distinctness of Conditions\nIn HTT, the different varied conditions are more perceptually distinct and correspond directly to the task at hand (e.g., throwing from 500 vs. 800).\nIn HTW, the difference between conditions for the varied group is only the number displayed at the top of the screen (e.g., 800-1000 or 1000-1200), which might be less salient.\n\n\nFeedback During Testing\nIn HTT, testing always includes feedback, except for intermittent testing in Experiment 1.\nIn HTW, the primary testing stage of interest has no feedback, with feedback testing occurring at the end but not focused on in the modeling work.\n\n\nNumber of Training Positions/Velocities\nIn HTT, the varied group trains on 2 positions, while the constant group trains on 1 position.\nIn HTW, the varied group trains on 3 velocity bands, while the constant group trains on 1 velocity band.\n\n\nTesting Trial Order\nIn HTT, testing trials are randomly ordered, with participants experiencing trials from their training position and the training position of the other groups.\nIn HTW, no-feedback testing is split into 2 non-overlapping stages, with novel velocity bands encountered in a separate block from the testing of trained positions.\n\n\nIntermittent Testing Trials\nIn HTT, intermittent testing trials are included in Experiment 1 with the ball trajectory fully masked.\nIn HTW, there are more no-feedback intermittent testing trials.\n\n\nEpisodic Re-activation during Testing\nIn HTT, episodic re-activation of training exemplars might occur more frequently due to the randomly ordered testing positions, which include trained positions. This could potentially benefit an episodic mechanism.\nIn HTW, the varied subjects are always further away in time and number of trials from re-encountering one of their training locations/bands during testing, which might reduce the potential benefits of episodic re-activation.\n\n\n\n\n   \n2a\n\n\n\n\n\n\n\n\n\nDimension\nProject 1 (HTT)\nProject 2 (HTW)\n\n\n\n\nTask Type\nProjectile launching to hit a target\nProjectile launching to hit a wall at a specific velocity\n\n\nInput Dimensions\nTwo velocity components (x and y), but only x velocity relevant for hitting the target\nOne velocity component (x) relevant for hitting the wall\n\n\nOutput Dimensions\nDistance from the target\nVelocity at which the ball hits the wall\n\n\nFeedback Type\nContinuous feedback indicating distance from the target\nContinuous feedback indicating deviation from target velocity band (Exp. 1 and 2); Ordinal feedback (too soft, too hard, or correct) (Exp. 3)\n\n\nGeneralization Type\nGeneralization to novel locations\nExtrapolation to novel velocity bands\n\n\nComputational Models\nInstance-based Generalization with Adaptive Similarity (IGAS)\nAssociative Learning Model (ALM) and Extrapolation-Association Model (EXAM)\n\n\nModel Assumptions\nAdaptive tuning of generalization function based on training variability\nALM: Similarity-based generalization; EXAM: Linear extrapolation mechanism\n\n\nStatistical Analysis\nFrequentist null hypothesis testing\nBayesian hierarchical modeling\n\n\n\n\n\n2b\n\n\n\n\n\n\n\n\n\nDimension\nHTT (Project 1)\nHTW (Project 2)\n\n\n\n\nTask Type\nVisuomotor Skill Learning\nVisuomotor Function Learning\n\n\nDependent Variable\nAccuracy (Distance from Target)\nAccuracy (Distance from Target Band)\n\n\nTraining Manipulation\nConstant vs. Varied Throwing Locations\nConstant vs. Varied Velocity Bands\n\n\nTesting\nIncluded both trained and novel throwing locations\nIncluded both trained and novel velocity bands\n\n\nModeling Approach\nInstance-Based Similarity Model (IGAS)\nAssociative Learning Model (ALM), Extrapolation-Association Model (EXAM)\n\n\nModel Fitting\nFit to all participants, allowed generalization parameter to vary between conditions\nFit to individual participants using Approximate Bayesian Computation\n\n\nKey Findings\nVaried training led to superior performance, accounted for by adaptive generalization gradient\nVaried training led to poorer performance and less band discrimination, better captured by EXAM than ALM\n\n\nNovelty\nFirst study to apply an instance-based similarity model to explain benefits of varied training in visuomotor skill learning\nFirst study to investigate effects of training variability in a visuomotor function learning task",
    "crumbs": [
      "General Discussion"
    ]
  },
  {
    "objectID": "Sections/Discussion.html#general-discussion",
    "href": "Sections/Discussion.html#general-discussion",
    "title": "General Discussion",
    "section": "General Discussion",
    "text": "General Discussion\nTo facilitate ease of comparison between the two projects and their respective tasks, we’ll now refer to project 1 as Hit The Target (HTT) and project 2 as Hit The Wall (HTW).\n\nEmpirical Results Summary\n\n\nDifferences between the two Projects\nAlthough the HTT and HTW tasks are similiar in requiring participants to learn how to correctly launch projectiles, they nevertheless differ across numerous dimensions that may be relevant to the opposing patterns observed in the two projects (see Table 1 provides for a detailed comparison of the two tasks).\nIn HTT, the salient perceptual elements of the task (i.e. the launching box, target and barrier) are subject to variation (i.e. different distances between the launching box and target), and the spatial layout of these perceptually variable elements are intrinsically linked to the task objective of striking the target. Conversely, the perceptual task elements in HTW are invariant across trials, and the task objective is specified by the target velocity value specified as a numeral at the top of the screen. If the benefits of training variation do arise from the formation and flexible retrieval of distinct memory traces, then the lack of perceptual salience between training instances in the HTW task may have limited any potential benefits of variability. Future work could investigate this possibility further employing a modified version of the HTW task wherein the correct velocity value is indicated by some perceptual feature of the task (e.g. the color of the wall, or size of the ball), rather than displaying the target velocity numerically.\nThe HTT and HTW tasks also differed in terms of general task complexity. The HTT task was designed to mimic projectile launching tasks commonly employed in visuomotor learning studies, and the parabolic trajectories necessary to strike the target in HTT were sensitive to both the x and y dimensions of the projectiles velocity (and to a lesser extent, the position within the launching box at which the ball was released). Conversely the HTW task was influenced to a greater extent by the tasks commonly utilized in the function learning literature, wherein the correct output respones are determined by a single input dimension.\n\n\n\nTable 1: Comparison of the tasks in Project 1 (HTT) and Project 2 (HTW).\n\n\n\n\n\n\n\n\n\n\nDimension\nHTT (Project 1)\nHTW (Project 2)\n\n\n\n\nTask Description\nProjectile launching to hit a target\nProjectile launching to hit wall at a specific velocity\n\n\nTask Complexity\nMore complex parabolic trajectory, both x and y velocities relevant to outcome\nSimpler 1D mapping of force to outcome. Only x velocity is relevant.\n\n\nTask Space\nMore complex: xy velocity combinations closer to the solution space may still result in worse feedback due to striking the barrier.\nSimpler: smooth, linear mapping between velocity and feedback.\n\n\nPerceptual salience of Varied Conditions\nVaried conditions (# of throwing distances) are perceptually distinct, i.e. salient differences in distance between launching box and target.\nVaried conditions (# of velocity bands) are less salient - only difference is the numeral displayed on screen.\n\n\nTesting Feedback\nTesting always included feedback\nPrimary testing stage had no feedback.\n\n\nPotential for Learning during Testing\nLimited potential for learning during testing due to feedback.\nSome potential for learning during no-feedback testing by observing ball trajectory.\n\n\nPosition/Velocity Experience\nVaried group gets half as much experience on any one position as the constant group.\nVaried group gets 1/3 as much experience on any one velocity band as the constant group.\n\n\nTesting Structure\nRandom interleaving of trained/transfer testing distances.\nBlocked structure, separately testing trained vs extrapolation testing bands.\n\n\n\n\n\n\n    \n\nRework the section on “Differences between the two Projects” include more speculation on how the perceptual distinctiveness of the task conditions may have memory or attentional consequences that relate to when training variation is useful. In particular discussing connections to ideas from instance based, or exemplar-based memory models of learning (e.g. works of Gordan Logan; Nosofsky; Crump, Hintzman, Estes etc.)",
    "crumbs": [
      "General Discussion"
    ]
  }
]